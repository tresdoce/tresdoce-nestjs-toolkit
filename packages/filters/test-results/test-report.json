{
  "stats": {
    "suites": 2,
    "tests": 14,
    "passes": 14,
    "pending": 0,
    "failures": 0,
    "testsRegistered": 14,
    "passPercent": 100,
    "pendingPercent": 0,
    "other": 0,
    "hasOther": false,
    "skipped": 0,
    "hasSkipped": false,
    "start": "2023-05-03T01:38:11.536Z",
    "end": "2023-05-03T01:38:11.550Z",
    "duration": 14
  },
  "results": [
    {
      "uuid": "9ab5f2ad-876c-4d82-92bf-abd44f19b23c",
      "title": "@tresdoce-nestjs-toolkit/filters",
      "fullFile": "",
      "file": "",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "bb515838-7be9-485c-b847-d6ffd7912a1a",
          "title": "@tresdoce-nestjs-toolkit/filters",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "fullTitle": "filters > code exception > should map a regular code exception",
              "title": "filters > code exception > should map a regular code exception",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "2e8d027c-bf11-448c-b8aa-99e3445a3904",
              "parentUUID": "bb515838-7be9-485c-b847-d6ffd7912a1a",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > default Http exceptions > should map default exception when thrown with not parameters",
              "title": "filters > default Http exceptions > should map default exception when thrown with not parameters",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "5d99a745-a295-4a76-bc00-8ba613b31c78",
              "parentUUID": "bb515838-7be9-485c-b847-d6ffd7912a1a",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > default Http exceptions > should map default exception when thrown with error details",
              "title": "filters > default Http exceptions > should map default exception when thrown with error details",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "0b7c0fb4-438c-43b4-815a-2062767dda34",
              "parentUUID": "bb515838-7be9-485c-b847-d6ffd7912a1a",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > default Http exceptions > should map default exception when thrown with error details and description",
              "title": "filters > default Http exceptions > should map default exception when thrown with error details and description",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "fee192fc-34f9-41f5-b13e-ce35a67ac701",
              "parentUUID": "bb515838-7be9-485c-b847-d6ffd7912a1a",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > default Http exceptions > the generic HttpException > should map HttpException response when called with a string",
              "title": "filters > default Http exceptions > the generic HttpException > should map HttpException response when called with a string",
              "timedOut": false,
              "duration": 3,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "a96bd8e3-87d8-4125-9df5-e36672a96cc8",
              "parentUUID": "bb515838-7be9-485c-b847-d6ffd7912a1a",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > default Http exceptions > the generic HttpException > should map HttpException response when called with an object",
              "title": "filters > default Http exceptions > the generic HttpException > should map HttpException response when called with an object",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "7e6ba16e-6667-4e4f-8125-e156c30968e3",
              "parentUUID": "bb515838-7be9-485c-b847-d6ffd7912a1a",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > default Http exceptions > the generic HttpException > should map HttpException response when called with an object with empty message",
              "title": "filters > default Http exceptions > the generic HttpException > should map HttpException response when called with an object with empty message",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "153eb51c-a67a-49e4-8ff7-443de448d179",
              "parentUUID": "bb515838-7be9-485c-b847-d6ffd7912a1a",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > default Http exceptions > the generic HttpException > should map HttpException response when called with an array",
              "title": "filters > default Http exceptions > the generic HttpException > should map HttpException response when called with an array",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "66855cfb-867c-4ced-a7c3-e347251ddef1",
              "parentUUID": "bb515838-7be9-485c-b847-d6ffd7912a1a",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > default Http exceptions > should map HttpException response when called with an object",
              "title": "filters > default Http exceptions > should map HttpException response when called with an object",
              "timedOut": false,
              "duration": 0,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "615cc7c9-28c9-4c32-b13d-9d55b4620c2b",
              "parentUUID": "bb515838-7be9-485c-b847-d6ffd7912a1a",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > when used outside a module > should map default exception when thrown with not parameters",
              "title": "filters > when used outside a module > should map default exception when thrown with not parameters",
              "timedOut": false,
              "duration": 0,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "1e4e5e25-95bd-4119-bc5d-9f13729872c7",
              "parentUUID": "bb515838-7be9-485c-b847-d6ffd7912a1a",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > configuration is defined with values > should be return application info",
              "title": "filters > configuration is defined with values > should be return application info",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "6f90cbf3-a29f-46b3-9e5b-0514343754d1",
              "parentUUID": "bb515838-7be9-485c-b847-d6ffd7912a1a",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "error.utils > should be return code in string",
              "title": "error.utils > should be return code in string",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { getCode } from '../';\nimport { HttpStatus } from '@nestjs/common';\n\ndescribe('error.utils', () => {\n  it('should be return code in string', () => {\n    const code = getCode(HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR]);\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n\n  it('should be return code in string obj', () => {\n    const code = getCode({ error: HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR] });\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n\n  it('should be return code in string', () => {\n    const code = getCode({ error: HttpStatus['TEST_ERROR'] });\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n});\n",
              "err": {},
              "uuid": "e61f45a7-f6fc-4c18-ba96-3a6f0dfa1180",
              "parentUUID": "bb515838-7be9-485c-b847-d6ffd7912a1a",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "error.utils > should be return code in string obj",
              "title": "error.utils > should be return code in string obj",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { getCode } from '../';\nimport { HttpStatus } from '@nestjs/common';\n\ndescribe('error.utils', () => {\n  it('should be return code in string', () => {\n    const code = getCode(HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR]);\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n\n  it('should be return code in string obj', () => {\n    const code = getCode({ error: HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR] });\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n\n  it('should be return code in string', () => {\n    const code = getCode({ error: HttpStatus['TEST_ERROR'] });\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n});\n",
              "err": {},
              "uuid": "2da13459-be95-4a13-adf0-6bf20526f1c6",
              "parentUUID": "bb515838-7be9-485c-b847-d6ffd7912a1a",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "error.utils > should be return code in string",
              "title": "error.utils > should be return code in string",
              "timedOut": false,
              "duration": 0,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { getCode } from '../';\nimport { HttpStatus } from '@nestjs/common';\n\ndescribe('error.utils', () => {\n  it('should be return code in string', () => {\n    const code = getCode(HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR]);\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n\n  it('should be return code in string obj', () => {\n    const code = getCode({ error: HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR] });\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n\n  it('should be return code in string', () => {\n    const code = getCode({ error: HttpStatus['TEST_ERROR'] });\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n});\n",
              "err": {},
              "uuid": "6599412f-2809-41c5-b41e-ba001b751824",
              "parentUUID": "bb515838-7be9-485c-b847-d6ffd7912a1a",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "2e8d027c-bf11-448c-b8aa-99e3445a3904",
            "5d99a745-a295-4a76-bc00-8ba613b31c78",
            "0b7c0fb4-438c-43b4-815a-2062767dda34",
            "fee192fc-34f9-41f5-b13e-ce35a67ac701",
            "a96bd8e3-87d8-4125-9df5-e36672a96cc8",
            "7e6ba16e-6667-4e4f-8125-e156c30968e3",
            "153eb51c-a67a-49e4-8ff7-443de448d179",
            "66855cfb-867c-4ced-a7c3-e347251ddef1",
            "615cc7c9-28c9-4c32-b13d-9d55b4620c2b",
            "1e4e5e25-95bd-4119-bc5d-9f13729872c7",
            "6f90cbf3-a29f-46b3-9e5b-0514343754d1",
            "e61f45a7-f6fc-4c18-ba96-3a6f0dfa1180",
            "2da13459-be95-4a13-adf0-6bf20526f1c6",
            "6599412f-2809-41c5-b41e-ba001b751824"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 14,
          "root": false,
          "rootEmpty": false,
          "_timeout": 5000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 5000
    }
  ]
}
