{
  "stats": {
    "suites": 2,
    "tests": 14,
    "passes": 14,
    "pending": 0,
    "failures": 0,
    "testsRegistered": 14,
    "passPercent": 100,
    "pendingPercent": 0,
    "other": 0,
    "hasOther": false,
    "skipped": 0,
    "hasSkipped": false,
    "start": "2023-05-05T13:18:18.744Z",
    "end": "2023-05-05T13:18:18.761Z",
    "duration": 17
  },
  "results": [
    {
      "uuid": "7a309b9f-81ec-44db-a70c-34772ca802df",
      "title": "@tresdoce-nestjs-toolkit/filters",
      "fullFile": "",
      "file": "",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "4e0fc067-c8de-4af8-9096-d112fd14f523",
          "title": "@tresdoce-nestjs-toolkit/filters",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "fullTitle": "filters > code exception > should map a regular code exception",
              "title": "filters > code exception > should map a regular code exception",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "b4acf2f5-90db-4855-92ff-eb793179824e",
              "parentUUID": "4e0fc067-c8de-4af8-9096-d112fd14f523",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > default Http exceptions > should map default exception when thrown with not parameters",
              "title": "filters > default Http exceptions > should map default exception when thrown with not parameters",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "9e419ce0-bee9-49af-933f-d1c43ac36606",
              "parentUUID": "4e0fc067-c8de-4af8-9096-d112fd14f523",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > default Http exceptions > should map default exception when thrown with error details",
              "title": "filters > default Http exceptions > should map default exception when thrown with error details",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "b65b96d1-61ec-423c-a772-f9a71b8b412e",
              "parentUUID": "4e0fc067-c8de-4af8-9096-d112fd14f523",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > default Http exceptions > should map default exception when thrown with error details and description",
              "title": "filters > default Http exceptions > should map default exception when thrown with error details and description",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "2ae5669d-9ef1-4c66-9b2a-88ff43f1237e",
              "parentUUID": "4e0fc067-c8de-4af8-9096-d112fd14f523",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > default Http exceptions > the generic HttpException > should map HttpException response when called with a string",
              "title": "filters > default Http exceptions > the generic HttpException > should map HttpException response when called with a string",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "1a0873b3-9a92-41c0-a365-2d11ce793409",
              "parentUUID": "4e0fc067-c8de-4af8-9096-d112fd14f523",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > default Http exceptions > the generic HttpException > should map HttpException response when called with an object",
              "title": "filters > default Http exceptions > the generic HttpException > should map HttpException response when called with an object",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "f861e391-3d0f-4b4a-a790-6af316fc7177",
              "parentUUID": "4e0fc067-c8de-4af8-9096-d112fd14f523",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > default Http exceptions > the generic HttpException > should map HttpException response when called with an object with empty message",
              "title": "filters > default Http exceptions > the generic HttpException > should map HttpException response when called with an object with empty message",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "7ddfd827-e22b-4bc1-a375-a0e7348850dd",
              "parentUUID": "4e0fc067-c8de-4af8-9096-d112fd14f523",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > default Http exceptions > the generic HttpException > should map HttpException response when called with an array",
              "title": "filters > default Http exceptions > the generic HttpException > should map HttpException response when called with an array",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "962c9544-619d-4a6a-8958-847b1c8e0c53",
              "parentUUID": "4e0fc067-c8de-4af8-9096-d112fd14f523",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > default Http exceptions > should map HttpException response when called with an object",
              "title": "filters > default Http exceptions > should map HttpException response when called with an object",
              "timedOut": false,
              "duration": 0,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "b4d5699c-de68-402b-8118-daddf80b1bde",
              "parentUUID": "4e0fc067-c8de-4af8-9096-d112fd14f523",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > when used outside a module > should map default exception when thrown with not parameters",
              "title": "filters > when used outside a module > should map default exception when thrown with not parameters",
              "timedOut": false,
              "duration": 0,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "ea8688aa-e22d-43bb-8339-d3797d01f6a5",
              "parentUUID": "4e0fc067-c8de-4af8-9096-d112fd14f523",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > configuration is defined with values > should be return application info",
              "title": "filters > configuration is defined with values > should be return application info",
              "timedOut": false,
              "duration": 0,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "7ffa0cd7-e6c3-42b0-a005-211c7d123570",
              "parentUUID": "4e0fc067-c8de-4af8-9096-d112fd14f523",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "error.utils > should be return code in string",
              "title": "error.utils > should be return code in string",
              "timedOut": false,
              "duration": 7,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { getCode } from '../';\nimport { HttpStatus } from '@nestjs/common';\n\ndescribe('error.utils', () => {\n  it('should be return code in string', () => {\n    const code = getCode(HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR]);\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n\n  it('should be return code in string obj', () => {\n    const code = getCode({ error: HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR] });\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n\n  it('should be return code in string', () => {\n    const code = getCode({ error: HttpStatus['TEST_ERROR'] });\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n});\n",
              "err": {},
              "uuid": "9cac9cc4-8442-4cb7-9609-d75010cf1cc3",
              "parentUUID": "4e0fc067-c8de-4af8-9096-d112fd14f523",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "error.utils > should be return code in string obj",
              "title": "error.utils > should be return code in string obj",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { getCode } from '../';\nimport { HttpStatus } from '@nestjs/common';\n\ndescribe('error.utils', () => {\n  it('should be return code in string', () => {\n    const code = getCode(HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR]);\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n\n  it('should be return code in string obj', () => {\n    const code = getCode({ error: HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR] });\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n\n  it('should be return code in string', () => {\n    const code = getCode({ error: HttpStatus['TEST_ERROR'] });\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n});\n",
              "err": {},
              "uuid": "cda3d17c-c490-49ad-8210-4219d997e1ef",
              "parentUUID": "4e0fc067-c8de-4af8-9096-d112fd14f523",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "error.utils > should be return code in string",
              "title": "error.utils > should be return code in string",
              "timedOut": false,
              "duration": 0,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { getCode } from '../';\nimport { HttpStatus } from '@nestjs/common';\n\ndescribe('error.utils', () => {\n  it('should be return code in string', () => {\n    const code = getCode(HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR]);\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n\n  it('should be return code in string obj', () => {\n    const code = getCode({ error: HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR] });\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n\n  it('should be return code in string', () => {\n    const code = getCode({ error: HttpStatus['TEST_ERROR'] });\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n});\n",
              "err": {},
              "uuid": "4d2a0693-b16f-4044-a686-52d906f42aa8",
              "parentUUID": "4e0fc067-c8de-4af8-9096-d112fd14f523",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "b4acf2f5-90db-4855-92ff-eb793179824e",
            "9e419ce0-bee9-49af-933f-d1c43ac36606",
            "b65b96d1-61ec-423c-a772-f9a71b8b412e",
            "2ae5669d-9ef1-4c66-9b2a-88ff43f1237e",
            "1a0873b3-9a92-41c0-a365-2d11ce793409",
            "f861e391-3d0f-4b4a-a790-6af316fc7177",
            "7ddfd827-e22b-4bc1-a375-a0e7348850dd",
            "962c9544-619d-4a6a-8958-847b1c8e0c53",
            "b4d5699c-de68-402b-8118-daddf80b1bde",
            "ea8688aa-e22d-43bb-8339-d3797d01f6a5",
            "7ffa0cd7-e6c3-42b0-a005-211c7d123570",
            "9cac9cc4-8442-4cb7-9609-d75010cf1cc3",
            "cda3d17c-c490-49ad-8210-4219d997e1ef",
            "4d2a0693-b16f-4044-a686-52d906f42aa8"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 17,
          "root": false,
          "rootEmpty": false,
          "_timeout": 5000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 5000
    }
  ]
}