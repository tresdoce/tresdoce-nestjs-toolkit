{
  "stats": {
    "suites": 2,
    "tests": 14,
    "passes": 14,
    "pending": 0,
    "failures": 0,
    "testsRegistered": 14,
    "passPercent": 100,
    "pendingPercent": 0,
    "other": 0,
    "hasOther": false,
    "skipped": 0,
    "hasSkipped": false,
    "start": "2023-05-02T17:46:26.528Z",
    "end": "2023-05-02T17:46:26.540Z",
    "duration": 12
  },
  "results": [
    {
      "uuid": "54c6bfa5-b14e-4d71-8d5d-6c7212d657ac",
      "title": "@tresdoce-nestjs-toolkit/filters",
      "fullFile": "",
      "file": "",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "9ac57cc2-fa11-4289-93a0-9952311d4c50",
          "title": "@tresdoce-nestjs-toolkit/filters",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "fullTitle": "filters > code exception > should map a regular code exception",
              "title": "filters > code exception > should map a regular code exception",
              "timedOut": false,
              "duration": 3,
              "state": "passed",
              "speed": null,
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "c2e0f6fe-e797-4808-a9eb-1ca92656e91e",
              "parentUUID": "9ac57cc2-fa11-4289-93a0-9952311d4c50",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > code exception > should map default exception when thrown with not parameters",
              "title": "filters > code exception > should map default exception when thrown with not parameters",
              "timedOut": false,
              "duration": 0,
              "state": "passed",
              "speed": null,
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "8ae7ea24-7e6a-4faf-8c43-597207eb6fef",
              "parentUUID": "9ac57cc2-fa11-4289-93a0-9952311d4c50",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > code exception > should map default exception when thrown with error details",
              "title": "filters > code exception > should map default exception when thrown with error details",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": null,
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "c1d9d51a-8c83-4664-aebe-c7d04a011ff8",
              "parentUUID": "9ac57cc2-fa11-4289-93a0-9952311d4c50",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > code exception > should map default exception when thrown with error details and description",
              "title": "filters > code exception > should map default exception when thrown with error details and description",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": null,
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "12c84570-5edc-49a1-ba6e-639a4f2ad370",
              "parentUUID": "9ac57cc2-fa11-4289-93a0-9952311d4c50",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > code exception > should map HttpException response when called with a string",
              "title": "filters > code exception > should map HttpException response when called with a string",
              "timedOut": false,
              "duration": 0,
              "state": "passed",
              "speed": null,
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "c2d63de4-3d8b-46d0-94c0-464f91deb6cf",
              "parentUUID": "9ac57cc2-fa11-4289-93a0-9952311d4c50",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > code exception > should map HttpException response when called with an object",
              "title": "filters > code exception > should map HttpException response when called with an object",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": null,
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "2e31998e-6a47-4cbb-a377-eb0650a77094",
              "parentUUID": "9ac57cc2-fa11-4289-93a0-9952311d4c50",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > code exception > should map HttpException response when called with an object with empty message",
              "title": "filters > code exception > should map HttpException response when called with an object with empty message",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": null,
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "7da1ffec-aff6-4d07-a4e0-a92906ab66d2",
              "parentUUID": "9ac57cc2-fa11-4289-93a0-9952311d4c50",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > code exception > should map HttpException response when called with an array",
              "title": "filters > code exception > should map HttpException response when called with an array",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": null,
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "27fffe24-c49e-4b76-9d53-8c8309eeaf8b",
              "parentUUID": "9ac57cc2-fa11-4289-93a0-9952311d4c50",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > code exception > should map HttpException response when called with an object",
              "title": "filters > code exception > should map HttpException response when called with an object",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": null,
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "c3358050-832f-443e-9a68-8e1cc3a2001b",
              "parentUUID": "9ac57cc2-fa11-4289-93a0-9952311d4c50",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > code exception > should map default exception when thrown with not parameters",
              "title": "filters > code exception > should map default exception when thrown with not parameters",
              "timedOut": false,
              "duration": 0,
              "state": "passed",
              "speed": null,
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "06849e63-5eb0-40ea-8717-018c6b06e4f6",
              "parentUUID": "9ac57cc2-fa11-4289-93a0-9952311d4c50",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > code exception > should be return application info",
              "title": "filters > code exception > should be return application info",
              "timedOut": false,
              "duration": 0,
              "state": "passed",
              "speed": null,
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "cbe33c20-c4c0-4a48-bdb4-420e28686bc8",
              "parentUUID": "9ac57cc2-fa11-4289-93a0-9952311d4c50",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "error.utils > should be return code in string",
              "title": "error.utils > should be return code in string",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": null,
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { getCode } from '../';\nimport { HttpStatus } from '@nestjs/common';\n\ndescribe('error.utils', () => {\n  it('should be return code in string', () => {\n    const code = getCode(HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR]);\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n\n  it('should be return code in string obj', () => {\n    const code = getCode({ error: HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR] });\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n\n  it('should be return code in string', () => {\n    const code = getCode({ error: HttpStatus['TEST_ERROR'] });\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n});\n",
              "err": {},
              "uuid": "4673e569-a758-44d2-8b80-cf9934395cba",
              "parentUUID": "9ac57cc2-fa11-4289-93a0-9952311d4c50",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "error.utils > should be return code in string obj",
              "title": "error.utils > should be return code in string obj",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": null,
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { getCode } from '../';\nimport { HttpStatus } from '@nestjs/common';\n\ndescribe('error.utils', () => {\n  it('should be return code in string', () => {\n    const code = getCode(HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR]);\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n\n  it('should be return code in string obj', () => {\n    const code = getCode({ error: HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR] });\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n\n  it('should be return code in string', () => {\n    const code = getCode({ error: HttpStatus['TEST_ERROR'] });\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n});\n",
              "err": {},
              "uuid": "8979c094-2e39-4f89-97e1-50fec200ff28",
              "parentUUID": "9ac57cc2-fa11-4289-93a0-9952311d4c50",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "error.utils > should be return code in string",
              "title": "error.utils > should be return code in string",
              "timedOut": false,
              "duration": 0,
              "state": "passed",
              "speed": null,
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { getCode } from '../';\nimport { HttpStatus } from '@nestjs/common';\n\ndescribe('error.utils', () => {\n  it('should be return code in string', () => {\n    const code = getCode(HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR]);\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n\n  it('should be return code in string obj', () => {\n    const code = getCode({ error: HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR] });\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n\n  it('should be return code in string', () => {\n    const code = getCode({ error: HttpStatus['TEST_ERROR'] });\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n});\n",
              "err": {},
              "uuid": "17bbd3c8-10a1-4215-86cb-0378aad8bd89",
              "parentUUID": "9ac57cc2-fa11-4289-93a0-9952311d4c50",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "c2e0f6fe-e797-4808-a9eb-1ca92656e91e",
            "8ae7ea24-7e6a-4faf-8c43-597207eb6fef",
            "c1d9d51a-8c83-4664-aebe-c7d04a011ff8",
            "12c84570-5edc-49a1-ba6e-639a4f2ad370",
            "c2d63de4-3d8b-46d0-94c0-464f91deb6cf",
            "2e31998e-6a47-4cbb-a377-eb0650a77094",
            "7da1ffec-aff6-4d07-a4e0-a92906ab66d2",
            "27fffe24-c49e-4b76-9d53-8c8309eeaf8b",
            "c3358050-832f-443e-9a68-8e1cc3a2001b",
            "06849e63-5eb0-40ea-8717-018c6b06e4f6",
            "cbe33c20-c4c0-4a48-bdb4-420e28686bc8",
            "4673e569-a758-44d2-8b80-cf9934395cba",
            "8979c094-2e39-4f89-97e1-50fec200ff28",
            "17bbd3c8-10a1-4215-86cb-0378aad8bd89"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 12,
          "root": false,
          "rootEmpty": false,
          "_timeout": 5000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 5000
    }
  ]
}
