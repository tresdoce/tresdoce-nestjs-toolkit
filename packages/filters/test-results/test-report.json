{
  "stats": {
    "suites": 2,
    "tests": 14,
    "passes": 14,
    "pending": 0,
    "failures": 0,
    "testsRegistered": 14,
    "passPercent": 100,
    "pendingPercent": 0,
    "other": 0,
    "hasOther": false,
    "skipped": 0,
    "hasSkipped": false,
    "start": "2023-05-02T00:48:34.724Z",
    "end": "2023-05-02T00:48:34.740Z",
    "duration": 16
  },
  "results": [
    {
      "uuid": "0e644a8b-bc19-42e3-8448-39d420046401",
      "title": "@tresdoce-nestjs-toolkit/filters",
      "fullFile": "",
      "file": "",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "c2e4b3d8-dbbf-48f0-9907-4ea0180f5c90",
          "title": "@tresdoce-nestjs-toolkit/filters",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "filters > code exception > should map a regular code exception",
              "fullTitle": "should map a regular code exception",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": null,
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "c03ef442-1681-4407-8331-4accc1a5fba3",
              "parentUUID": "c2e4b3d8-dbbf-48f0-9907-4ea0180f5c90",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "filters > code exception > should map default exception when thrown with not parameters",
              "fullTitle": "should map default exception when thrown with not parameters",
              "timedOut": false,
              "duration": 0,
              "state": "passed",
              "speed": null,
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "40239190-8057-4158-8c83-5af1464fc9ee",
              "parentUUID": "c2e4b3d8-dbbf-48f0-9907-4ea0180f5c90",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "filters > code exception > should map default exception when thrown with error details",
              "fullTitle": "should map default exception when thrown with error details",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": null,
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "a10a5b1e-f113-4337-abd0-e035a00824f8",
              "parentUUID": "c2e4b3d8-dbbf-48f0-9907-4ea0180f5c90",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "filters > code exception > should map default exception when thrown with error details and description",
              "fullTitle": "should map default exception when thrown with error details and description",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": null,
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "65f199fe-2df3-40b7-b710-087df5f762df",
              "parentUUID": "c2e4b3d8-dbbf-48f0-9907-4ea0180f5c90",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "filters > code exception > should map HttpException response when called with a string",
              "fullTitle": "should map HttpException response when called with a string",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": null,
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "f8ace1ca-8f5e-41ec-a49f-562edd2813c9",
              "parentUUID": "c2e4b3d8-dbbf-48f0-9907-4ea0180f5c90",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "filters > code exception > should map HttpException response when called with an object",
              "fullTitle": "should map HttpException response when called with an object",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": null,
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "6f3af190-01d2-42de-9e4e-8dcfb293f3f5",
              "parentUUID": "c2e4b3d8-dbbf-48f0-9907-4ea0180f5c90",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "filters > code exception > should map HttpException response when called with an object with empty message",
              "fullTitle": "should map HttpException response when called with an object with empty message",
              "timedOut": false,
              "duration": 4,
              "state": "passed",
              "speed": null,
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "4f86440f-acd3-4b9a-9014-6aef1f6e274b",
              "parentUUID": "c2e4b3d8-dbbf-48f0-9907-4ea0180f5c90",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "filters > code exception > should map HttpException response when called with an array",
              "fullTitle": "should map HttpException response when called with an array",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": null,
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "47de7582-73a5-41f5-8985-21abd4f58d74",
              "parentUUID": "c2e4b3d8-dbbf-48f0-9907-4ea0180f5c90",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "filters > code exception > should map HttpException response when called with an object",
              "fullTitle": "should map HttpException response when called with an object",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": null,
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "df10351c-ebd7-48c1-8bce-7e2c7de3e78b",
              "parentUUID": "c2e4b3d8-dbbf-48f0-9907-4ea0180f5c90",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "filters > code exception > should map default exception when thrown with not parameters",
              "fullTitle": "should map default exception when thrown with not parameters",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": null,
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "6f81b364-8f06-4016-92c7-83d9b2de22b3",
              "parentUUID": "c2e4b3d8-dbbf-48f0-9907-4ea0180f5c90",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "filters > code exception > should be return application info",
              "fullTitle": "should be return application info",
              "timedOut": false,
              "duration": 0,
              "state": "passed",
              "speed": null,
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "8632141b-2c48-42c5-a986-bb90b42fc493",
              "parentUUID": "c2e4b3d8-dbbf-48f0-9907-4ea0180f5c90",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "error.utils > should be return code in string",
              "fullTitle": "should be return code in string",
              "timedOut": false,
              "duration": 3,
              "state": "passed",
              "speed": null,
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { getCode } from '../';\nimport { HttpStatus } from '@nestjs/common';\n\ndescribe('error.utils', () => {\n  it('should be return code in string', () => {\n    const code = getCode(HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR]);\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n\n  it('should be return code in string obj', () => {\n    const code = getCode({ error: HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR] });\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n\n  it('should be return code in string', () => {\n    const code = getCode({ error: HttpStatus['TEST_ERROR'] });\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n});\n",
              "err": {},
              "uuid": "0a54c246-0e3f-46c4-97cb-5cb2ec397aa7",
              "parentUUID": "c2e4b3d8-dbbf-48f0-9907-4ea0180f5c90",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "error.utils > should be return code in string obj",
              "fullTitle": "should be return code in string obj",
              "timedOut": false,
              "duration": 0,
              "state": "passed",
              "speed": null,
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { getCode } from '../';\nimport { HttpStatus } from '@nestjs/common';\n\ndescribe('error.utils', () => {\n  it('should be return code in string', () => {\n    const code = getCode(HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR]);\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n\n  it('should be return code in string obj', () => {\n    const code = getCode({ error: HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR] });\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n\n  it('should be return code in string', () => {\n    const code = getCode({ error: HttpStatus['TEST_ERROR'] });\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n});\n",
              "err": {},
              "uuid": "df9dae99-18c5-4063-8edb-6ed351526706",
              "parentUUID": "c2e4b3d8-dbbf-48f0-9907-4ea0180f5c90",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "error.utils > should be return code in string",
              "fullTitle": "should be return code in string",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": null,
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { getCode } from '../';\nimport { HttpStatus } from '@nestjs/common';\n\ndescribe('error.utils', () => {\n  it('should be return code in string', () => {\n    const code = getCode(HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR]);\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n\n  it('should be return code in string obj', () => {\n    const code = getCode({ error: HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR] });\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n\n  it('should be return code in string', () => {\n    const code = getCode({ error: HttpStatus['TEST_ERROR'] });\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n});\n",
              "err": {},
              "uuid": "1fa10333-2818-470f-9eea-c14f1918c393",
              "parentUUID": "c2e4b3d8-dbbf-48f0-9907-4ea0180f5c90",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "c03ef442-1681-4407-8331-4accc1a5fba3",
            "40239190-8057-4158-8c83-5af1464fc9ee",
            "a10a5b1e-f113-4337-abd0-e035a00824f8",
            "65f199fe-2df3-40b7-b710-087df5f762df",
            "f8ace1ca-8f5e-41ec-a49f-562edd2813c9",
            "6f3af190-01d2-42de-9e4e-8dcfb293f3f5",
            "4f86440f-acd3-4b9a-9014-6aef1f6e274b",
            "47de7582-73a5-41f5-8985-21abd4f58d74",
            "df10351c-ebd7-48c1-8bce-7e2c7de3e78b",
            "6f81b364-8f06-4016-92c7-83d9b2de22b3",
            "8632141b-2c48-42c5-a986-bb90b42fc493",
            "0a54c246-0e3f-46c4-97cb-5cb2ec397aa7",
            "df9dae99-18c5-4063-8edb-6ed351526706",
            "1fa10333-2818-470f-9eea-c14f1918c393"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 16,
          "root": false,
          "rootEmpty": false,
          "_timeout": 5000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 5000
    }
  ]
}
