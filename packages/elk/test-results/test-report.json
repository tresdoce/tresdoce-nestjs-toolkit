{
  "stats": {
    "suites": 1,
    "tests": 8,
    "passes": 8,
    "pending": 0,
    "failures": 0,
    "testsRegistered": 8,
    "passPercent": 100,
    "pendingPercent": 0,
    "other": 0,
    "hasOther": false,
    "skipped": 0,
    "hasSkipped": false,
    "start": "2023-05-02T02:22:53.511Z",
    "end": "2023-05-02T02:23:01.894Z",
    "duration": 8383
  },
  "results": [
    {
      "uuid": "91d34515-4c7b-4f29-8242-8dbc8fdaa264",
      "title": "@tresdoce-nestjs-toolkit/elk",
      "fullFile": "",
      "file": "",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "af49b4d7-ae8c-4f57-9a76-2df786d7179e",
          "title": "@tresdoce-nestjs-toolkit/elk",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "ElkModule > should be defined",
              "fullTitle": "should be defined",
              "timedOut": false,
              "duration": 1313,
              "state": "passed",
              "speed": null,
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { HttpException, INestApplication } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport {\n  dynamicConfig,\n  fixtureUserResponse,\n  TCElasticSearchOptions,\n  tcName,\n  testContainers,\n} from '@tresdoce-nestjs-toolkit/test-utils';\nimport { Observable, of, throwError } from 'rxjs';\nimport { HttpConnection } from '@elastic/elasticsearch';\nimport { URL } from 'url';\n\nimport { ElkModule } from '../elk/elk.module';\nimport { ElkInterceptor } from '../elk/interceptors/elk.interceptor';\nimport { ElkService } from '../elk/services/elk.service';\n\nlet executionContext: any = {\n  switchToHttp: jest.fn(() => ({\n    getRequest: () => ({\n      path: '/test',\n      method: 'GET',\n      params: {},\n      query: {},\n      body: {},\n      headers: {\n        'Content-Type': 'application/json',\n        apiKey: 'abcdefg12345',\n      },\n    }),\n    getResponse: () => ({\n      getHeaders: jest.fn().mockReturnValue({\n        'Content-Type': 'application/json',\n        my_header: 'test-header',\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() => 'http'),\n  getClass: jest.fn(() => 'testController'),\n  getHandler: jest.fn(() => 'handlerElk'),\n};\n\nlet executionContextParams: any = {\n  switchToHttp: jest.fn(() => ({\n    getRequest: () => ({\n      path: '/test',\n      method: 'GET',\n      params: { name: 'juan' },\n      query: { name: 'juan' },\n      body: { name: 'juan' },\n      headers: {\n        'Content-Type': 'application/json',\n        apiKey: 'abcdefg12345',\n      },\n    }),\n    getResponse: () => ({\n      getHeaders: jest.fn().mockReturnValue({\n        'Content-Type': 'application/json',\n        my_header: 'test-header',\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() => 'http'),\n  getClass: jest.fn(() => 'testController'),\n  getHandler: jest.fn(() => 'handlerElk'),\n};\n\n/*const callHandler: any = {\n  handle: jest.fn(() => ({\n    pipe: jest.fn(() => ({\n      tap: jest.fn(() => ({\n        next: jest.fn(),\n        error: jest.fn(),\n      })),\n    })),\n  })),\n};*/\n\njest.setTimeout(70000);\ndescribe('ElkModule', () => {\n  let app: INestApplication;\n  let elkService: ElkService;\n  let interceptor: ElkInterceptor<any>;\n  let container: testContainers;\n\n  beforeAll(async () => {\n    //'elasticsearch:8.3.3'\n    //docker.elastic.co/elasticsearch/elasticsearch:8.3.3\n\n    container = await new testContainers('elasticsearch:8.3.3', {\n      ...TCElasticSearchOptions,\n      containerName: `${tcName}-elasticsearch-interceptor`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () => {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () => {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              elasticsearch: {\n                name: 'test-elk-index',\n                node: {\n                  url: new URL(`http://${container.getHost()}:9200`),\n                },\n                maxRetries: 10,\n                requestTimeout: 60000,\n                sniffOnStart: true,\n                Connection: HttpConnection,\n              },\n            }),\n          ],\n        }),\n        ElkModule,\n      ],\n    }).compile();\n    app = moduleFixture.createNestApplication();\n    interceptor = new ElkInterceptor(app.get<ElkService>(ElkService));\n    app.useGlobalInterceptors(interceptor);\n    elkService = moduleFixture.get<ElkService>(ElkService);\n    await app.init();\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', () => {\n    expect(app).toBeDefined();\n  });\n\n  describe('ElkInterceptor', () => {\n    it('should be an ElkInterceptor instance to be defined', async () => {\n      expect(new ElkInterceptor(elkService)).toBeDefined();\n    });\n\n    it('should be create document in elasticsearch when return success string', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of('this is a test')),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return success object', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of([fixtureUserResponse])),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return success with parameters', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of([fixtureUserResponse])),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContextParams, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return exception', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const error = new Error(`User #$1 not found`);\n\n      const callHandler: any = {\n        handle: jest.fn(() => throwError(error)),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () => {},\n        error: (error) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n\n    it('should be create document in elasticsearch when return exception http', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const error = new HttpException('not found', 404);\n\n      const callHandler: any = {\n        handle: jest.fn(() => throwError(error)),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () => {},\n        error: (error) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n  });\n\n  describe('ElkModule - Register', () => {\n    let app: INestApplication;\n    let elkService: ElkService;\n    let interceptor: ElkInterceptor<any>;\n\n    beforeEach(async () => {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ElkModule.register({\n            name: 'test-elk-index',\n            node: {\n              url: new URL(`http://${container.getHost()}:9200`),\n            },\n            maxRetries: 10,\n            requestTimeout: 60000,\n            sniffOnStart: true,\n            Connection: HttpConnection,\n          }),\n        ],\n      }).compile();\n      app = moduleFixture.createNestApplication();\n      interceptor = new ElkInterceptor(app.get<ElkService>(ElkService));\n      app.useGlobalInterceptors(interceptor);\n      elkService = moduleFixture.get<ElkService>(ElkService);\n      await app.init();\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be defined', () => {\n      expect(app).toBeDefined();\n    });\n  });\n});\n",
              "err": {},
              "uuid": "6d0815b0-4fb9-4c7a-abd9-41f2f9b1492b",
              "parentUUID": "af49b4d7-ae8c-4f57-9a76-2df786d7179e",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "ElkModule > should be an ElkInterceptor instance to be defined",
              "fullTitle": "should be an ElkInterceptor instance to be defined",
              "timedOut": false,
              "duration": 1008,
              "state": "passed",
              "speed": null,
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { HttpException, INestApplication } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport {\n  dynamicConfig,\n  fixtureUserResponse,\n  TCElasticSearchOptions,\n  tcName,\n  testContainers,\n} from '@tresdoce-nestjs-toolkit/test-utils';\nimport { Observable, of, throwError } from 'rxjs';\nimport { HttpConnection } from '@elastic/elasticsearch';\nimport { URL } from 'url';\n\nimport { ElkModule } from '../elk/elk.module';\nimport { ElkInterceptor } from '../elk/interceptors/elk.interceptor';\nimport { ElkService } from '../elk/services/elk.service';\n\nlet executionContext: any = {\n  switchToHttp: jest.fn(() => ({\n    getRequest: () => ({\n      path: '/test',\n      method: 'GET',\n      params: {},\n      query: {},\n      body: {},\n      headers: {\n        'Content-Type': 'application/json',\n        apiKey: 'abcdefg12345',\n      },\n    }),\n    getResponse: () => ({\n      getHeaders: jest.fn().mockReturnValue({\n        'Content-Type': 'application/json',\n        my_header: 'test-header',\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() => 'http'),\n  getClass: jest.fn(() => 'testController'),\n  getHandler: jest.fn(() => 'handlerElk'),\n};\n\nlet executionContextParams: any = {\n  switchToHttp: jest.fn(() => ({\n    getRequest: () => ({\n      path: '/test',\n      method: 'GET',\n      params: { name: 'juan' },\n      query: { name: 'juan' },\n      body: { name: 'juan' },\n      headers: {\n        'Content-Type': 'application/json',\n        apiKey: 'abcdefg12345',\n      },\n    }),\n    getResponse: () => ({\n      getHeaders: jest.fn().mockReturnValue({\n        'Content-Type': 'application/json',\n        my_header: 'test-header',\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() => 'http'),\n  getClass: jest.fn(() => 'testController'),\n  getHandler: jest.fn(() => 'handlerElk'),\n};\n\n/*const callHandler: any = {\n  handle: jest.fn(() => ({\n    pipe: jest.fn(() => ({\n      tap: jest.fn(() => ({\n        next: jest.fn(),\n        error: jest.fn(),\n      })),\n    })),\n  })),\n};*/\n\njest.setTimeout(70000);\ndescribe('ElkModule', () => {\n  let app: INestApplication;\n  let elkService: ElkService;\n  let interceptor: ElkInterceptor<any>;\n  let container: testContainers;\n\n  beforeAll(async () => {\n    //'elasticsearch:8.3.3'\n    //docker.elastic.co/elasticsearch/elasticsearch:8.3.3\n\n    container = await new testContainers('elasticsearch:8.3.3', {\n      ...TCElasticSearchOptions,\n      containerName: `${tcName}-elasticsearch-interceptor`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () => {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () => {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              elasticsearch: {\n                name: 'test-elk-index',\n                node: {\n                  url: new URL(`http://${container.getHost()}:9200`),\n                },\n                maxRetries: 10,\n                requestTimeout: 60000,\n                sniffOnStart: true,\n                Connection: HttpConnection,\n              },\n            }),\n          ],\n        }),\n        ElkModule,\n      ],\n    }).compile();\n    app = moduleFixture.createNestApplication();\n    interceptor = new ElkInterceptor(app.get<ElkService>(ElkService));\n    app.useGlobalInterceptors(interceptor);\n    elkService = moduleFixture.get<ElkService>(ElkService);\n    await app.init();\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', () => {\n    expect(app).toBeDefined();\n  });\n\n  describe('ElkInterceptor', () => {\n    it('should be an ElkInterceptor instance to be defined', async () => {\n      expect(new ElkInterceptor(elkService)).toBeDefined();\n    });\n\n    it('should be create document in elasticsearch when return success string', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of('this is a test')),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return success object', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of([fixtureUserResponse])),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return success with parameters', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of([fixtureUserResponse])),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContextParams, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return exception', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const error = new Error(`User #$1 not found`);\n\n      const callHandler: any = {\n        handle: jest.fn(() => throwError(error)),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () => {},\n        error: (error) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n\n    it('should be create document in elasticsearch when return exception http', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const error = new HttpException('not found', 404);\n\n      const callHandler: any = {\n        handle: jest.fn(() => throwError(error)),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () => {},\n        error: (error) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n  });\n\n  describe('ElkModule - Register', () => {\n    let app: INestApplication;\n    let elkService: ElkService;\n    let interceptor: ElkInterceptor<any>;\n\n    beforeEach(async () => {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ElkModule.register({\n            name: 'test-elk-index',\n            node: {\n              url: new URL(`http://${container.getHost()}:9200`),\n            },\n            maxRetries: 10,\n            requestTimeout: 60000,\n            sniffOnStart: true,\n            Connection: HttpConnection,\n          }),\n        ],\n      }).compile();\n      app = moduleFixture.createNestApplication();\n      interceptor = new ElkInterceptor(app.get<ElkService>(ElkService));\n      app.useGlobalInterceptors(interceptor);\n      elkService = moduleFixture.get<ElkService>(ElkService);\n      await app.init();\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be defined', () => {\n      expect(app).toBeDefined();\n    });\n  });\n});\n",
              "err": {},
              "uuid": "c2145fb4-be58-472c-bf3a-8e8a43ca7662",
              "parentUUID": "af49b4d7-ae8c-4f57-9a76-2df786d7179e",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "ElkModule > should be create document in elasticsearch when return success string",
              "fullTitle": "should be create document in elasticsearch when return success string",
              "timedOut": false,
              "duration": 1011,
              "state": "passed",
              "speed": null,
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { HttpException, INestApplication } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport {\n  dynamicConfig,\n  fixtureUserResponse,\n  TCElasticSearchOptions,\n  tcName,\n  testContainers,\n} from '@tresdoce-nestjs-toolkit/test-utils';\nimport { Observable, of, throwError } from 'rxjs';\nimport { HttpConnection } from '@elastic/elasticsearch';\nimport { URL } from 'url';\n\nimport { ElkModule } from '../elk/elk.module';\nimport { ElkInterceptor } from '../elk/interceptors/elk.interceptor';\nimport { ElkService } from '../elk/services/elk.service';\n\nlet executionContext: any = {\n  switchToHttp: jest.fn(() => ({\n    getRequest: () => ({\n      path: '/test',\n      method: 'GET',\n      params: {},\n      query: {},\n      body: {},\n      headers: {\n        'Content-Type': 'application/json',\n        apiKey: 'abcdefg12345',\n      },\n    }),\n    getResponse: () => ({\n      getHeaders: jest.fn().mockReturnValue({\n        'Content-Type': 'application/json',\n        my_header: 'test-header',\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() => 'http'),\n  getClass: jest.fn(() => 'testController'),\n  getHandler: jest.fn(() => 'handlerElk'),\n};\n\nlet executionContextParams: any = {\n  switchToHttp: jest.fn(() => ({\n    getRequest: () => ({\n      path: '/test',\n      method: 'GET',\n      params: { name: 'juan' },\n      query: { name: 'juan' },\n      body: { name: 'juan' },\n      headers: {\n        'Content-Type': 'application/json',\n        apiKey: 'abcdefg12345',\n      },\n    }),\n    getResponse: () => ({\n      getHeaders: jest.fn().mockReturnValue({\n        'Content-Type': 'application/json',\n        my_header: 'test-header',\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() => 'http'),\n  getClass: jest.fn(() => 'testController'),\n  getHandler: jest.fn(() => 'handlerElk'),\n};\n\n/*const callHandler: any = {\n  handle: jest.fn(() => ({\n    pipe: jest.fn(() => ({\n      tap: jest.fn(() => ({\n        next: jest.fn(),\n        error: jest.fn(),\n      })),\n    })),\n  })),\n};*/\n\njest.setTimeout(70000);\ndescribe('ElkModule', () => {\n  let app: INestApplication;\n  let elkService: ElkService;\n  let interceptor: ElkInterceptor<any>;\n  let container: testContainers;\n\n  beforeAll(async () => {\n    //'elasticsearch:8.3.3'\n    //docker.elastic.co/elasticsearch/elasticsearch:8.3.3\n\n    container = await new testContainers('elasticsearch:8.3.3', {\n      ...TCElasticSearchOptions,\n      containerName: `${tcName}-elasticsearch-interceptor`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () => {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () => {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              elasticsearch: {\n                name: 'test-elk-index',\n                node: {\n                  url: new URL(`http://${container.getHost()}:9200`),\n                },\n                maxRetries: 10,\n                requestTimeout: 60000,\n                sniffOnStart: true,\n                Connection: HttpConnection,\n              },\n            }),\n          ],\n        }),\n        ElkModule,\n      ],\n    }).compile();\n    app = moduleFixture.createNestApplication();\n    interceptor = new ElkInterceptor(app.get<ElkService>(ElkService));\n    app.useGlobalInterceptors(interceptor);\n    elkService = moduleFixture.get<ElkService>(ElkService);\n    await app.init();\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', () => {\n    expect(app).toBeDefined();\n  });\n\n  describe('ElkInterceptor', () => {\n    it('should be an ElkInterceptor instance to be defined', async () => {\n      expect(new ElkInterceptor(elkService)).toBeDefined();\n    });\n\n    it('should be create document in elasticsearch when return success string', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of('this is a test')),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return success object', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of([fixtureUserResponse])),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return success with parameters', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of([fixtureUserResponse])),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContextParams, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return exception', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const error = new Error(`User #$1 not found`);\n\n      const callHandler: any = {\n        handle: jest.fn(() => throwError(error)),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () => {},\n        error: (error) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n\n    it('should be create document in elasticsearch when return exception http', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const error = new HttpException('not found', 404);\n\n      const callHandler: any = {\n        handle: jest.fn(() => throwError(error)),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () => {},\n        error: (error) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n  });\n\n  describe('ElkModule - Register', () => {\n    let app: INestApplication;\n    let elkService: ElkService;\n    let interceptor: ElkInterceptor<any>;\n\n    beforeEach(async () => {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ElkModule.register({\n            name: 'test-elk-index',\n            node: {\n              url: new URL(`http://${container.getHost()}:9200`),\n            },\n            maxRetries: 10,\n            requestTimeout: 60000,\n            sniffOnStart: true,\n            Connection: HttpConnection,\n          }),\n        ],\n      }).compile();\n      app = moduleFixture.createNestApplication();\n      interceptor = new ElkInterceptor(app.get<ElkService>(ElkService));\n      app.useGlobalInterceptors(interceptor);\n      elkService = moduleFixture.get<ElkService>(ElkService);\n      await app.init();\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be defined', () => {\n      expect(app).toBeDefined();\n    });\n  });\n});\n",
              "err": {},
              "uuid": "25bb9171-547b-47af-a101-965bbe3899c8",
              "parentUUID": "af49b4d7-ae8c-4f57-9a76-2df786d7179e",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "ElkModule > should be create document in elasticsearch when return success object",
              "fullTitle": "should be create document in elasticsearch when return success object",
              "timedOut": false,
              "duration": 1010,
              "state": "passed",
              "speed": null,
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { HttpException, INestApplication } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport {\n  dynamicConfig,\n  fixtureUserResponse,\n  TCElasticSearchOptions,\n  tcName,\n  testContainers,\n} from '@tresdoce-nestjs-toolkit/test-utils';\nimport { Observable, of, throwError } from 'rxjs';\nimport { HttpConnection } from '@elastic/elasticsearch';\nimport { URL } from 'url';\n\nimport { ElkModule } from '../elk/elk.module';\nimport { ElkInterceptor } from '../elk/interceptors/elk.interceptor';\nimport { ElkService } from '../elk/services/elk.service';\n\nlet executionContext: any = {\n  switchToHttp: jest.fn(() => ({\n    getRequest: () => ({\n      path: '/test',\n      method: 'GET',\n      params: {},\n      query: {},\n      body: {},\n      headers: {\n        'Content-Type': 'application/json',\n        apiKey: 'abcdefg12345',\n      },\n    }),\n    getResponse: () => ({\n      getHeaders: jest.fn().mockReturnValue({\n        'Content-Type': 'application/json',\n        my_header: 'test-header',\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() => 'http'),\n  getClass: jest.fn(() => 'testController'),\n  getHandler: jest.fn(() => 'handlerElk'),\n};\n\nlet executionContextParams: any = {\n  switchToHttp: jest.fn(() => ({\n    getRequest: () => ({\n      path: '/test',\n      method: 'GET',\n      params: { name: 'juan' },\n      query: { name: 'juan' },\n      body: { name: 'juan' },\n      headers: {\n        'Content-Type': 'application/json',\n        apiKey: 'abcdefg12345',\n      },\n    }),\n    getResponse: () => ({\n      getHeaders: jest.fn().mockReturnValue({\n        'Content-Type': 'application/json',\n        my_header: 'test-header',\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() => 'http'),\n  getClass: jest.fn(() => 'testController'),\n  getHandler: jest.fn(() => 'handlerElk'),\n};\n\n/*const callHandler: any = {\n  handle: jest.fn(() => ({\n    pipe: jest.fn(() => ({\n      tap: jest.fn(() => ({\n        next: jest.fn(),\n        error: jest.fn(),\n      })),\n    })),\n  })),\n};*/\n\njest.setTimeout(70000);\ndescribe('ElkModule', () => {\n  let app: INestApplication;\n  let elkService: ElkService;\n  let interceptor: ElkInterceptor<any>;\n  let container: testContainers;\n\n  beforeAll(async () => {\n    //'elasticsearch:8.3.3'\n    //docker.elastic.co/elasticsearch/elasticsearch:8.3.3\n\n    container = await new testContainers('elasticsearch:8.3.3', {\n      ...TCElasticSearchOptions,\n      containerName: `${tcName}-elasticsearch-interceptor`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () => {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () => {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              elasticsearch: {\n                name: 'test-elk-index',\n                node: {\n                  url: new URL(`http://${container.getHost()}:9200`),\n                },\n                maxRetries: 10,\n                requestTimeout: 60000,\n                sniffOnStart: true,\n                Connection: HttpConnection,\n              },\n            }),\n          ],\n        }),\n        ElkModule,\n      ],\n    }).compile();\n    app = moduleFixture.createNestApplication();\n    interceptor = new ElkInterceptor(app.get<ElkService>(ElkService));\n    app.useGlobalInterceptors(interceptor);\n    elkService = moduleFixture.get<ElkService>(ElkService);\n    await app.init();\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', () => {\n    expect(app).toBeDefined();\n  });\n\n  describe('ElkInterceptor', () => {\n    it('should be an ElkInterceptor instance to be defined', async () => {\n      expect(new ElkInterceptor(elkService)).toBeDefined();\n    });\n\n    it('should be create document in elasticsearch when return success string', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of('this is a test')),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return success object', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of([fixtureUserResponse])),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return success with parameters', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of([fixtureUserResponse])),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContextParams, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return exception', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const error = new Error(`User #$1 not found`);\n\n      const callHandler: any = {\n        handle: jest.fn(() => throwError(error)),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () => {},\n        error: (error) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n\n    it('should be create document in elasticsearch when return exception http', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const error = new HttpException('not found', 404);\n\n      const callHandler: any = {\n        handle: jest.fn(() => throwError(error)),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () => {},\n        error: (error) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n  });\n\n  describe('ElkModule - Register', () => {\n    let app: INestApplication;\n    let elkService: ElkService;\n    let interceptor: ElkInterceptor<any>;\n\n    beforeEach(async () => {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ElkModule.register({\n            name: 'test-elk-index',\n            node: {\n              url: new URL(`http://${container.getHost()}:9200`),\n            },\n            maxRetries: 10,\n            requestTimeout: 60000,\n            sniffOnStart: true,\n            Connection: HttpConnection,\n          }),\n        ],\n      }).compile();\n      app = moduleFixture.createNestApplication();\n      interceptor = new ElkInterceptor(app.get<ElkService>(ElkService));\n      app.useGlobalInterceptors(interceptor);\n      elkService = moduleFixture.get<ElkService>(ElkService);\n      await app.init();\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be defined', () => {\n      expect(app).toBeDefined();\n    });\n  });\n});\n",
              "err": {},
              "uuid": "826a6dac-84b5-4409-a98e-11147dc03ca5",
              "parentUUID": "af49b4d7-ae8c-4f57-9a76-2df786d7179e",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "ElkModule > should be create document in elasticsearch when return success with parameters",
              "fullTitle": "should be create document in elasticsearch when return success with parameters",
              "timedOut": false,
              "duration": 1009,
              "state": "passed",
              "speed": null,
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { HttpException, INestApplication } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport {\n  dynamicConfig,\n  fixtureUserResponse,\n  TCElasticSearchOptions,\n  tcName,\n  testContainers,\n} from '@tresdoce-nestjs-toolkit/test-utils';\nimport { Observable, of, throwError } from 'rxjs';\nimport { HttpConnection } from '@elastic/elasticsearch';\nimport { URL } from 'url';\n\nimport { ElkModule } from '../elk/elk.module';\nimport { ElkInterceptor } from '../elk/interceptors/elk.interceptor';\nimport { ElkService } from '../elk/services/elk.service';\n\nlet executionContext: any = {\n  switchToHttp: jest.fn(() => ({\n    getRequest: () => ({\n      path: '/test',\n      method: 'GET',\n      params: {},\n      query: {},\n      body: {},\n      headers: {\n        'Content-Type': 'application/json',\n        apiKey: 'abcdefg12345',\n      },\n    }),\n    getResponse: () => ({\n      getHeaders: jest.fn().mockReturnValue({\n        'Content-Type': 'application/json',\n        my_header: 'test-header',\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() => 'http'),\n  getClass: jest.fn(() => 'testController'),\n  getHandler: jest.fn(() => 'handlerElk'),\n};\n\nlet executionContextParams: any = {\n  switchToHttp: jest.fn(() => ({\n    getRequest: () => ({\n      path: '/test',\n      method: 'GET',\n      params: { name: 'juan' },\n      query: { name: 'juan' },\n      body: { name: 'juan' },\n      headers: {\n        'Content-Type': 'application/json',\n        apiKey: 'abcdefg12345',\n      },\n    }),\n    getResponse: () => ({\n      getHeaders: jest.fn().mockReturnValue({\n        'Content-Type': 'application/json',\n        my_header: 'test-header',\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() => 'http'),\n  getClass: jest.fn(() => 'testController'),\n  getHandler: jest.fn(() => 'handlerElk'),\n};\n\n/*const callHandler: any = {\n  handle: jest.fn(() => ({\n    pipe: jest.fn(() => ({\n      tap: jest.fn(() => ({\n        next: jest.fn(),\n        error: jest.fn(),\n      })),\n    })),\n  })),\n};*/\n\njest.setTimeout(70000);\ndescribe('ElkModule', () => {\n  let app: INestApplication;\n  let elkService: ElkService;\n  let interceptor: ElkInterceptor<any>;\n  let container: testContainers;\n\n  beforeAll(async () => {\n    //'elasticsearch:8.3.3'\n    //docker.elastic.co/elasticsearch/elasticsearch:8.3.3\n\n    container = await new testContainers('elasticsearch:8.3.3', {\n      ...TCElasticSearchOptions,\n      containerName: `${tcName}-elasticsearch-interceptor`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () => {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () => {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              elasticsearch: {\n                name: 'test-elk-index',\n                node: {\n                  url: new URL(`http://${container.getHost()}:9200`),\n                },\n                maxRetries: 10,\n                requestTimeout: 60000,\n                sniffOnStart: true,\n                Connection: HttpConnection,\n              },\n            }),\n          ],\n        }),\n        ElkModule,\n      ],\n    }).compile();\n    app = moduleFixture.createNestApplication();\n    interceptor = new ElkInterceptor(app.get<ElkService>(ElkService));\n    app.useGlobalInterceptors(interceptor);\n    elkService = moduleFixture.get<ElkService>(ElkService);\n    await app.init();\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', () => {\n    expect(app).toBeDefined();\n  });\n\n  describe('ElkInterceptor', () => {\n    it('should be an ElkInterceptor instance to be defined', async () => {\n      expect(new ElkInterceptor(elkService)).toBeDefined();\n    });\n\n    it('should be create document in elasticsearch when return success string', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of('this is a test')),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return success object', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of([fixtureUserResponse])),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return success with parameters', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of([fixtureUserResponse])),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContextParams, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return exception', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const error = new Error(`User #$1 not found`);\n\n      const callHandler: any = {\n        handle: jest.fn(() => throwError(error)),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () => {},\n        error: (error) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n\n    it('should be create document in elasticsearch when return exception http', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const error = new HttpException('not found', 404);\n\n      const callHandler: any = {\n        handle: jest.fn(() => throwError(error)),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () => {},\n        error: (error) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n  });\n\n  describe('ElkModule - Register', () => {\n    let app: INestApplication;\n    let elkService: ElkService;\n    let interceptor: ElkInterceptor<any>;\n\n    beforeEach(async () => {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ElkModule.register({\n            name: 'test-elk-index',\n            node: {\n              url: new URL(`http://${container.getHost()}:9200`),\n            },\n            maxRetries: 10,\n            requestTimeout: 60000,\n            sniffOnStart: true,\n            Connection: HttpConnection,\n          }),\n        ],\n      }).compile();\n      app = moduleFixture.createNestApplication();\n      interceptor = new ElkInterceptor(app.get<ElkService>(ElkService));\n      app.useGlobalInterceptors(interceptor);\n      elkService = moduleFixture.get<ElkService>(ElkService);\n      await app.init();\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be defined', () => {\n      expect(app).toBeDefined();\n    });\n  });\n});\n",
              "err": {},
              "uuid": "a541dfa2-fa25-4c03-be49-515d65496ccc",
              "parentUUID": "af49b4d7-ae8c-4f57-9a76-2df786d7179e",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "ElkModule > should be create document in elasticsearch when return exception",
              "fullTitle": "should be create document in elasticsearch when return exception",
              "timedOut": false,
              "duration": 1009,
              "state": "passed",
              "speed": null,
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { HttpException, INestApplication } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport {\n  dynamicConfig,\n  fixtureUserResponse,\n  TCElasticSearchOptions,\n  tcName,\n  testContainers,\n} from '@tresdoce-nestjs-toolkit/test-utils';\nimport { Observable, of, throwError } from 'rxjs';\nimport { HttpConnection } from '@elastic/elasticsearch';\nimport { URL } from 'url';\n\nimport { ElkModule } from '../elk/elk.module';\nimport { ElkInterceptor } from '../elk/interceptors/elk.interceptor';\nimport { ElkService } from '../elk/services/elk.service';\n\nlet executionContext: any = {\n  switchToHttp: jest.fn(() => ({\n    getRequest: () => ({\n      path: '/test',\n      method: 'GET',\n      params: {},\n      query: {},\n      body: {},\n      headers: {\n        'Content-Type': 'application/json',\n        apiKey: 'abcdefg12345',\n      },\n    }),\n    getResponse: () => ({\n      getHeaders: jest.fn().mockReturnValue({\n        'Content-Type': 'application/json',\n        my_header: 'test-header',\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() => 'http'),\n  getClass: jest.fn(() => 'testController'),\n  getHandler: jest.fn(() => 'handlerElk'),\n};\n\nlet executionContextParams: any = {\n  switchToHttp: jest.fn(() => ({\n    getRequest: () => ({\n      path: '/test',\n      method: 'GET',\n      params: { name: 'juan' },\n      query: { name: 'juan' },\n      body: { name: 'juan' },\n      headers: {\n        'Content-Type': 'application/json',\n        apiKey: 'abcdefg12345',\n      },\n    }),\n    getResponse: () => ({\n      getHeaders: jest.fn().mockReturnValue({\n        'Content-Type': 'application/json',\n        my_header: 'test-header',\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() => 'http'),\n  getClass: jest.fn(() => 'testController'),\n  getHandler: jest.fn(() => 'handlerElk'),\n};\n\n/*const callHandler: any = {\n  handle: jest.fn(() => ({\n    pipe: jest.fn(() => ({\n      tap: jest.fn(() => ({\n        next: jest.fn(),\n        error: jest.fn(),\n      })),\n    })),\n  })),\n};*/\n\njest.setTimeout(70000);\ndescribe('ElkModule', () => {\n  let app: INestApplication;\n  let elkService: ElkService;\n  let interceptor: ElkInterceptor<any>;\n  let container: testContainers;\n\n  beforeAll(async () => {\n    //'elasticsearch:8.3.3'\n    //docker.elastic.co/elasticsearch/elasticsearch:8.3.3\n\n    container = await new testContainers('elasticsearch:8.3.3', {\n      ...TCElasticSearchOptions,\n      containerName: `${tcName}-elasticsearch-interceptor`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () => {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () => {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              elasticsearch: {\n                name: 'test-elk-index',\n                node: {\n                  url: new URL(`http://${container.getHost()}:9200`),\n                },\n                maxRetries: 10,\n                requestTimeout: 60000,\n                sniffOnStart: true,\n                Connection: HttpConnection,\n              },\n            }),\n          ],\n        }),\n        ElkModule,\n      ],\n    }).compile();\n    app = moduleFixture.createNestApplication();\n    interceptor = new ElkInterceptor(app.get<ElkService>(ElkService));\n    app.useGlobalInterceptors(interceptor);\n    elkService = moduleFixture.get<ElkService>(ElkService);\n    await app.init();\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', () => {\n    expect(app).toBeDefined();\n  });\n\n  describe('ElkInterceptor', () => {\n    it('should be an ElkInterceptor instance to be defined', async () => {\n      expect(new ElkInterceptor(elkService)).toBeDefined();\n    });\n\n    it('should be create document in elasticsearch when return success string', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of('this is a test')),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return success object', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of([fixtureUserResponse])),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return success with parameters', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of([fixtureUserResponse])),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContextParams, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return exception', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const error = new Error(`User #$1 not found`);\n\n      const callHandler: any = {\n        handle: jest.fn(() => throwError(error)),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () => {},\n        error: (error) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n\n    it('should be create document in elasticsearch when return exception http', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const error = new HttpException('not found', 404);\n\n      const callHandler: any = {\n        handle: jest.fn(() => throwError(error)),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () => {},\n        error: (error) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n  });\n\n  describe('ElkModule - Register', () => {\n    let app: INestApplication;\n    let elkService: ElkService;\n    let interceptor: ElkInterceptor<any>;\n\n    beforeEach(async () => {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ElkModule.register({\n            name: 'test-elk-index',\n            node: {\n              url: new URL(`http://${container.getHost()}:9200`),\n            },\n            maxRetries: 10,\n            requestTimeout: 60000,\n            sniffOnStart: true,\n            Connection: HttpConnection,\n          }),\n        ],\n      }).compile();\n      app = moduleFixture.createNestApplication();\n      interceptor = new ElkInterceptor(app.get<ElkService>(ElkService));\n      app.useGlobalInterceptors(interceptor);\n      elkService = moduleFixture.get<ElkService>(ElkService);\n      await app.init();\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be defined', () => {\n      expect(app).toBeDefined();\n    });\n  });\n});\n",
              "err": {},
              "uuid": "3983c915-caed-4155-8837-678038eb6ed8",
              "parentUUID": "af49b4d7-ae8c-4f57-9a76-2df786d7179e",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "ElkModule > should be create document in elasticsearch when return exception http",
              "fullTitle": "should be create document in elasticsearch when return exception http",
              "timedOut": false,
              "duration": 1008,
              "state": "passed",
              "speed": null,
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { HttpException, INestApplication } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport {\n  dynamicConfig,\n  fixtureUserResponse,\n  TCElasticSearchOptions,\n  tcName,\n  testContainers,\n} from '@tresdoce-nestjs-toolkit/test-utils';\nimport { Observable, of, throwError } from 'rxjs';\nimport { HttpConnection } from '@elastic/elasticsearch';\nimport { URL } from 'url';\n\nimport { ElkModule } from '../elk/elk.module';\nimport { ElkInterceptor } from '../elk/interceptors/elk.interceptor';\nimport { ElkService } from '../elk/services/elk.service';\n\nlet executionContext: any = {\n  switchToHttp: jest.fn(() => ({\n    getRequest: () => ({\n      path: '/test',\n      method: 'GET',\n      params: {},\n      query: {},\n      body: {},\n      headers: {\n        'Content-Type': 'application/json',\n        apiKey: 'abcdefg12345',\n      },\n    }),\n    getResponse: () => ({\n      getHeaders: jest.fn().mockReturnValue({\n        'Content-Type': 'application/json',\n        my_header: 'test-header',\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() => 'http'),\n  getClass: jest.fn(() => 'testController'),\n  getHandler: jest.fn(() => 'handlerElk'),\n};\n\nlet executionContextParams: any = {\n  switchToHttp: jest.fn(() => ({\n    getRequest: () => ({\n      path: '/test',\n      method: 'GET',\n      params: { name: 'juan' },\n      query: { name: 'juan' },\n      body: { name: 'juan' },\n      headers: {\n        'Content-Type': 'application/json',\n        apiKey: 'abcdefg12345',\n      },\n    }),\n    getResponse: () => ({\n      getHeaders: jest.fn().mockReturnValue({\n        'Content-Type': 'application/json',\n        my_header: 'test-header',\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() => 'http'),\n  getClass: jest.fn(() => 'testController'),\n  getHandler: jest.fn(() => 'handlerElk'),\n};\n\n/*const callHandler: any = {\n  handle: jest.fn(() => ({\n    pipe: jest.fn(() => ({\n      tap: jest.fn(() => ({\n        next: jest.fn(),\n        error: jest.fn(),\n      })),\n    })),\n  })),\n};*/\n\njest.setTimeout(70000);\ndescribe('ElkModule', () => {\n  let app: INestApplication;\n  let elkService: ElkService;\n  let interceptor: ElkInterceptor<any>;\n  let container: testContainers;\n\n  beforeAll(async () => {\n    //'elasticsearch:8.3.3'\n    //docker.elastic.co/elasticsearch/elasticsearch:8.3.3\n\n    container = await new testContainers('elasticsearch:8.3.3', {\n      ...TCElasticSearchOptions,\n      containerName: `${tcName}-elasticsearch-interceptor`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () => {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () => {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              elasticsearch: {\n                name: 'test-elk-index',\n                node: {\n                  url: new URL(`http://${container.getHost()}:9200`),\n                },\n                maxRetries: 10,\n                requestTimeout: 60000,\n                sniffOnStart: true,\n                Connection: HttpConnection,\n              },\n            }),\n          ],\n        }),\n        ElkModule,\n      ],\n    }).compile();\n    app = moduleFixture.createNestApplication();\n    interceptor = new ElkInterceptor(app.get<ElkService>(ElkService));\n    app.useGlobalInterceptors(interceptor);\n    elkService = moduleFixture.get<ElkService>(ElkService);\n    await app.init();\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', () => {\n    expect(app).toBeDefined();\n  });\n\n  describe('ElkInterceptor', () => {\n    it('should be an ElkInterceptor instance to be defined', async () => {\n      expect(new ElkInterceptor(elkService)).toBeDefined();\n    });\n\n    it('should be create document in elasticsearch when return success string', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of('this is a test')),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return success object', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of([fixtureUserResponse])),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return success with parameters', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of([fixtureUserResponse])),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContextParams, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return exception', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const error = new Error(`User #$1 not found`);\n\n      const callHandler: any = {\n        handle: jest.fn(() => throwError(error)),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () => {},\n        error: (error) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n\n    it('should be create document in elasticsearch when return exception http', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const error = new HttpException('not found', 404);\n\n      const callHandler: any = {\n        handle: jest.fn(() => throwError(error)),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () => {},\n        error: (error) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n  });\n\n  describe('ElkModule - Register', () => {\n    let app: INestApplication;\n    let elkService: ElkService;\n    let interceptor: ElkInterceptor<any>;\n\n    beforeEach(async () => {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ElkModule.register({\n            name: 'test-elk-index',\n            node: {\n              url: new URL(`http://${container.getHost()}:9200`),\n            },\n            maxRetries: 10,\n            requestTimeout: 60000,\n            sniffOnStart: true,\n            Connection: HttpConnection,\n          }),\n        ],\n      }).compile();\n      app = moduleFixture.createNestApplication();\n      interceptor = new ElkInterceptor(app.get<ElkService>(ElkService));\n      app.useGlobalInterceptors(interceptor);\n      elkService = moduleFixture.get<ElkService>(ElkService);\n      await app.init();\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be defined', () => {\n      expect(app).toBeDefined();\n    });\n  });\n});\n",
              "err": {},
              "uuid": "d820765a-c013-4dec-8034-2e2f6269c502",
              "parentUUID": "af49b4d7-ae8c-4f57-9a76-2df786d7179e",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "ElkModule > should be defined",
              "fullTitle": "should be defined",
              "timedOut": false,
              "duration": 1015,
              "state": "passed",
              "speed": null,
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { HttpException, INestApplication } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport {\n  dynamicConfig,\n  fixtureUserResponse,\n  TCElasticSearchOptions,\n  tcName,\n  testContainers,\n} from '@tresdoce-nestjs-toolkit/test-utils';\nimport { Observable, of, throwError } from 'rxjs';\nimport { HttpConnection } from '@elastic/elasticsearch';\nimport { URL } from 'url';\n\nimport { ElkModule } from '../elk/elk.module';\nimport { ElkInterceptor } from '../elk/interceptors/elk.interceptor';\nimport { ElkService } from '../elk/services/elk.service';\n\nlet executionContext: any = {\n  switchToHttp: jest.fn(() => ({\n    getRequest: () => ({\n      path: '/test',\n      method: 'GET',\n      params: {},\n      query: {},\n      body: {},\n      headers: {\n        'Content-Type': 'application/json',\n        apiKey: 'abcdefg12345',\n      },\n    }),\n    getResponse: () => ({\n      getHeaders: jest.fn().mockReturnValue({\n        'Content-Type': 'application/json',\n        my_header: 'test-header',\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() => 'http'),\n  getClass: jest.fn(() => 'testController'),\n  getHandler: jest.fn(() => 'handlerElk'),\n};\n\nlet executionContextParams: any = {\n  switchToHttp: jest.fn(() => ({\n    getRequest: () => ({\n      path: '/test',\n      method: 'GET',\n      params: { name: 'juan' },\n      query: { name: 'juan' },\n      body: { name: 'juan' },\n      headers: {\n        'Content-Type': 'application/json',\n        apiKey: 'abcdefg12345',\n      },\n    }),\n    getResponse: () => ({\n      getHeaders: jest.fn().mockReturnValue({\n        'Content-Type': 'application/json',\n        my_header: 'test-header',\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() => 'http'),\n  getClass: jest.fn(() => 'testController'),\n  getHandler: jest.fn(() => 'handlerElk'),\n};\n\n/*const callHandler: any = {\n  handle: jest.fn(() => ({\n    pipe: jest.fn(() => ({\n      tap: jest.fn(() => ({\n        next: jest.fn(),\n        error: jest.fn(),\n      })),\n    })),\n  })),\n};*/\n\njest.setTimeout(70000);\ndescribe('ElkModule', () => {\n  let app: INestApplication;\n  let elkService: ElkService;\n  let interceptor: ElkInterceptor<any>;\n  let container: testContainers;\n\n  beforeAll(async () => {\n    //'elasticsearch:8.3.3'\n    //docker.elastic.co/elasticsearch/elasticsearch:8.3.3\n\n    container = await new testContainers('elasticsearch:8.3.3', {\n      ...TCElasticSearchOptions,\n      containerName: `${tcName}-elasticsearch-interceptor`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () => {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () => {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              elasticsearch: {\n                name: 'test-elk-index',\n                node: {\n                  url: new URL(`http://${container.getHost()}:9200`),\n                },\n                maxRetries: 10,\n                requestTimeout: 60000,\n                sniffOnStart: true,\n                Connection: HttpConnection,\n              },\n            }),\n          ],\n        }),\n        ElkModule,\n      ],\n    }).compile();\n    app = moduleFixture.createNestApplication();\n    interceptor = new ElkInterceptor(app.get<ElkService>(ElkService));\n    app.useGlobalInterceptors(interceptor);\n    elkService = moduleFixture.get<ElkService>(ElkService);\n    await app.init();\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', () => {\n    expect(app).toBeDefined();\n  });\n\n  describe('ElkInterceptor', () => {\n    it('should be an ElkInterceptor instance to be defined', async () => {\n      expect(new ElkInterceptor(elkService)).toBeDefined();\n    });\n\n    it('should be create document in elasticsearch when return success string', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of('this is a test')),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return success object', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of([fixtureUserResponse])),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return success with parameters', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of([fixtureUserResponse])),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContextParams, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return exception', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const error = new Error(`User #$1 not found`);\n\n      const callHandler: any = {\n        handle: jest.fn(() => throwError(error)),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () => {},\n        error: (error) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n\n    it('should be create document in elasticsearch when return exception http', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const error = new HttpException('not found', 404);\n\n      const callHandler: any = {\n        handle: jest.fn(() => throwError(error)),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () => {},\n        error: (error) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n  });\n\n  describe('ElkModule - Register', () => {\n    let app: INestApplication;\n    let elkService: ElkService;\n    let interceptor: ElkInterceptor<any>;\n\n    beforeEach(async () => {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ElkModule.register({\n            name: 'test-elk-index',\n            node: {\n              url: new URL(`http://${container.getHost()}:9200`),\n            },\n            maxRetries: 10,\n            requestTimeout: 60000,\n            sniffOnStart: true,\n            Connection: HttpConnection,\n          }),\n        ],\n      }).compile();\n      app = moduleFixture.createNestApplication();\n      interceptor = new ElkInterceptor(app.get<ElkService>(ElkService));\n      app.useGlobalInterceptors(interceptor);\n      elkService = moduleFixture.get<ElkService>(ElkService);\n      await app.init();\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be defined', () => {\n      expect(app).toBeDefined();\n    });\n  });\n});\n",
              "err": {},
              "uuid": "f2dfabb4-41d0-45d5-9aaf-8ca383ab5b86",
              "parentUUID": "af49b4d7-ae8c-4f57-9a76-2df786d7179e",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "6d0815b0-4fb9-4c7a-abd9-41f2f9b1492b",
            "c2145fb4-be58-472c-bf3a-8e8a43ca7662",
            "25bb9171-547b-47af-a101-965bbe3899c8",
            "826a6dac-84b5-4409-a98e-11147dc03ca5",
            "a541dfa2-fa25-4c03-be49-515d65496ccc",
            "3983c915-caed-4155-8837-678038eb6ed8",
            "d820765a-c013-4dec-8034-2e2f6269c502",
            "f2dfabb4-41d0-45d5-9aaf-8ca383ab5b86"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 8383,
          "root": false,
          "rootEmpty": false,
          "_timeout": 5000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 5000
    }
  ]
}
