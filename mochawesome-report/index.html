<!doctype html>
<html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Tresdoce NestJS Toolkit - Test Reports</title><link rel="stylesheet" href="assets/app.css"/></head><body data-raw="{&quot;stats&quot;:{&quot;suites&quot;:13,&quot;tests&quot;:155,&quot;passes&quot;:155,&quot;pending&quot;:0,&quot;failures&quot;:0,&quot;testsRegistered&quot;:155,&quot;passPercent&quot;:100,&quot;pendingPercent&quot;:0,&quot;other&quot;:0,&quot;hasOther&quot;:false,&quot;skipped&quot;:0,&quot;hasSkipped&quot;:false,&quot;start&quot;:&quot;2023-05-03T12:59:18.946Z&quot;,&quot;end&quot;:&quot;2023-05-05T13:19:01.490Z&quot;,&quot;duration&quot;:173982544},&quot;results&quot;:[{&quot;uuid&quot;:&quot;75292f1c-953c-4f5d-9511-a0ff51df03b0&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/archetype&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;b8d02835-1254-45b7-b274-580ef3b4bc49&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/archetype&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;fullTitle&quot;:&quot;Constants &gt; should be return exclude to prefix global&quot;,&quot;title&quot;:&quot;Constants &gt; should be return exclude to prefix global&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { RequestMethod } from &#x27;@nestjs/common&#x27;;\nimport { manifestControllerExcludes } from &#x27;../archetype/constants/archetype.constants&#x27;;\n\ndescribe(&#x27;Constants&#x27;, () =&gt; {\n  it(&#x27;should be return exclude to prefix global&#x27;, async () =&gt; {\n    expect(manifestControllerExcludes).toEqual(expect.any(Array));\n    expect(manifestControllerExcludes).toMatchObject([\n      {\n        path: &#x27;/info&#x27;,\n        method: RequestMethod.GET,\n      },\n    ]);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ff8814c4-28a1-4306-a0a9-aac2db2eb62a&quot;,&quot;parentUUID&quot;:&quot;b8d02835-1254-45b7-b274-580ef3b4bc49&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;ArchetypeService &gt; should be defined&quot;,&quot;title&quot;:&quot;ArchetypeService &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\n\nimport { config, manifest } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\n\nimport { ArchetypeModule } from &#x27;../archetype/archetype.module&#x27;;\nimport { ArchetypeService } from &#x27;../archetype/services/archetype.service&#x27;;\n\ndescribe(&#x27;ArchetypeService&#x27;, () =&gt; {\n  let service: ArchetypeService;\n  /*const archetypeService = {\n      readFile: jest.fn(() =&gt; manifest),\n      getArchetypeVersion: jest.fn(() =&gt; ({ archetypeVersion: manifest.archetypeVersion })),\n      getApplicationInfo: jest.fn(() =&gt; ({\n        name: manifest.name,\n        version: manifest.version,\n        description: manifest.description,\n        author: manifest.author,\n        repository: manifest.repository,\n        homepage: manifest.homepage,\n        dependencies: manifest.dependencies,\n        devDependencies: manifest.devDependencies,\n      })),\n      generateManifest: jest.fn(() =&gt; manifest),\n    };*/\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        ArchetypeModule,\n      ],\n      providers: [ArchetypeService],\n    }).compile();\n\n    service = module.get&lt;ArchetypeService&gt;(ArchetypeService);\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(service).toBeDefined();\n  });\n\n  it(&#x27;should be read package file&#x27;, async () =&gt; {\n    const packageFile = await service.readFile(__dirname, &#x27;../../package.json&#x27;);\n    expect(packageFile).toBeDefined();\n    expect(packageFile).toEqual(expect.any(Object));\n  });\n\n  it(&#x27;should be return archetype version&#x27;, async () =&gt; {\n    service.readFile = jest.fn().mockImplementation(() =&gt; ({ version: manifest.archetypeVersion }));\n\n    expect(await service.getArchetypeVersion()).toEqual({\n      archetypeVersion: manifest.archetypeVersion,\n    });\n  });\n\n  it(&#x27;should be return application info&#x27;, async () =&gt; {\n    service.readFile = jest.fn().mockImplementation(() =&gt; ({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: manifest.dependencies,\n      devDependencies: manifest.devDependencies,\n    }));\n\n    expect(await service.getApplicationInfo()).toEqual({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: {\n        &#x27;@tresdoce-nestjs-toolkit/archetype&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@tresdoce-nestjs-toolkit/health&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@tresdoce-nestjs-toolkit/http-client&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@nestjs/class-transformer&#x27;: &#x27;^0.4.0&#x27;,\n        &#x27;@nestjs/class-validator&#x27;: &#x27;^0.13.3&#x27;,\n        &#x27;@nestjs/common&#x27;: &#x27;^9.2.1&#x27;,\n        &#x27;@nestjs/config&#x27;: &#x27;^2.2.0&#x27;,\n        &#x27;@nestjs/core&#x27;: &#x27;^8.2.5&#x27;,\n        &#x27;@nestjs/platform-express&#x27;: &#x27;^8.2.5&#x27;,\n        &#x27;@nestjs/swagger&#x27;: &#x27;^5.1.5&#x27;,\n      },\n      devDependencies: {\n        &#x27;@tresdoce-nestjs-toolkit/commons&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@nestjs/cli&#x27;: &#x27;^9.1.8&#x27;,\n        &#x27;@nestjs/schematics&#x27;: &#x27;^9.1.0&#x27;,\n        &#x27;@nestjs/testing&#x27;: &#x27;^9.4.0&#x27;,\n      },\n    });\n  });\n\n  it(&#x27;should be return manifest&#x27;, async () =&gt; {\n    service.getArchetypeVersion = jest.fn().mockImplementation(() =&gt; ({\n      archetypeVersion: manifest.archetypeVersion,\n    }));\n\n    service.getApplicationInfo = jest.fn().mockImplementation(() =&gt; ({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: manifest.dependencies,\n      devDependencies: manifest.devDependencies,\n    }));\n\n    expect(await service.generateManifest()).toEqual({ ...manifest });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;64e83238-36ca-46ca-912e-747de812fb10&quot;,&quot;parentUUID&quot;:&quot;b8d02835-1254-45b7-b274-580ef3b4bc49&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;ArchetypeService &gt; should be read package file&quot;,&quot;title&quot;:&quot;ArchetypeService &gt; should be read package file&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\n\nimport { config, manifest } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\n\nimport { ArchetypeModule } from &#x27;../archetype/archetype.module&#x27;;\nimport { ArchetypeService } from &#x27;../archetype/services/archetype.service&#x27;;\n\ndescribe(&#x27;ArchetypeService&#x27;, () =&gt; {\n  let service: ArchetypeService;\n  /*const archetypeService = {\n      readFile: jest.fn(() =&gt; manifest),\n      getArchetypeVersion: jest.fn(() =&gt; ({ archetypeVersion: manifest.archetypeVersion })),\n      getApplicationInfo: jest.fn(() =&gt; ({\n        name: manifest.name,\n        version: manifest.version,\n        description: manifest.description,\n        author: manifest.author,\n        repository: manifest.repository,\n        homepage: manifest.homepage,\n        dependencies: manifest.dependencies,\n        devDependencies: manifest.devDependencies,\n      })),\n      generateManifest: jest.fn(() =&gt; manifest),\n    };*/\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        ArchetypeModule,\n      ],\n      providers: [ArchetypeService],\n    }).compile();\n\n    service = module.get&lt;ArchetypeService&gt;(ArchetypeService);\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(service).toBeDefined();\n  });\n\n  it(&#x27;should be read package file&#x27;, async () =&gt; {\n    const packageFile = await service.readFile(__dirname, &#x27;../../package.json&#x27;);\n    expect(packageFile).toBeDefined();\n    expect(packageFile).toEqual(expect.any(Object));\n  });\n\n  it(&#x27;should be return archetype version&#x27;, async () =&gt; {\n    service.readFile = jest.fn().mockImplementation(() =&gt; ({ version: manifest.archetypeVersion }));\n\n    expect(await service.getArchetypeVersion()).toEqual({\n      archetypeVersion: manifest.archetypeVersion,\n    });\n  });\n\n  it(&#x27;should be return application info&#x27;, async () =&gt; {\n    service.readFile = jest.fn().mockImplementation(() =&gt; ({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: manifest.dependencies,\n      devDependencies: manifest.devDependencies,\n    }));\n\n    expect(await service.getApplicationInfo()).toEqual({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: {\n        &#x27;@tresdoce-nestjs-toolkit/archetype&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@tresdoce-nestjs-toolkit/health&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@tresdoce-nestjs-toolkit/http-client&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@nestjs/class-transformer&#x27;: &#x27;^0.4.0&#x27;,\n        &#x27;@nestjs/class-validator&#x27;: &#x27;^0.13.3&#x27;,\n        &#x27;@nestjs/common&#x27;: &#x27;^9.2.1&#x27;,\n        &#x27;@nestjs/config&#x27;: &#x27;^2.2.0&#x27;,\n        &#x27;@nestjs/core&#x27;: &#x27;^8.2.5&#x27;,\n        &#x27;@nestjs/platform-express&#x27;: &#x27;^8.2.5&#x27;,\n        &#x27;@nestjs/swagger&#x27;: &#x27;^5.1.5&#x27;,\n      },\n      devDependencies: {\n        &#x27;@tresdoce-nestjs-toolkit/commons&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@nestjs/cli&#x27;: &#x27;^9.1.8&#x27;,\n        &#x27;@nestjs/schematics&#x27;: &#x27;^9.1.0&#x27;,\n        &#x27;@nestjs/testing&#x27;: &#x27;^9.4.0&#x27;,\n      },\n    });\n  });\n\n  it(&#x27;should be return manifest&#x27;, async () =&gt; {\n    service.getArchetypeVersion = jest.fn().mockImplementation(() =&gt; ({\n      archetypeVersion: manifest.archetypeVersion,\n    }));\n\n    service.getApplicationInfo = jest.fn().mockImplementation(() =&gt; ({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: manifest.dependencies,\n      devDependencies: manifest.devDependencies,\n    }));\n\n    expect(await service.generateManifest()).toEqual({ ...manifest });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;22b75286-0e8c-4e31-89ca-120ec6c6970a&quot;,&quot;parentUUID&quot;:&quot;b8d02835-1254-45b7-b274-580ef3b4bc49&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;ArchetypeService &gt; should be return archetype version&quot;,&quot;title&quot;:&quot;ArchetypeService &gt; should be return archetype version&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\n\nimport { config, manifest } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\n\nimport { ArchetypeModule } from &#x27;../archetype/archetype.module&#x27;;\nimport { ArchetypeService } from &#x27;../archetype/services/archetype.service&#x27;;\n\ndescribe(&#x27;ArchetypeService&#x27;, () =&gt; {\n  let service: ArchetypeService;\n  /*const archetypeService = {\n      readFile: jest.fn(() =&gt; manifest),\n      getArchetypeVersion: jest.fn(() =&gt; ({ archetypeVersion: manifest.archetypeVersion })),\n      getApplicationInfo: jest.fn(() =&gt; ({\n        name: manifest.name,\n        version: manifest.version,\n        description: manifest.description,\n        author: manifest.author,\n        repository: manifest.repository,\n        homepage: manifest.homepage,\n        dependencies: manifest.dependencies,\n        devDependencies: manifest.devDependencies,\n      })),\n      generateManifest: jest.fn(() =&gt; manifest),\n    };*/\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        ArchetypeModule,\n      ],\n      providers: [ArchetypeService],\n    }).compile();\n\n    service = module.get&lt;ArchetypeService&gt;(ArchetypeService);\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(service).toBeDefined();\n  });\n\n  it(&#x27;should be read package file&#x27;, async () =&gt; {\n    const packageFile = await service.readFile(__dirname, &#x27;../../package.json&#x27;);\n    expect(packageFile).toBeDefined();\n    expect(packageFile).toEqual(expect.any(Object));\n  });\n\n  it(&#x27;should be return archetype version&#x27;, async () =&gt; {\n    service.readFile = jest.fn().mockImplementation(() =&gt; ({ version: manifest.archetypeVersion }));\n\n    expect(await service.getArchetypeVersion()).toEqual({\n      archetypeVersion: manifest.archetypeVersion,\n    });\n  });\n\n  it(&#x27;should be return application info&#x27;, async () =&gt; {\n    service.readFile = jest.fn().mockImplementation(() =&gt; ({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: manifest.dependencies,\n      devDependencies: manifest.devDependencies,\n    }));\n\n    expect(await service.getApplicationInfo()).toEqual({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: {\n        &#x27;@tresdoce-nestjs-toolkit/archetype&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@tresdoce-nestjs-toolkit/health&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@tresdoce-nestjs-toolkit/http-client&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@nestjs/class-transformer&#x27;: &#x27;^0.4.0&#x27;,\n        &#x27;@nestjs/class-validator&#x27;: &#x27;^0.13.3&#x27;,\n        &#x27;@nestjs/common&#x27;: &#x27;^9.2.1&#x27;,\n        &#x27;@nestjs/config&#x27;: &#x27;^2.2.0&#x27;,\n        &#x27;@nestjs/core&#x27;: &#x27;^8.2.5&#x27;,\n        &#x27;@nestjs/platform-express&#x27;: &#x27;^8.2.5&#x27;,\n        &#x27;@nestjs/swagger&#x27;: &#x27;^5.1.5&#x27;,\n      },\n      devDependencies: {\n        &#x27;@tresdoce-nestjs-toolkit/commons&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@nestjs/cli&#x27;: &#x27;^9.1.8&#x27;,\n        &#x27;@nestjs/schematics&#x27;: &#x27;^9.1.0&#x27;,\n        &#x27;@nestjs/testing&#x27;: &#x27;^9.4.0&#x27;,\n      },\n    });\n  });\n\n  it(&#x27;should be return manifest&#x27;, async () =&gt; {\n    service.getArchetypeVersion = jest.fn().mockImplementation(() =&gt; ({\n      archetypeVersion: manifest.archetypeVersion,\n    }));\n\n    service.getApplicationInfo = jest.fn().mockImplementation(() =&gt; ({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: manifest.dependencies,\n      devDependencies: manifest.devDependencies,\n    }));\n\n    expect(await service.generateManifest()).toEqual({ ...manifest });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;562055ca-7c34-4ec7-9f64-1a91ba135be5&quot;,&quot;parentUUID&quot;:&quot;b8d02835-1254-45b7-b274-580ef3b4bc49&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;ArchetypeService &gt; should be return application info&quot;,&quot;title&quot;:&quot;ArchetypeService &gt; should be return application info&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\n\nimport { config, manifest } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\n\nimport { ArchetypeModule } from &#x27;../archetype/archetype.module&#x27;;\nimport { ArchetypeService } from &#x27;../archetype/services/archetype.service&#x27;;\n\ndescribe(&#x27;ArchetypeService&#x27;, () =&gt; {\n  let service: ArchetypeService;\n  /*const archetypeService = {\n      readFile: jest.fn(() =&gt; manifest),\n      getArchetypeVersion: jest.fn(() =&gt; ({ archetypeVersion: manifest.archetypeVersion })),\n      getApplicationInfo: jest.fn(() =&gt; ({\n        name: manifest.name,\n        version: manifest.version,\n        description: manifest.description,\n        author: manifest.author,\n        repository: manifest.repository,\n        homepage: manifest.homepage,\n        dependencies: manifest.dependencies,\n        devDependencies: manifest.devDependencies,\n      })),\n      generateManifest: jest.fn(() =&gt; manifest),\n    };*/\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        ArchetypeModule,\n      ],\n      providers: [ArchetypeService],\n    }).compile();\n\n    service = module.get&lt;ArchetypeService&gt;(ArchetypeService);\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(service).toBeDefined();\n  });\n\n  it(&#x27;should be read package file&#x27;, async () =&gt; {\n    const packageFile = await service.readFile(__dirname, &#x27;../../package.json&#x27;);\n    expect(packageFile).toBeDefined();\n    expect(packageFile).toEqual(expect.any(Object));\n  });\n\n  it(&#x27;should be return archetype version&#x27;, async () =&gt; {\n    service.readFile = jest.fn().mockImplementation(() =&gt; ({ version: manifest.archetypeVersion }));\n\n    expect(await service.getArchetypeVersion()).toEqual({\n      archetypeVersion: manifest.archetypeVersion,\n    });\n  });\n\n  it(&#x27;should be return application info&#x27;, async () =&gt; {\n    service.readFile = jest.fn().mockImplementation(() =&gt; ({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: manifest.dependencies,\n      devDependencies: manifest.devDependencies,\n    }));\n\n    expect(await service.getApplicationInfo()).toEqual({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: {\n        &#x27;@tresdoce-nestjs-toolkit/archetype&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@tresdoce-nestjs-toolkit/health&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@tresdoce-nestjs-toolkit/http-client&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@nestjs/class-transformer&#x27;: &#x27;^0.4.0&#x27;,\n        &#x27;@nestjs/class-validator&#x27;: &#x27;^0.13.3&#x27;,\n        &#x27;@nestjs/common&#x27;: &#x27;^9.2.1&#x27;,\n        &#x27;@nestjs/config&#x27;: &#x27;^2.2.0&#x27;,\n        &#x27;@nestjs/core&#x27;: &#x27;^8.2.5&#x27;,\n        &#x27;@nestjs/platform-express&#x27;: &#x27;^8.2.5&#x27;,\n        &#x27;@nestjs/swagger&#x27;: &#x27;^5.1.5&#x27;,\n      },\n      devDependencies: {\n        &#x27;@tresdoce-nestjs-toolkit/commons&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@nestjs/cli&#x27;: &#x27;^9.1.8&#x27;,\n        &#x27;@nestjs/schematics&#x27;: &#x27;^9.1.0&#x27;,\n        &#x27;@nestjs/testing&#x27;: &#x27;^9.4.0&#x27;,\n      },\n    });\n  });\n\n  it(&#x27;should be return manifest&#x27;, async () =&gt; {\n    service.getArchetypeVersion = jest.fn().mockImplementation(() =&gt; ({\n      archetypeVersion: manifest.archetypeVersion,\n    }));\n\n    service.getApplicationInfo = jest.fn().mockImplementation(() =&gt; ({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: manifest.dependencies,\n      devDependencies: manifest.devDependencies,\n    }));\n\n    expect(await service.generateManifest()).toEqual({ ...manifest });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e37f224c-673c-4d74-9282-aea6b54fe043&quot;,&quot;parentUUID&quot;:&quot;b8d02835-1254-45b7-b274-580ef3b4bc49&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;ArchetypeService &gt; should be return manifest&quot;,&quot;title&quot;:&quot;ArchetypeService &gt; should be return manifest&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\n\nimport { config, manifest } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\n\nimport { ArchetypeModule } from &#x27;../archetype/archetype.module&#x27;;\nimport { ArchetypeService } from &#x27;../archetype/services/archetype.service&#x27;;\n\ndescribe(&#x27;ArchetypeService&#x27;, () =&gt; {\n  let service: ArchetypeService;\n  /*const archetypeService = {\n      readFile: jest.fn(() =&gt; manifest),\n      getArchetypeVersion: jest.fn(() =&gt; ({ archetypeVersion: manifest.archetypeVersion })),\n      getApplicationInfo: jest.fn(() =&gt; ({\n        name: manifest.name,\n        version: manifest.version,\n        description: manifest.description,\n        author: manifest.author,\n        repository: manifest.repository,\n        homepage: manifest.homepage,\n        dependencies: manifest.dependencies,\n        devDependencies: manifest.devDependencies,\n      })),\n      generateManifest: jest.fn(() =&gt; manifest),\n    };*/\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        ArchetypeModule,\n      ],\n      providers: [ArchetypeService],\n    }).compile();\n\n    service = module.get&lt;ArchetypeService&gt;(ArchetypeService);\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(service).toBeDefined();\n  });\n\n  it(&#x27;should be read package file&#x27;, async () =&gt; {\n    const packageFile = await service.readFile(__dirname, &#x27;../../package.json&#x27;);\n    expect(packageFile).toBeDefined();\n    expect(packageFile).toEqual(expect.any(Object));\n  });\n\n  it(&#x27;should be return archetype version&#x27;, async () =&gt; {\n    service.readFile = jest.fn().mockImplementation(() =&gt; ({ version: manifest.archetypeVersion }));\n\n    expect(await service.getArchetypeVersion()).toEqual({\n      archetypeVersion: manifest.archetypeVersion,\n    });\n  });\n\n  it(&#x27;should be return application info&#x27;, async () =&gt; {\n    service.readFile = jest.fn().mockImplementation(() =&gt; ({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: manifest.dependencies,\n      devDependencies: manifest.devDependencies,\n    }));\n\n    expect(await service.getApplicationInfo()).toEqual({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: {\n        &#x27;@tresdoce-nestjs-toolkit/archetype&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@tresdoce-nestjs-toolkit/health&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@tresdoce-nestjs-toolkit/http-client&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@nestjs/class-transformer&#x27;: &#x27;^0.4.0&#x27;,\n        &#x27;@nestjs/class-validator&#x27;: &#x27;^0.13.3&#x27;,\n        &#x27;@nestjs/common&#x27;: &#x27;^9.2.1&#x27;,\n        &#x27;@nestjs/config&#x27;: &#x27;^2.2.0&#x27;,\n        &#x27;@nestjs/core&#x27;: &#x27;^8.2.5&#x27;,\n        &#x27;@nestjs/platform-express&#x27;: &#x27;^8.2.5&#x27;,\n        &#x27;@nestjs/swagger&#x27;: &#x27;^5.1.5&#x27;,\n      },\n      devDependencies: {\n        &#x27;@tresdoce-nestjs-toolkit/commons&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@nestjs/cli&#x27;: &#x27;^9.1.8&#x27;,\n        &#x27;@nestjs/schematics&#x27;: &#x27;^9.1.0&#x27;,\n        &#x27;@nestjs/testing&#x27;: &#x27;^9.4.0&#x27;,\n      },\n    });\n  });\n\n  it(&#x27;should be return manifest&#x27;, async () =&gt; {\n    service.getArchetypeVersion = jest.fn().mockImplementation(() =&gt; ({\n      archetypeVersion: manifest.archetypeVersion,\n    }));\n\n    service.getApplicationInfo = jest.fn().mockImplementation(() =&gt; ({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: manifest.dependencies,\n      devDependencies: manifest.devDependencies,\n    }));\n\n    expect(await service.generateManifest()).toEqual({ ...manifest });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;abda106f-1bb2-457b-bd44-8679a51e6e1e&quot;,&quot;parentUUID&quot;:&quot;b8d02835-1254-45b7-b274-580ef3b4bc49&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;ArchetypeModule &gt; should be define&quot;,&quot;title&quot;:&quot;ArchetypeModule &gt; should be define&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:176,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { config } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\n\nimport { ArchetypeModule } from &#x27;../archetype/archetype.module&#x27;;\n\ndescribe(&#x27;ArchetypeModule&#x27;, () =&gt; {\n  let app: INestApplication;\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        ArchetypeModule,\n      ],\n    }).compile();\n\n    app = module.createNestApplication();\n    await app.init();\n  });\n\n  it(&#x27;should be define&#x27;, async () =&gt; {\n    expect(app).toBeDefined();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1589982f-89e3-408b-9c27-ac6218a19536&quot;,&quot;parentUUID&quot;:&quot;b8d02835-1254-45b7-b274-580ef3b4bc49&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;ArchetypeController &gt; should be defined&quot;,&quot;title&quot;:&quot;ArchetypeController &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:15,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\n\nimport { config, manifest } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\n\nimport { ArchetypeModule } from &#x27;../archetype/archetype.module&#x27;;\nimport { ArchetypeController } from &#x27;../archetype/controllers/archetype.controller&#x27;;\nimport { ArchetypeService } from &#x27;../archetype/services/archetype.service&#x27;;\n\ndescribe(&#x27;ArchetypeController&#x27;, () =&gt; {\n  let controller: ArchetypeController;\n  const archetypeService = {\n    generateManifest: () =&gt; manifest,\n  };\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        ArchetypeModule,\n      ],\n      controllers: [ArchetypeController],\n      providers: [ArchetypeService],\n    })\n      .overrideProvider(ArchetypeService)\n      .useValue(archetypeService)\n      .compile();\n\n    controller = module.get&lt;ArchetypeController&gt;(ArchetypeController);\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(controller).toBeDefined();\n  });\n\n  it(&#x27;should be return manifest json&#x27;, async () =&gt; {\n    expect(await controller.getArchetypeInfo()).toBeDefined();\n    expect(await controller.getArchetypeInfo()).toEqual(manifest);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;84630f0a-3aa5-487f-8ebb-bf998274d0a4&quot;,&quot;parentUUID&quot;:&quot;b8d02835-1254-45b7-b274-580ef3b4bc49&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;ArchetypeController &gt; should be return manifest json&quot;,&quot;title&quot;:&quot;ArchetypeController &gt; should be return manifest json&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\n\nimport { config, manifest } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\n\nimport { ArchetypeModule } from &#x27;../archetype/archetype.module&#x27;;\nimport { ArchetypeController } from &#x27;../archetype/controllers/archetype.controller&#x27;;\nimport { ArchetypeService } from &#x27;../archetype/services/archetype.service&#x27;;\n\ndescribe(&#x27;ArchetypeController&#x27;, () =&gt; {\n  let controller: ArchetypeController;\n  const archetypeService = {\n    generateManifest: () =&gt; manifest,\n  };\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        ArchetypeModule,\n      ],\n      controllers: [ArchetypeController],\n      providers: [ArchetypeService],\n    })\n      .overrideProvider(ArchetypeService)\n      .useValue(archetypeService)\n      .compile();\n\n    controller = module.get&lt;ArchetypeController&gt;(ArchetypeController);\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(controller).toBeDefined();\n  });\n\n  it(&#x27;should be return manifest json&#x27;, async () =&gt; {\n    expect(await controller.getArchetypeInfo()).toBeDefined();\n    expect(await controller.getArchetypeInfo()).toEqual(manifest);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;8b30e9c1-b1a1-4d9e-87e6-9cfefb180c08&quot;,&quot;parentUUID&quot;:&quot;b8d02835-1254-45b7-b274-580ef3b4bc49&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;ff8814c4-28a1-4306-a0a9-aac2db2eb62a&quot;,&quot;64e83238-36ca-46ca-912e-747de812fb10&quot;,&quot;22b75286-0e8c-4e31-89ca-120ec6c6970a&quot;,&quot;562055ca-7c34-4ec7-9f64-1a91ba135be5&quot;,&quot;e37f224c-673c-4d74-9282-aea6b54fe043&quot;,&quot;abda106f-1bb2-457b-bd44-8679a51e6e1e&quot;,&quot;1589982f-89e3-408b-9c27-ac6218a19536&quot;,&quot;84630f0a-3aa5-487f-8ebb-bf998274d0a4&quot;,&quot;8b30e9c1-b1a1-4d9e-87e6-9cfefb180c08&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:233,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:5000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:5000},{&quot;uuid&quot;:&quot;52a2b92b-6964-4091-a0f7-a550e5f41e5b&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/camunda&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;e06016ae-c05f-45a2-b550-df0909725a04&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/camunda&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;fullTitle&quot;:&quot;CamundaModule &gt; should be defined&quot;,&quot;title&quot;:&quot;CamundaModule &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:177,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport { CamundaModule } from &#x27;../camunda/camunda.module&#x27;;\nimport { dynamicConfig, tcName, testContainers } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { Subscription } from &#x27;../camunda/decorators/camunda.decorator&#x27;;\nimport { CamundaTaskConnector } from &#x27;../camunda/providers/camunda.provider&#x27;;\n\ndescribe(&#x27;CamundaModule&#x27;, () =&gt; {\n  let app: INestApplication;\n  let container: testContainers;\n\n  beforeAll(async () =&gt; {\n    container = await new testContainers(&#x27;camunda/camunda-bpm-platform:7.17.0&#x27;, {\n      ports: [\n        {\n          container: 8080,\n          host: 8080,\n        },\n      ],\n      containerName: `${tcName}-camunda-bpm`,\n      reuse: true,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              camunda: {\n                baseUrl: &#x27;http://localhost:8080/engine-rest&#x27;,\n              },\n            }),\n          ],\n        }),\n        CamundaModule,\n      ],\n    }).compile();\n\n    app = moduleFixture.createNestApplication();\n    app.connectMicroservice({\n      strategy: app.get(CamundaTaskConnector),\n    });\n    await app.startAllMicroservices();\n    await app.init();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(app).toBeDefined();\n  });\n\n  it(&#x27;should be Subscription decorator is defined with options&#x27;, async () =&gt; {\n    const decorator = Subscription(&#x27;test-topic&#x27;, { lockDuration: 500 });\n    console.log(decorator);\n    expect(decorator).toBeDefined();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d003e42c-3476-4e59-a224-b05989e3a999&quot;,&quot;parentUUID&quot;:&quot;e06016ae-c05f-45a2-b550-df0909725a04&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;CamundaModule &gt; should be Subscription decorator is defined with options&quot;,&quot;title&quot;:&quot;CamundaModule &gt; should be Subscription decorator is defined with options&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport { CamundaModule } from &#x27;../camunda/camunda.module&#x27;;\nimport { dynamicConfig, tcName, testContainers } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { Subscription } from &#x27;../camunda/decorators/camunda.decorator&#x27;;\nimport { CamundaTaskConnector } from &#x27;../camunda/providers/camunda.provider&#x27;;\n\ndescribe(&#x27;CamundaModule&#x27;, () =&gt; {\n  let app: INestApplication;\n  let container: testContainers;\n\n  beforeAll(async () =&gt; {\n    container = await new testContainers(&#x27;camunda/camunda-bpm-platform:7.17.0&#x27;, {\n      ports: [\n        {\n          container: 8080,\n          host: 8080,\n        },\n      ],\n      containerName: `${tcName}-camunda-bpm`,\n      reuse: true,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              camunda: {\n                baseUrl: &#x27;http://localhost:8080/engine-rest&#x27;,\n              },\n            }),\n          ],\n        }),\n        CamundaModule,\n      ],\n    }).compile();\n\n    app = moduleFixture.createNestApplication();\n    app.connectMicroservice({\n      strategy: app.get(CamundaTaskConnector),\n    });\n    await app.startAllMicroservices();\n    await app.init();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(app).toBeDefined();\n  });\n\n  it(&#x27;should be Subscription decorator is defined with options&#x27;, async () =&gt; {\n    const decorator = Subscription(&#x27;test-topic&#x27;, { lockDuration: 500 });\n    console.log(decorator);\n    expect(decorator).toBeDefined();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3509395e-b7dc-4f4e-9790-711f4c8c9da2&quot;,&quot;parentUUID&quot;:&quot;e06016ae-c05f-45a2-b550-df0909725a04&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;d003e42c-3476-4e59-a224-b05989e3a999&quot;,&quot;3509395e-b7dc-4f4e-9790-711f4c8c9da2&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:186,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:5000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:5000},{&quot;uuid&quot;:&quot;9134f974-0456-4760-b66e-9bab6a0072f6&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/commons&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;05f0e9f7-549a-4cae-9195-4f50b743658c&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/commons&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;fullTitle&quot;:&quot;build-config &gt; should be return jest config is build&quot;,&quot;title&quot;:&quot;build-config &gt; should be return jest config is build&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { buildConfig } from &#x27;../index&#x27;;\ndescribe(&#x27;build-config&#x27;, () =&gt; {\n  const INIT_ENVS = process.env;\n\n  beforeEach(() =&gt; {\n    jest.resetModules();\n    process.env = { ...INIT_ENVS };\n  });\n\n  afterAll(() =&gt; {\n    process.env = INIT_ENVS;\n  });\n\n  it(&#x27;should be return jest config is build&#x27;, () =&gt; {\n    process.env.NODE_ENV = &#x27;build&#x27;;\n    const config = buildConfig({ output: {}, optimization: {} });\n    expect(config).not.toBe(null);\n    expect(typeof config).toBe(&#x27;object&#x27;);\n    expect(config).toBeDefined();\n    expect(config.mode).toEqual(&#x27;production&#x27;);\n  });\n\n  it(&#x27;should be return jest config not is build&#x27;, () =&gt; {\n    process.env.NODE_ENV = &#x27;dev&#x27;;\n    const config = buildConfig({ output: {}, optimization: {} });\n    expect(config).not.toBe(null);\n    expect(typeof config).toBe(&#x27;object&#x27;);\n    expect(config).toBeDefined();\n    expect(config.mode).toEqual(&#x27;none&#x27;);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c6966595-2662-4fac-abb4-c256a2c1a8dc&quot;,&quot;parentUUID&quot;:&quot;05f0e9f7-549a-4cae-9195-4f50b743658c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;build-config &gt; should be return jest config not is build&quot;,&quot;title&quot;:&quot;build-config &gt; should be return jest config not is build&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { buildConfig } from &#x27;../index&#x27;;\ndescribe(&#x27;build-config&#x27;, () =&gt; {\n  const INIT_ENVS = process.env;\n\n  beforeEach(() =&gt; {\n    jest.resetModules();\n    process.env = { ...INIT_ENVS };\n  });\n\n  afterAll(() =&gt; {\n    process.env = INIT_ENVS;\n  });\n\n  it(&#x27;should be return jest config is build&#x27;, () =&gt; {\n    process.env.NODE_ENV = &#x27;build&#x27;;\n    const config = buildConfig({ output: {}, optimization: {} });\n    expect(config).not.toBe(null);\n    expect(typeof config).toBe(&#x27;object&#x27;);\n    expect(config).toBeDefined();\n    expect(config.mode).toEqual(&#x27;production&#x27;);\n  });\n\n  it(&#x27;should be return jest config not is build&#x27;, () =&gt; {\n    process.env.NODE_ENV = &#x27;dev&#x27;;\n    const config = buildConfig({ output: {}, optimization: {} });\n    expect(config).not.toBe(null);\n    expect(typeof config).toBe(&#x27;object&#x27;);\n    expect(config).toBeDefined();\n    expect(config.mode).toEqual(&#x27;none&#x27;);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d7a8aadf-6a65-47a7-a0d1-6599072eeb23&quot;,&quot;parentUUID&quot;:&quot;05f0e9f7-549a-4cae-9195-4f50b743658c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;testing-library &gt; should be return jest config&quot;,&quot;title&quot;:&quot;testing-library &gt; should be return jest config&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { jestConfig } from &#x27;../index&#x27;;\n\ndescribe(&#x27;testing-library&#x27;, () =&gt; {\n  it(&#x27;should be return jest config&#x27;, () =&gt; {\n    const config = jestConfig();\n    expect(config).not.toBe(null);\n    expect(typeof config).toBe(&#x27;object&#x27;);\n    expect(config).toBeDefined();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7d07e3f4-48ac-4308-8c17-34e45868689a&quot;,&quot;parentUUID&quot;:&quot;05f0e9f7-549a-4cae-9195-4f50b743658c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;eslint-config &gt; should be return jest config&quot;,&quot;title&quot;:&quot;eslint-config &gt; should be return jest config&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { eslintConfig } from &#x27;../index&#x27;;\ndescribe(&#x27;eslint-config&#x27;, () =&gt; {\n  it(&#x27;should be return jest config&#x27;, () =&gt; {\n    const config = eslintConfig();\n    expect(config).not.toBe(null);\n    expect(typeof config).toBe(&#x27;object&#x27;);\n    expect(config).toBeDefined();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;03544d79-00c1-4c54-88f3-2357f75aa579&quot;,&quot;parentUUID&quot;:&quot;05f0e9f7-549a-4cae-9195-4f50b743658c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;c6966595-2662-4fac-abb4-c256a2c1a8dc&quot;,&quot;d7a8aadf-6a65-47a7-a0d1-6599072eeb23&quot;,&quot;7d07e3f4-48ac-4308-8c17-34e45868689a&quot;,&quot;03544d79-00c1-4c54-88f3-2357f75aa579&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:8,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:5000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:5000},{&quot;uuid&quot;:&quot;a5a6f14a-90ec-410c-8361-f8188348a5e7&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/core&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;fef2c576-2dad-42e2-94b3-6609a1a5ea47&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/core&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;fullTitle&quot;:&quot;commons &gt; with env context &gt; should be return commons exclude paths with context&quot;,&quot;title&quot;:&quot;commons &gt; with env context &gt; should be return commons exclude paths with context&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { corePathsExcludes, excludePaths } from &#x27;../index&#x27;;\nimport { RequestMethod } from &#x27;@nestjs/common&#x27;;\n\ndescribe(&#x27;commons&#x27;, () =&gt; {\n  describe(&#x27;with env context&#x27;, () =&gt; {\n    beforeEach(() =&gt; {\n      process.env.CONTEXT = &#x27;v1/api-test&#x27;;\n    });\n\n    it(&#x27;should be return commons exclude paths with context&#x27;, () =&gt; {\n      expect(corePathsExcludes()).not.toBe(null);\n      expect(corePathsExcludes()).toBeDefined();\n      expect(corePathsExcludes()).toBeInstanceOf(Array);\n\n      expect(corePathsExcludes()).toContainObject({\n        path: `/v1/api-test/health/liveness`,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: `/v1/api-test/health/readiness`,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: `/v1/api-test/info`,\n        method: RequestMethod.GET,\n      });\n    });\n\n    it(&#x27;should be return array of exclude paths with context&#x27;, () =&gt; {\n      expect(excludePaths()).not.toBe(null);\n      expect(excludePaths()).toBeDefined();\n      expect(excludePaths()).toBeInstanceOf(Array);\n      expect(excludePaths()).toEqual([\n        `/v1/api-test/health/liveness`,\n        `/v1/api-test/health/readiness`,\n        `/v1/api-test/info`,\n      ]);\n    });\n  });\n\n  describe(&#x27;without env context&#x27;, () =&gt; {\n    beforeEach(() =&gt; {\n      process.env.CONTEXT = &#x27;&#x27;;\n    });\n\n    it(&#x27;should be return commons exclude paths without context&#x27;, () =&gt; {\n      expect(corePathsExcludes()).not.toBe(null);\n      expect(corePathsExcludes()).toBeDefined();\n      expect(corePathsExcludes()).toBeInstanceOf(Array);\n\n      expect(corePathsExcludes()).toContainObject({\n        path: &#x27;/health/liveness&#x27;,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: &#x27;/health/readiness&#x27;,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: &#x27;/info&#x27;,\n        method: RequestMethod.GET,\n      });\n    });\n\n    it(&#x27;should be return array of exclude paths without context&#x27;, () =&gt; {\n      expect(excludePaths()).not.toBe(null);\n      expect(excludePaths()).toBeDefined();\n      expect(excludePaths()).toBeInstanceOf(Array);\n      expect(excludePaths()).toEqual([&#x27;/health/liveness&#x27;, &#x27;/health/readiness&#x27;, &#x27;/info&#x27;]);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6daa302e-8e35-4483-8363-a6a8a03eeab2&quot;,&quot;parentUUID&quot;:&quot;fef2c576-2dad-42e2-94b3-6609a1a5ea47&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;commons &gt; with env context &gt; should be return array of exclude paths with context&quot;,&quot;title&quot;:&quot;commons &gt; with env context &gt; should be return array of exclude paths with context&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { corePathsExcludes, excludePaths } from &#x27;../index&#x27;;\nimport { RequestMethod } from &#x27;@nestjs/common&#x27;;\n\ndescribe(&#x27;commons&#x27;, () =&gt; {\n  describe(&#x27;with env context&#x27;, () =&gt; {\n    beforeEach(() =&gt; {\n      process.env.CONTEXT = &#x27;v1/api-test&#x27;;\n    });\n\n    it(&#x27;should be return commons exclude paths with context&#x27;, () =&gt; {\n      expect(corePathsExcludes()).not.toBe(null);\n      expect(corePathsExcludes()).toBeDefined();\n      expect(corePathsExcludes()).toBeInstanceOf(Array);\n\n      expect(corePathsExcludes()).toContainObject({\n        path: `/v1/api-test/health/liveness`,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: `/v1/api-test/health/readiness`,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: `/v1/api-test/info`,\n        method: RequestMethod.GET,\n      });\n    });\n\n    it(&#x27;should be return array of exclude paths with context&#x27;, () =&gt; {\n      expect(excludePaths()).not.toBe(null);\n      expect(excludePaths()).toBeDefined();\n      expect(excludePaths()).toBeInstanceOf(Array);\n      expect(excludePaths()).toEqual([\n        `/v1/api-test/health/liveness`,\n        `/v1/api-test/health/readiness`,\n        `/v1/api-test/info`,\n      ]);\n    });\n  });\n\n  describe(&#x27;without env context&#x27;, () =&gt; {\n    beforeEach(() =&gt; {\n      process.env.CONTEXT = &#x27;&#x27;;\n    });\n\n    it(&#x27;should be return commons exclude paths without context&#x27;, () =&gt; {\n      expect(corePathsExcludes()).not.toBe(null);\n      expect(corePathsExcludes()).toBeDefined();\n      expect(corePathsExcludes()).toBeInstanceOf(Array);\n\n      expect(corePathsExcludes()).toContainObject({\n        path: &#x27;/health/liveness&#x27;,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: &#x27;/health/readiness&#x27;,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: &#x27;/info&#x27;,\n        method: RequestMethod.GET,\n      });\n    });\n\n    it(&#x27;should be return array of exclude paths without context&#x27;, () =&gt; {\n      expect(excludePaths()).not.toBe(null);\n      expect(excludePaths()).toBeDefined();\n      expect(excludePaths()).toBeInstanceOf(Array);\n      expect(excludePaths()).toEqual([&#x27;/health/liveness&#x27;, &#x27;/health/readiness&#x27;, &#x27;/info&#x27;]);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;50ce86c0-93fd-4b5e-9e4f-b660e6e4fa59&quot;,&quot;parentUUID&quot;:&quot;fef2c576-2dad-42e2-94b3-6609a1a5ea47&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;commons &gt; without env context &gt; should be return commons exclude paths without context&quot;,&quot;title&quot;:&quot;commons &gt; without env context &gt; should be return commons exclude paths without context&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { corePathsExcludes, excludePaths } from &#x27;../index&#x27;;\nimport { RequestMethod } from &#x27;@nestjs/common&#x27;;\n\ndescribe(&#x27;commons&#x27;, () =&gt; {\n  describe(&#x27;with env context&#x27;, () =&gt; {\n    beforeEach(() =&gt; {\n      process.env.CONTEXT = &#x27;v1/api-test&#x27;;\n    });\n\n    it(&#x27;should be return commons exclude paths with context&#x27;, () =&gt; {\n      expect(corePathsExcludes()).not.toBe(null);\n      expect(corePathsExcludes()).toBeDefined();\n      expect(corePathsExcludes()).toBeInstanceOf(Array);\n\n      expect(corePathsExcludes()).toContainObject({\n        path: `/v1/api-test/health/liveness`,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: `/v1/api-test/health/readiness`,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: `/v1/api-test/info`,\n        method: RequestMethod.GET,\n      });\n    });\n\n    it(&#x27;should be return array of exclude paths with context&#x27;, () =&gt; {\n      expect(excludePaths()).not.toBe(null);\n      expect(excludePaths()).toBeDefined();\n      expect(excludePaths()).toBeInstanceOf(Array);\n      expect(excludePaths()).toEqual([\n        `/v1/api-test/health/liveness`,\n        `/v1/api-test/health/readiness`,\n        `/v1/api-test/info`,\n      ]);\n    });\n  });\n\n  describe(&#x27;without env context&#x27;, () =&gt; {\n    beforeEach(() =&gt; {\n      process.env.CONTEXT = &#x27;&#x27;;\n    });\n\n    it(&#x27;should be return commons exclude paths without context&#x27;, () =&gt; {\n      expect(corePathsExcludes()).not.toBe(null);\n      expect(corePathsExcludes()).toBeDefined();\n      expect(corePathsExcludes()).toBeInstanceOf(Array);\n\n      expect(corePathsExcludes()).toContainObject({\n        path: &#x27;/health/liveness&#x27;,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: &#x27;/health/readiness&#x27;,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: &#x27;/info&#x27;,\n        method: RequestMethod.GET,\n      });\n    });\n\n    it(&#x27;should be return array of exclude paths without context&#x27;, () =&gt; {\n      expect(excludePaths()).not.toBe(null);\n      expect(excludePaths()).toBeDefined();\n      expect(excludePaths()).toBeInstanceOf(Array);\n      expect(excludePaths()).toEqual([&#x27;/health/liveness&#x27;, &#x27;/health/readiness&#x27;, &#x27;/info&#x27;]);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ae75257c-1768-4b33-8cb2-834ff2d0edea&quot;,&quot;parentUUID&quot;:&quot;fef2c576-2dad-42e2-94b3-6609a1a5ea47&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;commons &gt; without env context &gt; should be return array of exclude paths without context&quot;,&quot;title&quot;:&quot;commons &gt; without env context &gt; should be return array of exclude paths without context&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { corePathsExcludes, excludePaths } from &#x27;../index&#x27;;\nimport { RequestMethod } from &#x27;@nestjs/common&#x27;;\n\ndescribe(&#x27;commons&#x27;, () =&gt; {\n  describe(&#x27;with env context&#x27;, () =&gt; {\n    beforeEach(() =&gt; {\n      process.env.CONTEXT = &#x27;v1/api-test&#x27;;\n    });\n\n    it(&#x27;should be return commons exclude paths with context&#x27;, () =&gt; {\n      expect(corePathsExcludes()).not.toBe(null);\n      expect(corePathsExcludes()).toBeDefined();\n      expect(corePathsExcludes()).toBeInstanceOf(Array);\n\n      expect(corePathsExcludes()).toContainObject({\n        path: `/v1/api-test/health/liveness`,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: `/v1/api-test/health/readiness`,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: `/v1/api-test/info`,\n        method: RequestMethod.GET,\n      });\n    });\n\n    it(&#x27;should be return array of exclude paths with context&#x27;, () =&gt; {\n      expect(excludePaths()).not.toBe(null);\n      expect(excludePaths()).toBeDefined();\n      expect(excludePaths()).toBeInstanceOf(Array);\n      expect(excludePaths()).toEqual([\n        `/v1/api-test/health/liveness`,\n        `/v1/api-test/health/readiness`,\n        `/v1/api-test/info`,\n      ]);\n    });\n  });\n\n  describe(&#x27;without env context&#x27;, () =&gt; {\n    beforeEach(() =&gt; {\n      process.env.CONTEXT = &#x27;&#x27;;\n    });\n\n    it(&#x27;should be return commons exclude paths without context&#x27;, () =&gt; {\n      expect(corePathsExcludes()).not.toBe(null);\n      expect(corePathsExcludes()).toBeDefined();\n      expect(corePathsExcludes()).toBeInstanceOf(Array);\n\n      expect(corePathsExcludes()).toContainObject({\n        path: &#x27;/health/liveness&#x27;,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: &#x27;/health/readiness&#x27;,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: &#x27;/info&#x27;,\n        method: RequestMethod.GET,\n      });\n    });\n\n    it(&#x27;should be return array of exclude paths without context&#x27;, () =&gt; {\n      expect(excludePaths()).not.toBe(null);\n      expect(excludePaths()).toBeDefined();\n      expect(excludePaths()).toBeInstanceOf(Array);\n      expect(excludePaths()).toEqual([&#x27;/health/liveness&#x27;, &#x27;/health/readiness&#x27;, &#x27;/info&#x27;]);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4abe6383-1f72-498a-8448-8a9190a1f0e7&quot;,&quot;parentUUID&quot;:&quot;fef2c576-2dad-42e2-94b3-6609a1a5ea47&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Public decorator &gt; should be defined&quot;,&quot;title&quot;:&quot;Public decorator &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Roles, ROLES_KEY } from &#x27;../index&#x27;;\n\ndescribe(&#x27;Public decorator&#x27;, () =&gt; {\n  it(&#x27;should be defined&#x27;, async () =&gt; {\n    expect(Roles(&#x27;admin&#x27;)).toBeDefined();\n    expect(Roles(&#x27;admin&#x27;, &#x27;user&#x27;)).toBeDefined();\n  });\n\n  it(&#x27;should be return key&#x27;, async () =&gt; {\n    expect(ROLES_KEY).toBe(&#x27;roles&#x27;);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7a0f4151-ecc7-4cf7-8b32-bd9b87eca063&quot;,&quot;parentUUID&quot;:&quot;fef2c576-2dad-42e2-94b3-6609a1a5ea47&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Public decorator &gt; should be return key&quot;,&quot;title&quot;:&quot;Public decorator &gt; should be return key&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Roles, ROLES_KEY } from &#x27;../index&#x27;;\n\ndescribe(&#x27;Public decorator&#x27;, () =&gt; {\n  it(&#x27;should be defined&#x27;, async () =&gt; {\n    expect(Roles(&#x27;admin&#x27;)).toBeDefined();\n    expect(Roles(&#x27;admin&#x27;, &#x27;user&#x27;)).toBeDefined();\n  });\n\n  it(&#x27;should be return key&#x27;, async () =&gt; {\n    expect(ROLES_KEY).toBe(&#x27;roles&#x27;);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4b90b66a-df5b-48b8-957e-58a6949bc4b8&quot;,&quot;parentUUID&quot;:&quot;fef2c576-2dad-42e2-94b3-6609a1a5ea47&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Public decorator &gt; should be defined&quot;,&quot;title&quot;:&quot;Public decorator &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Public, IS_PUBLIC_KEY } from &#x27;../index&#x27;;\n\ndescribe(&#x27;Public decorator&#x27;, () =&gt; {\n  it(&#x27;should be defined&#x27;, async () =&gt; {\n    expect(Public()).toBeDefined();\n  });\n\n  it(&#x27;should be return key&#x27;, async () =&gt; {\n    expect(IS_PUBLIC_KEY).toBe(&#x27;isPublic&#x27;);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ad1c44ad-7412-4267-b3c7-c15ff8f2cbc3&quot;,&quot;parentUUID&quot;:&quot;fef2c576-2dad-42e2-94b3-6609a1a5ea47&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Public decorator &gt; should be return key&quot;,&quot;title&quot;:&quot;Public decorator &gt; should be return key&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:0,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Public, IS_PUBLIC_KEY } from &#x27;../index&#x27;;\n\ndescribe(&#x27;Public decorator&#x27;, () =&gt; {\n  it(&#x27;should be defined&#x27;, async () =&gt; {\n    expect(Public()).toBeDefined();\n  });\n\n  it(&#x27;should be return key&#x27;, async () =&gt; {\n    expect(IS_PUBLIC_KEY).toBe(&#x27;isPublic&#x27;);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;949edea5-1ced-4839-891b-aeac31ae36b7&quot;,&quot;parentUUID&quot;:&quot;fef2c576-2dad-42e2-94b3-6609a1a5ea47&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;https-certificate &gt; should be return https certificate config&quot;,&quot;title&quot;:&quot;https-certificate &gt; should be return https certificate config&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { setHttpsOptions } from &#x27;../index&#x27;;\nimport * as path from &#x27;path&#x27;;\ndescribe(&#x27;https-certificate&#x27;, () =&gt; {\n  it(&#x27;should be return https certificate config&#x27;, () =&gt; {\n    const crtPath = path.resolve(__dirname, &#x27;./utils/localhost.crt&#x27;);\n    const keyPath = path.resolve(__dirname, &#x27;./utils/localhost.key&#x27;);\n\n    const config = setHttpsOptions(crtPath, keyPath);\n    expect(typeof config).toBe(&#x27;object&#x27;);\n    expect(config).toBeDefined();\n    expect(config.cert).not.toEqual(&#x27;&#x27;);\n    expect(config.key).not.toEqual(&#x27;&#x27;);\n  });\n\n  it(&#x27;should be return https certificate config empty&#x27;, () =&gt; {\n    const crtPath = path.resolve(__dirname, &#x27;./utils/my-localhost.crt&#x27;);\n    const keyPath = path.resolve(__dirname, &#x27;./utils/my-localhost.key&#x27;);\n\n    const config = setHttpsOptions(crtPath, keyPath);\n    expect(typeof config).toBe(&#x27;object&#x27;);\n    expect(config).toBeDefined();\n    expect(config.cert).toEqual(&#x27;&#x27;);\n    expect(config.key).toEqual(&#x27;&#x27;);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9e7033d8-59fe-40fb-98eb-44b076262584&quot;,&quot;parentUUID&quot;:&quot;fef2c576-2dad-42e2-94b3-6609a1a5ea47&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;https-certificate &gt; should be return https certificate config empty&quot;,&quot;title&quot;:&quot;https-certificate &gt; should be return https certificate config empty&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { setHttpsOptions } from &#x27;../index&#x27;;\nimport * as path from &#x27;path&#x27;;\ndescribe(&#x27;https-certificate&#x27;, () =&gt; {\n  it(&#x27;should be return https certificate config&#x27;, () =&gt; {\n    const crtPath = path.resolve(__dirname, &#x27;./utils/localhost.crt&#x27;);\n    const keyPath = path.resolve(__dirname, &#x27;./utils/localhost.key&#x27;);\n\n    const config = setHttpsOptions(crtPath, keyPath);\n    expect(typeof config).toBe(&#x27;object&#x27;);\n    expect(config).toBeDefined();\n    expect(config.cert).not.toEqual(&#x27;&#x27;);\n    expect(config.key).not.toEqual(&#x27;&#x27;);\n  });\n\n  it(&#x27;should be return https certificate config empty&#x27;, () =&gt; {\n    const crtPath = path.resolve(__dirname, &#x27;./utils/my-localhost.crt&#x27;);\n    const keyPath = path.resolve(__dirname, &#x27;./utils/my-localhost.key&#x27;);\n\n    const config = setHttpsOptions(crtPath, keyPath);\n    expect(typeof config).toBe(&#x27;object&#x27;);\n    expect(config).toBeDefined();\n    expect(config.cert).toEqual(&#x27;&#x27;);\n    expect(config.key).toEqual(&#x27;&#x27;);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;bbb4123e-e315-4e2f-b1e2-1694c5440f11&quot;,&quot;parentUUID&quot;:&quot;fef2c576-2dad-42e2-94b3-6609a1a5ea47&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;6daa302e-8e35-4483-8363-a6a8a03eeab2&quot;,&quot;50ce86c0-93fd-4b5e-9e4f-b660e6e4fa59&quot;,&quot;ae75257c-1768-4b33-8cb2-834ff2d0edea&quot;,&quot;4abe6383-1f72-498a-8448-8a9190a1f0e7&quot;,&quot;7a0f4151-ecc7-4cf7-8b32-bd9b87eca063&quot;,&quot;4b90b66a-df5b-48b8-957e-58a6949bc4b8&quot;,&quot;ad1c44ad-7412-4267-b3c7-c15ff8f2cbc3&quot;,&quot;949edea5-1ced-4839-891b-aeac31ae36b7&quot;,&quot;9e7033d8-59fe-40fb-98eb-44b076262584&quot;,&quot;bbb4123e-e315-4e2f-b1e2-1694c5440f11&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:16,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:5000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:5000},{&quot;uuid&quot;:&quot;6825bf87-3a9b-40e7-a2c5-d7c55a170c94&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/elk&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;75f69b88-729b-4c0f-b415-5d527cb20391&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/elk&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;fullTitle&quot;:&quot;ElkModule &gt; should be defined&quot;,&quot;title&quot;:&quot;ElkModule &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1353,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { HttpException, INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport {\n  dynamicConfig,\n  fixtureUserResponse,\n  TCElasticSearchOptions,\n  tcName,\n  testContainers,\n} from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { Observable, of, throwError } from &#x27;rxjs&#x27;;\nimport { HttpConnection } from &#x27;@elastic/elasticsearch&#x27;;\nimport { URL } from &#x27;url&#x27;;\n\nimport { ElkModule } from &#x27;../elk/elk.module&#x27;;\nimport { ElkInterceptor } from &#x27;../elk/interceptors/elk.interceptor&#x27;;\nimport { ElkService } from &#x27;../elk/services/elk.service&#x27;;\n\nlet executionContext: any = {\n  switchToHttp: jest.fn(() =&gt; ({\n    getRequest: () =&gt; ({\n      path: &#x27;/test&#x27;,\n      method: &#x27;GET&#x27;,\n      params: {},\n      query: {},\n      body: {},\n      headers: {\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        apiKey: &#x27;abcdefg12345&#x27;,\n      },\n    }),\n    getResponse: () =&gt; ({\n      getHeaders: jest.fn().mockReturnValue({\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        my_header: &#x27;test-header&#x27;,\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() =&gt; &#x27;http&#x27;),\n  getClass: jest.fn(() =&gt; &#x27;testController&#x27;),\n  getHandler: jest.fn(() =&gt; &#x27;handlerElk&#x27;),\n};\n\nlet executionContextParams: any = {\n  switchToHttp: jest.fn(() =&gt; ({\n    getRequest: () =&gt; ({\n      path: &#x27;/test&#x27;,\n      method: &#x27;GET&#x27;,\n      params: { name: &#x27;juan&#x27; },\n      query: { name: &#x27;juan&#x27; },\n      body: { name: &#x27;juan&#x27; },\n      headers: {\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        apiKey: &#x27;abcdefg12345&#x27;,\n      },\n    }),\n    getResponse: () =&gt; ({\n      getHeaders: jest.fn().mockReturnValue({\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        my_header: &#x27;test-header&#x27;,\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() =&gt; &#x27;http&#x27;),\n  getClass: jest.fn(() =&gt; &#x27;testController&#x27;),\n  getHandler: jest.fn(() =&gt; &#x27;handlerElk&#x27;),\n};\n\n/*const callHandler: any = {\n  handle: jest.fn(() =&gt; ({\n    pipe: jest.fn(() =&gt; ({\n      tap: jest.fn(() =&gt; ({\n        next: jest.fn(),\n        error: jest.fn(),\n      })),\n    })),\n  })),\n};*/\n\njest.setTimeout(70000);\ndescribe(&#x27;ElkModule&#x27;, () =&gt; {\n  let app: INestApplication;\n  let elkService: ElkService;\n  let interceptor: ElkInterceptor&lt;any&gt;;\n  let container: testContainers;\n\n  beforeAll(async () =&gt; {\n    //&#x27;elasticsearch:8.3.3&#x27;\n    //docker.elastic.co/elasticsearch/elasticsearch:8.3.3\n\n    container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n      ...TCElasticSearchOptions,\n      containerName: `${tcName}-elasticsearch-interceptor`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              elasticsearch: {\n                name: &#x27;test-elk-index&#x27;,\n                node: {\n                  url: new URL(`http://${container.getHost()}:9200`),\n                },\n                maxRetries: 10,\n                requestTimeout: 60000,\n                sniffOnStart: true,\n                Connection: HttpConnection,\n              },\n            }),\n          ],\n        }),\n        ElkModule,\n      ],\n    }).compile();\n    app = moduleFixture.createNestApplication();\n    interceptor = new ElkInterceptor(app.get&lt;ElkService&gt;(ElkService));\n    app.useGlobalInterceptors(interceptor);\n    elkService = moduleFixture.get&lt;ElkService&gt;(ElkService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(app).toBeDefined();\n  });\n\n  describe(&#x27;ElkInterceptor&#x27;, () =&gt; {\n    it(&#x27;should be an ElkInterceptor instance to be defined&#x27;, async () =&gt; {\n      expect(new ElkInterceptor(elkService)).toBeDefined();\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success string&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of(&#x27;this is a test&#x27;)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success object&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of([fixtureUserResponse])),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success with parameters&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of([fixtureUserResponse])),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContextParams, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return exception&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const error = new Error(`User #$1 not found`);\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; throwError(error)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () =&gt; {},\n        error: (error) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return exception http&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const error = new HttpException(&#x27;not found&#x27;, 404);\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; throwError(error)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () =&gt; {},\n        error: (error) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n  });\n\n  describe(&#x27;ElkModule - Register&#x27;, () =&gt; {\n    let app: INestApplication;\n    let elkService: ElkService;\n    let interceptor: ElkInterceptor&lt;any&gt;;\n\n    beforeEach(async () =&gt; {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ElkModule.register({\n            name: &#x27;test-elk-index&#x27;,\n            node: {\n              url: new URL(`http://${container.getHost()}:9200`),\n            },\n            maxRetries: 10,\n            requestTimeout: 60000,\n            sniffOnStart: true,\n            Connection: HttpConnection,\n          }),\n        ],\n      }).compile();\n      app = moduleFixture.createNestApplication();\n      interceptor = new ElkInterceptor(app.get&lt;ElkService&gt;(ElkService));\n      app.useGlobalInterceptors(interceptor);\n      elkService = moduleFixture.get&lt;ElkService&gt;(ElkService);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;8dc6dac1-0415-48e0-b158-3f2293573a9a&quot;,&quot;parentUUID&quot;:&quot;75f69b88-729b-4c0f-b415-5d527cb20391&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;ElkModule &gt; ElkInterceptor &gt; should be an ElkInterceptor instance to be defined&quot;,&quot;title&quot;:&quot;ElkModule &gt; ElkInterceptor &gt; should be an ElkInterceptor instance to be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1009,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { HttpException, INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport {\n  dynamicConfig,\n  fixtureUserResponse,\n  TCElasticSearchOptions,\n  tcName,\n  testContainers,\n} from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { Observable, of, throwError } from &#x27;rxjs&#x27;;\nimport { HttpConnection } from &#x27;@elastic/elasticsearch&#x27;;\nimport { URL } from &#x27;url&#x27;;\n\nimport { ElkModule } from &#x27;../elk/elk.module&#x27;;\nimport { ElkInterceptor } from &#x27;../elk/interceptors/elk.interceptor&#x27;;\nimport { ElkService } from &#x27;../elk/services/elk.service&#x27;;\n\nlet executionContext: any = {\n  switchToHttp: jest.fn(() =&gt; ({\n    getRequest: () =&gt; ({\n      path: &#x27;/test&#x27;,\n      method: &#x27;GET&#x27;,\n      params: {},\n      query: {},\n      body: {},\n      headers: {\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        apiKey: &#x27;abcdefg12345&#x27;,\n      },\n    }),\n    getResponse: () =&gt; ({\n      getHeaders: jest.fn().mockReturnValue({\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        my_header: &#x27;test-header&#x27;,\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() =&gt; &#x27;http&#x27;),\n  getClass: jest.fn(() =&gt; &#x27;testController&#x27;),\n  getHandler: jest.fn(() =&gt; &#x27;handlerElk&#x27;),\n};\n\nlet executionContextParams: any = {\n  switchToHttp: jest.fn(() =&gt; ({\n    getRequest: () =&gt; ({\n      path: &#x27;/test&#x27;,\n      method: &#x27;GET&#x27;,\n      params: { name: &#x27;juan&#x27; },\n      query: { name: &#x27;juan&#x27; },\n      body: { name: &#x27;juan&#x27; },\n      headers: {\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        apiKey: &#x27;abcdefg12345&#x27;,\n      },\n    }),\n    getResponse: () =&gt; ({\n      getHeaders: jest.fn().mockReturnValue({\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        my_header: &#x27;test-header&#x27;,\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() =&gt; &#x27;http&#x27;),\n  getClass: jest.fn(() =&gt; &#x27;testController&#x27;),\n  getHandler: jest.fn(() =&gt; &#x27;handlerElk&#x27;),\n};\n\n/*const callHandler: any = {\n  handle: jest.fn(() =&gt; ({\n    pipe: jest.fn(() =&gt; ({\n      tap: jest.fn(() =&gt; ({\n        next: jest.fn(),\n        error: jest.fn(),\n      })),\n    })),\n  })),\n};*/\n\njest.setTimeout(70000);\ndescribe(&#x27;ElkModule&#x27;, () =&gt; {\n  let app: INestApplication;\n  let elkService: ElkService;\n  let interceptor: ElkInterceptor&lt;any&gt;;\n  let container: testContainers;\n\n  beforeAll(async () =&gt; {\n    //&#x27;elasticsearch:8.3.3&#x27;\n    //docker.elastic.co/elasticsearch/elasticsearch:8.3.3\n\n    container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n      ...TCElasticSearchOptions,\n      containerName: `${tcName}-elasticsearch-interceptor`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              elasticsearch: {\n                name: &#x27;test-elk-index&#x27;,\n                node: {\n                  url: new URL(`http://${container.getHost()}:9200`),\n                },\n                maxRetries: 10,\n                requestTimeout: 60000,\n                sniffOnStart: true,\n                Connection: HttpConnection,\n              },\n            }),\n          ],\n        }),\n        ElkModule,\n      ],\n    }).compile();\n    app = moduleFixture.createNestApplication();\n    interceptor = new ElkInterceptor(app.get&lt;ElkService&gt;(ElkService));\n    app.useGlobalInterceptors(interceptor);\n    elkService = moduleFixture.get&lt;ElkService&gt;(ElkService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(app).toBeDefined();\n  });\n\n  describe(&#x27;ElkInterceptor&#x27;, () =&gt; {\n    it(&#x27;should be an ElkInterceptor instance to be defined&#x27;, async () =&gt; {\n      expect(new ElkInterceptor(elkService)).toBeDefined();\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success string&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of(&#x27;this is a test&#x27;)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success object&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of([fixtureUserResponse])),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success with parameters&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of([fixtureUserResponse])),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContextParams, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return exception&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const error = new Error(`User #$1 not found`);\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; throwError(error)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () =&gt; {},\n        error: (error) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return exception http&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const error = new HttpException(&#x27;not found&#x27;, 404);\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; throwError(error)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () =&gt; {},\n        error: (error) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n  });\n\n  describe(&#x27;ElkModule - Register&#x27;, () =&gt; {\n    let app: INestApplication;\n    let elkService: ElkService;\n    let interceptor: ElkInterceptor&lt;any&gt;;\n\n    beforeEach(async () =&gt; {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ElkModule.register({\n            name: &#x27;test-elk-index&#x27;,\n            node: {\n              url: new URL(`http://${container.getHost()}:9200`),\n            },\n            maxRetries: 10,\n            requestTimeout: 60000,\n            sniffOnStart: true,\n            Connection: HttpConnection,\n          }),\n        ],\n      }).compile();\n      app = moduleFixture.createNestApplication();\n      interceptor = new ElkInterceptor(app.get&lt;ElkService&gt;(ElkService));\n      app.useGlobalInterceptors(interceptor);\n      elkService = moduleFixture.get&lt;ElkService&gt;(ElkService);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;35994cbb-1ced-492b-acec-73db2b57cc1b&quot;,&quot;parentUUID&quot;:&quot;75f69b88-729b-4c0f-b415-5d527cb20391&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;ElkModule &gt; ElkInterceptor &gt; should be create document in elasticsearch when return success string&quot;,&quot;title&quot;:&quot;ElkModule &gt; ElkInterceptor &gt; should be create document in elasticsearch when return success string&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1018,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { HttpException, INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport {\n  dynamicConfig,\n  fixtureUserResponse,\n  TCElasticSearchOptions,\n  tcName,\n  testContainers,\n} from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { Observable, of, throwError } from &#x27;rxjs&#x27;;\nimport { HttpConnection } from &#x27;@elastic/elasticsearch&#x27;;\nimport { URL } from &#x27;url&#x27;;\n\nimport { ElkModule } from &#x27;../elk/elk.module&#x27;;\nimport { ElkInterceptor } from &#x27;../elk/interceptors/elk.interceptor&#x27;;\nimport { ElkService } from &#x27;../elk/services/elk.service&#x27;;\n\nlet executionContext: any = {\n  switchToHttp: jest.fn(() =&gt; ({\n    getRequest: () =&gt; ({\n      path: &#x27;/test&#x27;,\n      method: &#x27;GET&#x27;,\n      params: {},\n      query: {},\n      body: {},\n      headers: {\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        apiKey: &#x27;abcdefg12345&#x27;,\n      },\n    }),\n    getResponse: () =&gt; ({\n      getHeaders: jest.fn().mockReturnValue({\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        my_header: &#x27;test-header&#x27;,\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() =&gt; &#x27;http&#x27;),\n  getClass: jest.fn(() =&gt; &#x27;testController&#x27;),\n  getHandler: jest.fn(() =&gt; &#x27;handlerElk&#x27;),\n};\n\nlet executionContextParams: any = {\n  switchToHttp: jest.fn(() =&gt; ({\n    getRequest: () =&gt; ({\n      path: &#x27;/test&#x27;,\n      method: &#x27;GET&#x27;,\n      params: { name: &#x27;juan&#x27; },\n      query: { name: &#x27;juan&#x27; },\n      body: { name: &#x27;juan&#x27; },\n      headers: {\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        apiKey: &#x27;abcdefg12345&#x27;,\n      },\n    }),\n    getResponse: () =&gt; ({\n      getHeaders: jest.fn().mockReturnValue({\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        my_header: &#x27;test-header&#x27;,\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() =&gt; &#x27;http&#x27;),\n  getClass: jest.fn(() =&gt; &#x27;testController&#x27;),\n  getHandler: jest.fn(() =&gt; &#x27;handlerElk&#x27;),\n};\n\n/*const callHandler: any = {\n  handle: jest.fn(() =&gt; ({\n    pipe: jest.fn(() =&gt; ({\n      tap: jest.fn(() =&gt; ({\n        next: jest.fn(),\n        error: jest.fn(),\n      })),\n    })),\n  })),\n};*/\n\njest.setTimeout(70000);\ndescribe(&#x27;ElkModule&#x27;, () =&gt; {\n  let app: INestApplication;\n  let elkService: ElkService;\n  let interceptor: ElkInterceptor&lt;any&gt;;\n  let container: testContainers;\n\n  beforeAll(async () =&gt; {\n    //&#x27;elasticsearch:8.3.3&#x27;\n    //docker.elastic.co/elasticsearch/elasticsearch:8.3.3\n\n    container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n      ...TCElasticSearchOptions,\n      containerName: `${tcName}-elasticsearch-interceptor`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              elasticsearch: {\n                name: &#x27;test-elk-index&#x27;,\n                node: {\n                  url: new URL(`http://${container.getHost()}:9200`),\n                },\n                maxRetries: 10,\n                requestTimeout: 60000,\n                sniffOnStart: true,\n                Connection: HttpConnection,\n              },\n            }),\n          ],\n        }),\n        ElkModule,\n      ],\n    }).compile();\n    app = moduleFixture.createNestApplication();\n    interceptor = new ElkInterceptor(app.get&lt;ElkService&gt;(ElkService));\n    app.useGlobalInterceptors(interceptor);\n    elkService = moduleFixture.get&lt;ElkService&gt;(ElkService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(app).toBeDefined();\n  });\n\n  describe(&#x27;ElkInterceptor&#x27;, () =&gt; {\n    it(&#x27;should be an ElkInterceptor instance to be defined&#x27;, async () =&gt; {\n      expect(new ElkInterceptor(elkService)).toBeDefined();\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success string&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of(&#x27;this is a test&#x27;)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success object&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of([fixtureUserResponse])),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success with parameters&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of([fixtureUserResponse])),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContextParams, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return exception&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const error = new Error(`User #$1 not found`);\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; throwError(error)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () =&gt; {},\n        error: (error) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return exception http&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const error = new HttpException(&#x27;not found&#x27;, 404);\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; throwError(error)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () =&gt; {},\n        error: (error) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n  });\n\n  describe(&#x27;ElkModule - Register&#x27;, () =&gt; {\n    let app: INestApplication;\n    let elkService: ElkService;\n    let interceptor: ElkInterceptor&lt;any&gt;;\n\n    beforeEach(async () =&gt; {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ElkModule.register({\n            name: &#x27;test-elk-index&#x27;,\n            node: {\n              url: new URL(`http://${container.getHost()}:9200`),\n            },\n            maxRetries: 10,\n            requestTimeout: 60000,\n            sniffOnStart: true,\n            Connection: HttpConnection,\n          }),\n        ],\n      }).compile();\n      app = moduleFixture.createNestApplication();\n      interceptor = new ElkInterceptor(app.get&lt;ElkService&gt;(ElkService));\n      app.useGlobalInterceptors(interceptor);\n      elkService = moduleFixture.get&lt;ElkService&gt;(ElkService);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c681ce2b-0d0b-492f-9b1c-f8c18c89a411&quot;,&quot;parentUUID&quot;:&quot;75f69b88-729b-4c0f-b415-5d527cb20391&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;ElkModule &gt; ElkInterceptor &gt; should be create document in elasticsearch when return success object&quot;,&quot;title&quot;:&quot;ElkModule &gt; ElkInterceptor &gt; should be create document in elasticsearch when return success object&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1011,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { HttpException, INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport {\n  dynamicConfig,\n  fixtureUserResponse,\n  TCElasticSearchOptions,\n  tcName,\n  testContainers,\n} from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { Observable, of, throwError } from &#x27;rxjs&#x27;;\nimport { HttpConnection } from &#x27;@elastic/elasticsearch&#x27;;\nimport { URL } from &#x27;url&#x27;;\n\nimport { ElkModule } from &#x27;../elk/elk.module&#x27;;\nimport { ElkInterceptor } from &#x27;../elk/interceptors/elk.interceptor&#x27;;\nimport { ElkService } from &#x27;../elk/services/elk.service&#x27;;\n\nlet executionContext: any = {\n  switchToHttp: jest.fn(() =&gt; ({\n    getRequest: () =&gt; ({\n      path: &#x27;/test&#x27;,\n      method: &#x27;GET&#x27;,\n      params: {},\n      query: {},\n      body: {},\n      headers: {\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        apiKey: &#x27;abcdefg12345&#x27;,\n      },\n    }),\n    getResponse: () =&gt; ({\n      getHeaders: jest.fn().mockReturnValue({\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        my_header: &#x27;test-header&#x27;,\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() =&gt; &#x27;http&#x27;),\n  getClass: jest.fn(() =&gt; &#x27;testController&#x27;),\n  getHandler: jest.fn(() =&gt; &#x27;handlerElk&#x27;),\n};\n\nlet executionContextParams: any = {\n  switchToHttp: jest.fn(() =&gt; ({\n    getRequest: () =&gt; ({\n      path: &#x27;/test&#x27;,\n      method: &#x27;GET&#x27;,\n      params: { name: &#x27;juan&#x27; },\n      query: { name: &#x27;juan&#x27; },\n      body: { name: &#x27;juan&#x27; },\n      headers: {\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        apiKey: &#x27;abcdefg12345&#x27;,\n      },\n    }),\n    getResponse: () =&gt; ({\n      getHeaders: jest.fn().mockReturnValue({\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        my_header: &#x27;test-header&#x27;,\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() =&gt; &#x27;http&#x27;),\n  getClass: jest.fn(() =&gt; &#x27;testController&#x27;),\n  getHandler: jest.fn(() =&gt; &#x27;handlerElk&#x27;),\n};\n\n/*const callHandler: any = {\n  handle: jest.fn(() =&gt; ({\n    pipe: jest.fn(() =&gt; ({\n      tap: jest.fn(() =&gt; ({\n        next: jest.fn(),\n        error: jest.fn(),\n      })),\n    })),\n  })),\n};*/\n\njest.setTimeout(70000);\ndescribe(&#x27;ElkModule&#x27;, () =&gt; {\n  let app: INestApplication;\n  let elkService: ElkService;\n  let interceptor: ElkInterceptor&lt;any&gt;;\n  let container: testContainers;\n\n  beforeAll(async () =&gt; {\n    //&#x27;elasticsearch:8.3.3&#x27;\n    //docker.elastic.co/elasticsearch/elasticsearch:8.3.3\n\n    container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n      ...TCElasticSearchOptions,\n      containerName: `${tcName}-elasticsearch-interceptor`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              elasticsearch: {\n                name: &#x27;test-elk-index&#x27;,\n                node: {\n                  url: new URL(`http://${container.getHost()}:9200`),\n                },\n                maxRetries: 10,\n                requestTimeout: 60000,\n                sniffOnStart: true,\n                Connection: HttpConnection,\n              },\n            }),\n          ],\n        }),\n        ElkModule,\n      ],\n    }).compile();\n    app = moduleFixture.createNestApplication();\n    interceptor = new ElkInterceptor(app.get&lt;ElkService&gt;(ElkService));\n    app.useGlobalInterceptors(interceptor);\n    elkService = moduleFixture.get&lt;ElkService&gt;(ElkService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(app).toBeDefined();\n  });\n\n  describe(&#x27;ElkInterceptor&#x27;, () =&gt; {\n    it(&#x27;should be an ElkInterceptor instance to be defined&#x27;, async () =&gt; {\n      expect(new ElkInterceptor(elkService)).toBeDefined();\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success string&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of(&#x27;this is a test&#x27;)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success object&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of([fixtureUserResponse])),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success with parameters&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of([fixtureUserResponse])),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContextParams, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return exception&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const error = new Error(`User #$1 not found`);\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; throwError(error)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () =&gt; {},\n        error: (error) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return exception http&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const error = new HttpException(&#x27;not found&#x27;, 404);\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; throwError(error)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () =&gt; {},\n        error: (error) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n  });\n\n  describe(&#x27;ElkModule - Register&#x27;, () =&gt; {\n    let app: INestApplication;\n    let elkService: ElkService;\n    let interceptor: ElkInterceptor&lt;any&gt;;\n\n    beforeEach(async () =&gt; {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ElkModule.register({\n            name: &#x27;test-elk-index&#x27;,\n            node: {\n              url: new URL(`http://${container.getHost()}:9200`),\n            },\n            maxRetries: 10,\n            requestTimeout: 60000,\n            sniffOnStart: true,\n            Connection: HttpConnection,\n          }),\n        ],\n      }).compile();\n      app = moduleFixture.createNestApplication();\n      interceptor = new ElkInterceptor(app.get&lt;ElkService&gt;(ElkService));\n      app.useGlobalInterceptors(interceptor);\n      elkService = moduleFixture.get&lt;ElkService&gt;(ElkService);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;491352ef-7f86-49af-b237-627f3b1dea8c&quot;,&quot;parentUUID&quot;:&quot;75f69b88-729b-4c0f-b415-5d527cb20391&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;ElkModule &gt; ElkInterceptor &gt; should be create document in elasticsearch when return success with parameters&quot;,&quot;title&quot;:&quot;ElkModule &gt; ElkInterceptor &gt; should be create document in elasticsearch when return success with parameters&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1010,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { HttpException, INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport {\n  dynamicConfig,\n  fixtureUserResponse,\n  TCElasticSearchOptions,\n  tcName,\n  testContainers,\n} from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { Observable, of, throwError } from &#x27;rxjs&#x27;;\nimport { HttpConnection } from &#x27;@elastic/elasticsearch&#x27;;\nimport { URL } from &#x27;url&#x27;;\n\nimport { ElkModule } from &#x27;../elk/elk.module&#x27;;\nimport { ElkInterceptor } from &#x27;../elk/interceptors/elk.interceptor&#x27;;\nimport { ElkService } from &#x27;../elk/services/elk.service&#x27;;\n\nlet executionContext: any = {\n  switchToHttp: jest.fn(() =&gt; ({\n    getRequest: () =&gt; ({\n      path: &#x27;/test&#x27;,\n      method: &#x27;GET&#x27;,\n      params: {},\n      query: {},\n      body: {},\n      headers: {\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        apiKey: &#x27;abcdefg12345&#x27;,\n      },\n    }),\n    getResponse: () =&gt; ({\n      getHeaders: jest.fn().mockReturnValue({\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        my_header: &#x27;test-header&#x27;,\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() =&gt; &#x27;http&#x27;),\n  getClass: jest.fn(() =&gt; &#x27;testController&#x27;),\n  getHandler: jest.fn(() =&gt; &#x27;handlerElk&#x27;),\n};\n\nlet executionContextParams: any = {\n  switchToHttp: jest.fn(() =&gt; ({\n    getRequest: () =&gt; ({\n      path: &#x27;/test&#x27;,\n      method: &#x27;GET&#x27;,\n      params: { name: &#x27;juan&#x27; },\n      query: { name: &#x27;juan&#x27; },\n      body: { name: &#x27;juan&#x27; },\n      headers: {\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        apiKey: &#x27;abcdefg12345&#x27;,\n      },\n    }),\n    getResponse: () =&gt; ({\n      getHeaders: jest.fn().mockReturnValue({\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        my_header: &#x27;test-header&#x27;,\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() =&gt; &#x27;http&#x27;),\n  getClass: jest.fn(() =&gt; &#x27;testController&#x27;),\n  getHandler: jest.fn(() =&gt; &#x27;handlerElk&#x27;),\n};\n\n/*const callHandler: any = {\n  handle: jest.fn(() =&gt; ({\n    pipe: jest.fn(() =&gt; ({\n      tap: jest.fn(() =&gt; ({\n        next: jest.fn(),\n        error: jest.fn(),\n      })),\n    })),\n  })),\n};*/\n\njest.setTimeout(70000);\ndescribe(&#x27;ElkModule&#x27;, () =&gt; {\n  let app: INestApplication;\n  let elkService: ElkService;\n  let interceptor: ElkInterceptor&lt;any&gt;;\n  let container: testContainers;\n\n  beforeAll(async () =&gt; {\n    //&#x27;elasticsearch:8.3.3&#x27;\n    //docker.elastic.co/elasticsearch/elasticsearch:8.3.3\n\n    container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n      ...TCElasticSearchOptions,\n      containerName: `${tcName}-elasticsearch-interceptor`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              elasticsearch: {\n                name: &#x27;test-elk-index&#x27;,\n                node: {\n                  url: new URL(`http://${container.getHost()}:9200`),\n                },\n                maxRetries: 10,\n                requestTimeout: 60000,\n                sniffOnStart: true,\n                Connection: HttpConnection,\n              },\n            }),\n          ],\n        }),\n        ElkModule,\n      ],\n    }).compile();\n    app = moduleFixture.createNestApplication();\n    interceptor = new ElkInterceptor(app.get&lt;ElkService&gt;(ElkService));\n    app.useGlobalInterceptors(interceptor);\n    elkService = moduleFixture.get&lt;ElkService&gt;(ElkService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(app).toBeDefined();\n  });\n\n  describe(&#x27;ElkInterceptor&#x27;, () =&gt; {\n    it(&#x27;should be an ElkInterceptor instance to be defined&#x27;, async () =&gt; {\n      expect(new ElkInterceptor(elkService)).toBeDefined();\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success string&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of(&#x27;this is a test&#x27;)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success object&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of([fixtureUserResponse])),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success with parameters&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of([fixtureUserResponse])),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContextParams, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return exception&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const error = new Error(`User #$1 not found`);\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; throwError(error)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () =&gt; {},\n        error: (error) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return exception http&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const error = new HttpException(&#x27;not found&#x27;, 404);\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; throwError(error)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () =&gt; {},\n        error: (error) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n  });\n\n  describe(&#x27;ElkModule - Register&#x27;, () =&gt; {\n    let app: INestApplication;\n    let elkService: ElkService;\n    let interceptor: ElkInterceptor&lt;any&gt;;\n\n    beforeEach(async () =&gt; {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ElkModule.register({\n            name: &#x27;test-elk-index&#x27;,\n            node: {\n              url: new URL(`http://${container.getHost()}:9200`),\n            },\n            maxRetries: 10,\n            requestTimeout: 60000,\n            sniffOnStart: true,\n            Connection: HttpConnection,\n          }),\n        ],\n      }).compile();\n      app = moduleFixture.createNestApplication();\n      interceptor = new ElkInterceptor(app.get&lt;ElkService&gt;(ElkService));\n      app.useGlobalInterceptors(interceptor);\n      elkService = moduleFixture.get&lt;ElkService&gt;(ElkService);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6797888f-7622-40e8-9f07-046b874f810b&quot;,&quot;parentUUID&quot;:&quot;75f69b88-729b-4c0f-b415-5d527cb20391&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;ElkModule &gt; ElkInterceptor &gt; should be create document in elasticsearch when return exception&quot;,&quot;title&quot;:&quot;ElkModule &gt; ElkInterceptor &gt; should be create document in elasticsearch when return exception&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1010,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { HttpException, INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport {\n  dynamicConfig,\n  fixtureUserResponse,\n  TCElasticSearchOptions,\n  tcName,\n  testContainers,\n} from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { Observable, of, throwError } from &#x27;rxjs&#x27;;\nimport { HttpConnection } from &#x27;@elastic/elasticsearch&#x27;;\nimport { URL } from &#x27;url&#x27;;\n\nimport { ElkModule } from &#x27;../elk/elk.module&#x27;;\nimport { ElkInterceptor } from &#x27;../elk/interceptors/elk.interceptor&#x27;;\nimport { ElkService } from &#x27;../elk/services/elk.service&#x27;;\n\nlet executionContext: any = {\n  switchToHttp: jest.fn(() =&gt; ({\n    getRequest: () =&gt; ({\n      path: &#x27;/test&#x27;,\n      method: &#x27;GET&#x27;,\n      params: {},\n      query: {},\n      body: {},\n      headers: {\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        apiKey: &#x27;abcdefg12345&#x27;,\n      },\n    }),\n    getResponse: () =&gt; ({\n      getHeaders: jest.fn().mockReturnValue({\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        my_header: &#x27;test-header&#x27;,\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() =&gt; &#x27;http&#x27;),\n  getClass: jest.fn(() =&gt; &#x27;testController&#x27;),\n  getHandler: jest.fn(() =&gt; &#x27;handlerElk&#x27;),\n};\n\nlet executionContextParams: any = {\n  switchToHttp: jest.fn(() =&gt; ({\n    getRequest: () =&gt; ({\n      path: &#x27;/test&#x27;,\n      method: &#x27;GET&#x27;,\n      params: { name: &#x27;juan&#x27; },\n      query: { name: &#x27;juan&#x27; },\n      body: { name: &#x27;juan&#x27; },\n      headers: {\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        apiKey: &#x27;abcdefg12345&#x27;,\n      },\n    }),\n    getResponse: () =&gt; ({\n      getHeaders: jest.fn().mockReturnValue({\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        my_header: &#x27;test-header&#x27;,\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() =&gt; &#x27;http&#x27;),\n  getClass: jest.fn(() =&gt; &#x27;testController&#x27;),\n  getHandler: jest.fn(() =&gt; &#x27;handlerElk&#x27;),\n};\n\n/*const callHandler: any = {\n  handle: jest.fn(() =&gt; ({\n    pipe: jest.fn(() =&gt; ({\n      tap: jest.fn(() =&gt; ({\n        next: jest.fn(),\n        error: jest.fn(),\n      })),\n    })),\n  })),\n};*/\n\njest.setTimeout(70000);\ndescribe(&#x27;ElkModule&#x27;, () =&gt; {\n  let app: INestApplication;\n  let elkService: ElkService;\n  let interceptor: ElkInterceptor&lt;any&gt;;\n  let container: testContainers;\n\n  beforeAll(async () =&gt; {\n    //&#x27;elasticsearch:8.3.3&#x27;\n    //docker.elastic.co/elasticsearch/elasticsearch:8.3.3\n\n    container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n      ...TCElasticSearchOptions,\n      containerName: `${tcName}-elasticsearch-interceptor`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              elasticsearch: {\n                name: &#x27;test-elk-index&#x27;,\n                node: {\n                  url: new URL(`http://${container.getHost()}:9200`),\n                },\n                maxRetries: 10,\n                requestTimeout: 60000,\n                sniffOnStart: true,\n                Connection: HttpConnection,\n              },\n            }),\n          ],\n        }),\n        ElkModule,\n      ],\n    }).compile();\n    app = moduleFixture.createNestApplication();\n    interceptor = new ElkInterceptor(app.get&lt;ElkService&gt;(ElkService));\n    app.useGlobalInterceptors(interceptor);\n    elkService = moduleFixture.get&lt;ElkService&gt;(ElkService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(app).toBeDefined();\n  });\n\n  describe(&#x27;ElkInterceptor&#x27;, () =&gt; {\n    it(&#x27;should be an ElkInterceptor instance to be defined&#x27;, async () =&gt; {\n      expect(new ElkInterceptor(elkService)).toBeDefined();\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success string&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of(&#x27;this is a test&#x27;)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success object&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of([fixtureUserResponse])),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success with parameters&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of([fixtureUserResponse])),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContextParams, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return exception&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const error = new Error(`User #$1 not found`);\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; throwError(error)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () =&gt; {},\n        error: (error) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return exception http&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const error = new HttpException(&#x27;not found&#x27;, 404);\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; throwError(error)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () =&gt; {},\n        error: (error) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n  });\n\n  describe(&#x27;ElkModule - Register&#x27;, () =&gt; {\n    let app: INestApplication;\n    let elkService: ElkService;\n    let interceptor: ElkInterceptor&lt;any&gt;;\n\n    beforeEach(async () =&gt; {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ElkModule.register({\n            name: &#x27;test-elk-index&#x27;,\n            node: {\n              url: new URL(`http://${container.getHost()}:9200`),\n            },\n            maxRetries: 10,\n            requestTimeout: 60000,\n            sniffOnStart: true,\n            Connection: HttpConnection,\n          }),\n        ],\n      }).compile();\n      app = moduleFixture.createNestApplication();\n      interceptor = new ElkInterceptor(app.get&lt;ElkService&gt;(ElkService));\n      app.useGlobalInterceptors(interceptor);\n      elkService = moduleFixture.get&lt;ElkService&gt;(ElkService);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;362bf64a-49fe-482b-b083-82cff019d127&quot;,&quot;parentUUID&quot;:&quot;75f69b88-729b-4c0f-b415-5d527cb20391&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;ElkModule &gt; ElkInterceptor &gt; should be create document in elasticsearch when return exception http&quot;,&quot;title&quot;:&quot;ElkModule &gt; ElkInterceptor &gt; should be create document in elasticsearch when return exception http&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1008,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { HttpException, INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport {\n  dynamicConfig,\n  fixtureUserResponse,\n  TCElasticSearchOptions,\n  tcName,\n  testContainers,\n} from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { Observable, of, throwError } from &#x27;rxjs&#x27;;\nimport { HttpConnection } from &#x27;@elastic/elasticsearch&#x27;;\nimport { URL } from &#x27;url&#x27;;\n\nimport { ElkModule } from &#x27;../elk/elk.module&#x27;;\nimport { ElkInterceptor } from &#x27;../elk/interceptors/elk.interceptor&#x27;;\nimport { ElkService } from &#x27;../elk/services/elk.service&#x27;;\n\nlet executionContext: any = {\n  switchToHttp: jest.fn(() =&gt; ({\n    getRequest: () =&gt; ({\n      path: &#x27;/test&#x27;,\n      method: &#x27;GET&#x27;,\n      params: {},\n      query: {},\n      body: {},\n      headers: {\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        apiKey: &#x27;abcdefg12345&#x27;,\n      },\n    }),\n    getResponse: () =&gt; ({\n      getHeaders: jest.fn().mockReturnValue({\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        my_header: &#x27;test-header&#x27;,\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() =&gt; &#x27;http&#x27;),\n  getClass: jest.fn(() =&gt; &#x27;testController&#x27;),\n  getHandler: jest.fn(() =&gt; &#x27;handlerElk&#x27;),\n};\n\nlet executionContextParams: any = {\n  switchToHttp: jest.fn(() =&gt; ({\n    getRequest: () =&gt; ({\n      path: &#x27;/test&#x27;,\n      method: &#x27;GET&#x27;,\n      params: { name: &#x27;juan&#x27; },\n      query: { name: &#x27;juan&#x27; },\n      body: { name: &#x27;juan&#x27; },\n      headers: {\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        apiKey: &#x27;abcdefg12345&#x27;,\n      },\n    }),\n    getResponse: () =&gt; ({\n      getHeaders: jest.fn().mockReturnValue({\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        my_header: &#x27;test-header&#x27;,\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() =&gt; &#x27;http&#x27;),\n  getClass: jest.fn(() =&gt; &#x27;testController&#x27;),\n  getHandler: jest.fn(() =&gt; &#x27;handlerElk&#x27;),\n};\n\n/*const callHandler: any = {\n  handle: jest.fn(() =&gt; ({\n    pipe: jest.fn(() =&gt; ({\n      tap: jest.fn(() =&gt; ({\n        next: jest.fn(),\n        error: jest.fn(),\n      })),\n    })),\n  })),\n};*/\n\njest.setTimeout(70000);\ndescribe(&#x27;ElkModule&#x27;, () =&gt; {\n  let app: INestApplication;\n  let elkService: ElkService;\n  let interceptor: ElkInterceptor&lt;any&gt;;\n  let container: testContainers;\n\n  beforeAll(async () =&gt; {\n    //&#x27;elasticsearch:8.3.3&#x27;\n    //docker.elastic.co/elasticsearch/elasticsearch:8.3.3\n\n    container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n      ...TCElasticSearchOptions,\n      containerName: `${tcName}-elasticsearch-interceptor`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              elasticsearch: {\n                name: &#x27;test-elk-index&#x27;,\n                node: {\n                  url: new URL(`http://${container.getHost()}:9200`),\n                },\n                maxRetries: 10,\n                requestTimeout: 60000,\n                sniffOnStart: true,\n                Connection: HttpConnection,\n              },\n            }),\n          ],\n        }),\n        ElkModule,\n      ],\n    }).compile();\n    app = moduleFixture.createNestApplication();\n    interceptor = new ElkInterceptor(app.get&lt;ElkService&gt;(ElkService));\n    app.useGlobalInterceptors(interceptor);\n    elkService = moduleFixture.get&lt;ElkService&gt;(ElkService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(app).toBeDefined();\n  });\n\n  describe(&#x27;ElkInterceptor&#x27;, () =&gt; {\n    it(&#x27;should be an ElkInterceptor instance to be defined&#x27;, async () =&gt; {\n      expect(new ElkInterceptor(elkService)).toBeDefined();\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success string&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of(&#x27;this is a test&#x27;)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success object&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of([fixtureUserResponse])),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success with parameters&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of([fixtureUserResponse])),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContextParams, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return exception&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const error = new Error(`User #$1 not found`);\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; throwError(error)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () =&gt; {},\n        error: (error) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return exception http&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const error = new HttpException(&#x27;not found&#x27;, 404);\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; throwError(error)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () =&gt; {},\n        error: (error) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n  });\n\n  describe(&#x27;ElkModule - Register&#x27;, () =&gt; {\n    let app: INestApplication;\n    let elkService: ElkService;\n    let interceptor: ElkInterceptor&lt;any&gt;;\n\n    beforeEach(async () =&gt; {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ElkModule.register({\n            name: &#x27;test-elk-index&#x27;,\n            node: {\n              url: new URL(`http://${container.getHost()}:9200`),\n            },\n            maxRetries: 10,\n            requestTimeout: 60000,\n            sniffOnStart: true,\n            Connection: HttpConnection,\n          }),\n        ],\n      }).compile();\n      app = moduleFixture.createNestApplication();\n      interceptor = new ElkInterceptor(app.get&lt;ElkService&gt;(ElkService));\n      app.useGlobalInterceptors(interceptor);\n      elkService = moduleFixture.get&lt;ElkService&gt;(ElkService);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;84bc7e3a-f7a4-4ea6-9dbe-7890edb8b263&quot;,&quot;parentUUID&quot;:&quot;75f69b88-729b-4c0f-b415-5d527cb20391&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;ElkModule &gt; ElkModule - Register &gt; should be defined&quot;,&quot;title&quot;:&quot;ElkModule &gt; ElkModule - Register &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1032,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { HttpException, INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport {\n  dynamicConfig,\n  fixtureUserResponse,\n  TCElasticSearchOptions,\n  tcName,\n  testContainers,\n} from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { Observable, of, throwError } from &#x27;rxjs&#x27;;\nimport { HttpConnection } from &#x27;@elastic/elasticsearch&#x27;;\nimport { URL } from &#x27;url&#x27;;\n\nimport { ElkModule } from &#x27;../elk/elk.module&#x27;;\nimport { ElkInterceptor } from &#x27;../elk/interceptors/elk.interceptor&#x27;;\nimport { ElkService } from &#x27;../elk/services/elk.service&#x27;;\n\nlet executionContext: any = {\n  switchToHttp: jest.fn(() =&gt; ({\n    getRequest: () =&gt; ({\n      path: &#x27;/test&#x27;,\n      method: &#x27;GET&#x27;,\n      params: {},\n      query: {},\n      body: {},\n      headers: {\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        apiKey: &#x27;abcdefg12345&#x27;,\n      },\n    }),\n    getResponse: () =&gt; ({\n      getHeaders: jest.fn().mockReturnValue({\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        my_header: &#x27;test-header&#x27;,\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() =&gt; &#x27;http&#x27;),\n  getClass: jest.fn(() =&gt; &#x27;testController&#x27;),\n  getHandler: jest.fn(() =&gt; &#x27;handlerElk&#x27;),\n};\n\nlet executionContextParams: any = {\n  switchToHttp: jest.fn(() =&gt; ({\n    getRequest: () =&gt; ({\n      path: &#x27;/test&#x27;,\n      method: &#x27;GET&#x27;,\n      params: { name: &#x27;juan&#x27; },\n      query: { name: &#x27;juan&#x27; },\n      body: { name: &#x27;juan&#x27; },\n      headers: {\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        apiKey: &#x27;abcdefg12345&#x27;,\n      },\n    }),\n    getResponse: () =&gt; ({\n      getHeaders: jest.fn().mockReturnValue({\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        my_header: &#x27;test-header&#x27;,\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() =&gt; &#x27;http&#x27;),\n  getClass: jest.fn(() =&gt; &#x27;testController&#x27;),\n  getHandler: jest.fn(() =&gt; &#x27;handlerElk&#x27;),\n};\n\n/*const callHandler: any = {\n  handle: jest.fn(() =&gt; ({\n    pipe: jest.fn(() =&gt; ({\n      tap: jest.fn(() =&gt; ({\n        next: jest.fn(),\n        error: jest.fn(),\n      })),\n    })),\n  })),\n};*/\n\njest.setTimeout(70000);\ndescribe(&#x27;ElkModule&#x27;, () =&gt; {\n  let app: INestApplication;\n  let elkService: ElkService;\n  let interceptor: ElkInterceptor&lt;any&gt;;\n  let container: testContainers;\n\n  beforeAll(async () =&gt; {\n    //&#x27;elasticsearch:8.3.3&#x27;\n    //docker.elastic.co/elasticsearch/elasticsearch:8.3.3\n\n    container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n      ...TCElasticSearchOptions,\n      containerName: `${tcName}-elasticsearch-interceptor`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              elasticsearch: {\n                name: &#x27;test-elk-index&#x27;,\n                node: {\n                  url: new URL(`http://${container.getHost()}:9200`),\n                },\n                maxRetries: 10,\n                requestTimeout: 60000,\n                sniffOnStart: true,\n                Connection: HttpConnection,\n              },\n            }),\n          ],\n        }),\n        ElkModule,\n      ],\n    }).compile();\n    app = moduleFixture.createNestApplication();\n    interceptor = new ElkInterceptor(app.get&lt;ElkService&gt;(ElkService));\n    app.useGlobalInterceptors(interceptor);\n    elkService = moduleFixture.get&lt;ElkService&gt;(ElkService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(app).toBeDefined();\n  });\n\n  describe(&#x27;ElkInterceptor&#x27;, () =&gt; {\n    it(&#x27;should be an ElkInterceptor instance to be defined&#x27;, async () =&gt; {\n      expect(new ElkInterceptor(elkService)).toBeDefined();\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success string&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of(&#x27;this is a test&#x27;)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success object&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of([fixtureUserResponse])),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success with parameters&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of([fixtureUserResponse])),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContextParams, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return exception&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const error = new Error(`User #$1 not found`);\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; throwError(error)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () =&gt; {},\n        error: (error) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return exception http&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const error = new HttpException(&#x27;not found&#x27;, 404);\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; throwError(error)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () =&gt; {},\n        error: (error) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n  });\n\n  describe(&#x27;ElkModule - Register&#x27;, () =&gt; {\n    let app: INestApplication;\n    let elkService: ElkService;\n    let interceptor: ElkInterceptor&lt;any&gt;;\n\n    beforeEach(async () =&gt; {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ElkModule.register({\n            name: &#x27;test-elk-index&#x27;,\n            node: {\n              url: new URL(`http://${container.getHost()}:9200`),\n            },\n            maxRetries: 10,\n            requestTimeout: 60000,\n            sniffOnStart: true,\n            Connection: HttpConnection,\n          }),\n        ],\n      }).compile();\n      app = moduleFixture.createNestApplication();\n      interceptor = new ElkInterceptor(app.get&lt;ElkService&gt;(ElkService));\n      app.useGlobalInterceptors(interceptor);\n      elkService = moduleFixture.get&lt;ElkService&gt;(ElkService);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b993c3e1-8a86-470d-8171-6750642b856e&quot;,&quot;parentUUID&quot;:&quot;75f69b88-729b-4c0f-b415-5d527cb20391&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;8dc6dac1-0415-48e0-b158-3f2293573a9a&quot;,&quot;35994cbb-1ced-492b-acec-73db2b57cc1b&quot;,&quot;c681ce2b-0d0b-492f-9b1c-f8c18c89a411&quot;,&quot;491352ef-7f86-49af-b237-627f3b1dea8c&quot;,&quot;6797888f-7622-40e8-9f07-046b874f810b&quot;,&quot;362bf64a-49fe-482b-b083-82cff019d127&quot;,&quot;84bc7e3a-f7a4-4ea6-9dbe-7890edb8b263&quot;,&quot;b993c3e1-8a86-470d-8171-6750642b856e&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:8451,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:5000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:5000},{&quot;uuid&quot;:&quot;7a309b9f-81ec-44db-a70c-34772ca802df&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/filters&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;4e0fc067-c8de-4af8-9096-d112fd14f523&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/filters&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;fullTitle&quot;:&quot;filters &gt; code exception &gt; should map a regular code exception&quot;,&quot;title&quot;:&quot;filters &gt; code exception &gt; should map a regular code exception&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from &#x27;@nestjs/common&#x27;;\nimport { config } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from &#x27;../&#x27;;\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() =&gt; ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() =&gt; ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() =&gt; ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() =&gt; ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() =&gt; ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() =&gt; ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe(&#x27;filters&#x27;, () =&gt; {\n  describe(&#x27;code exception&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map a regular code exception&#x27;, () =&gt; {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split(&#x27;&#x27;);\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe(&#x27;default Http exceptions&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details and description&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;passing?&#x27;;\n      const details = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe(&#x27;the generic HttpException&#x27;, () =&gt; {\n      it(&#x27;should map HttpException response when called with a string&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const message = &#x27;Not passing&#x27;;\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;some message&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object with empty message&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an array&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: [&#x27;some message&#x27;, &#x27;some message 2&#x27;],\n          error: &#x27;Bad Request&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n      const errorObject: IErrorDetail = {\n        message: &#x27;some message&#x27;,\n        error: {\n          instance: &#x27;instance&#x27;,\n          type: &#x27;some-problem-detail&#x27;,\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;when used outside a module&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;configuration is defined with values&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it(&#x27;should be return application info&#x27;, async () =&gt; {\n      expect(appConfig.project.apiPrefix).toEqual(&#x27;API-TEST&#x27;);\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe(&#x27;configuration is undefined&#x27;, () =&gt; {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b4acf2f5-90db-4855-92ff-eb793179824e&quot;,&quot;parentUUID&quot;:&quot;4e0fc067-c8de-4af8-9096-d112fd14f523&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;filters &gt; default Http exceptions &gt; should map default exception when thrown with not parameters&quot;,&quot;title&quot;:&quot;filters &gt; default Http exceptions &gt; should map default exception when thrown with not parameters&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from &#x27;@nestjs/common&#x27;;\nimport { config } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from &#x27;../&#x27;;\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() =&gt; ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() =&gt; ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() =&gt; ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() =&gt; ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() =&gt; ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() =&gt; ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe(&#x27;filters&#x27;, () =&gt; {\n  describe(&#x27;code exception&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map a regular code exception&#x27;, () =&gt; {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split(&#x27;&#x27;);\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe(&#x27;default Http exceptions&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details and description&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;passing?&#x27;;\n      const details = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe(&#x27;the generic HttpException&#x27;, () =&gt; {\n      it(&#x27;should map HttpException response when called with a string&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const message = &#x27;Not passing&#x27;;\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;some message&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object with empty message&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an array&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: [&#x27;some message&#x27;, &#x27;some message 2&#x27;],\n          error: &#x27;Bad Request&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n      const errorObject: IErrorDetail = {\n        message: &#x27;some message&#x27;,\n        error: {\n          instance: &#x27;instance&#x27;,\n          type: &#x27;some-problem-detail&#x27;,\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;when used outside a module&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;configuration is defined with values&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it(&#x27;should be return application info&#x27;, async () =&gt; {\n      expect(appConfig.project.apiPrefix).toEqual(&#x27;API-TEST&#x27;);\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe(&#x27;configuration is undefined&#x27;, () =&gt; {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9e419ce0-bee9-49af-933f-d1c43ac36606&quot;,&quot;parentUUID&quot;:&quot;4e0fc067-c8de-4af8-9096-d112fd14f523&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;filters &gt; default Http exceptions &gt; should map default exception when thrown with error details&quot;,&quot;title&quot;:&quot;filters &gt; default Http exceptions &gt; should map default exception when thrown with error details&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from &#x27;@nestjs/common&#x27;;\nimport { config } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from &#x27;../&#x27;;\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() =&gt; ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() =&gt; ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() =&gt; ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() =&gt; ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() =&gt; ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() =&gt; ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe(&#x27;filters&#x27;, () =&gt; {\n  describe(&#x27;code exception&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map a regular code exception&#x27;, () =&gt; {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split(&#x27;&#x27;);\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe(&#x27;default Http exceptions&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details and description&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;passing?&#x27;;\n      const details = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe(&#x27;the generic HttpException&#x27;, () =&gt; {\n      it(&#x27;should map HttpException response when called with a string&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const message = &#x27;Not passing&#x27;;\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;some message&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object with empty message&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an array&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: [&#x27;some message&#x27;, &#x27;some message 2&#x27;],\n          error: &#x27;Bad Request&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n      const errorObject: IErrorDetail = {\n        message: &#x27;some message&#x27;,\n        error: {\n          instance: &#x27;instance&#x27;,\n          type: &#x27;some-problem-detail&#x27;,\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;when used outside a module&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;configuration is defined with values&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it(&#x27;should be return application info&#x27;, async () =&gt; {\n      expect(appConfig.project.apiPrefix).toEqual(&#x27;API-TEST&#x27;);\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe(&#x27;configuration is undefined&#x27;, () =&gt; {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b65b96d1-61ec-423c-a772-f9a71b8b412e&quot;,&quot;parentUUID&quot;:&quot;4e0fc067-c8de-4af8-9096-d112fd14f523&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;filters &gt; default Http exceptions &gt; should map default exception when thrown with error details and description&quot;,&quot;title&quot;:&quot;filters &gt; default Http exceptions &gt; should map default exception when thrown with error details and description&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from &#x27;@nestjs/common&#x27;;\nimport { config } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from &#x27;../&#x27;;\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() =&gt; ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() =&gt; ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() =&gt; ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() =&gt; ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() =&gt; ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() =&gt; ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe(&#x27;filters&#x27;, () =&gt; {\n  describe(&#x27;code exception&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map a regular code exception&#x27;, () =&gt; {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split(&#x27;&#x27;);\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe(&#x27;default Http exceptions&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details and description&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;passing?&#x27;;\n      const details = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe(&#x27;the generic HttpException&#x27;, () =&gt; {\n      it(&#x27;should map HttpException response when called with a string&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const message = &#x27;Not passing&#x27;;\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;some message&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object with empty message&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an array&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: [&#x27;some message&#x27;, &#x27;some message 2&#x27;],\n          error: &#x27;Bad Request&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n      const errorObject: IErrorDetail = {\n        message: &#x27;some message&#x27;,\n        error: {\n          instance: &#x27;instance&#x27;,\n          type: &#x27;some-problem-detail&#x27;,\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;when used outside a module&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;configuration is defined with values&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it(&#x27;should be return application info&#x27;, async () =&gt; {\n      expect(appConfig.project.apiPrefix).toEqual(&#x27;API-TEST&#x27;);\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe(&#x27;configuration is undefined&#x27;, () =&gt; {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2ae5669d-9ef1-4c66-9b2a-88ff43f1237e&quot;,&quot;parentUUID&quot;:&quot;4e0fc067-c8de-4af8-9096-d112fd14f523&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;filters &gt; default Http exceptions &gt; the generic HttpException &gt; should map HttpException response when called with a string&quot;,&quot;title&quot;:&quot;filters &gt; default Http exceptions &gt; the generic HttpException &gt; should map HttpException response when called with a string&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from &#x27;@nestjs/common&#x27;;\nimport { config } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from &#x27;../&#x27;;\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() =&gt; ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() =&gt; ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() =&gt; ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() =&gt; ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() =&gt; ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() =&gt; ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe(&#x27;filters&#x27;, () =&gt; {\n  describe(&#x27;code exception&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map a regular code exception&#x27;, () =&gt; {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split(&#x27;&#x27;);\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe(&#x27;default Http exceptions&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details and description&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;passing?&#x27;;\n      const details = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe(&#x27;the generic HttpException&#x27;, () =&gt; {\n      it(&#x27;should map HttpException response when called with a string&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const message = &#x27;Not passing&#x27;;\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;some message&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object with empty message&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an array&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: [&#x27;some message&#x27;, &#x27;some message 2&#x27;],\n          error: &#x27;Bad Request&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n      const errorObject: IErrorDetail = {\n        message: &#x27;some message&#x27;,\n        error: {\n          instance: &#x27;instance&#x27;,\n          type: &#x27;some-problem-detail&#x27;,\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;when used outside a module&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;configuration is defined with values&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it(&#x27;should be return application info&#x27;, async () =&gt; {\n      expect(appConfig.project.apiPrefix).toEqual(&#x27;API-TEST&#x27;);\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe(&#x27;configuration is undefined&#x27;, () =&gt; {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1a0873b3-9a92-41c0-a365-2d11ce793409&quot;,&quot;parentUUID&quot;:&quot;4e0fc067-c8de-4af8-9096-d112fd14f523&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;filters &gt; default Http exceptions &gt; the generic HttpException &gt; should map HttpException response when called with an object&quot;,&quot;title&quot;:&quot;filters &gt; default Http exceptions &gt; the generic HttpException &gt; should map HttpException response when called with an object&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from &#x27;@nestjs/common&#x27;;\nimport { config } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from &#x27;../&#x27;;\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() =&gt; ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() =&gt; ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() =&gt; ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() =&gt; ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() =&gt; ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() =&gt; ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe(&#x27;filters&#x27;, () =&gt; {\n  describe(&#x27;code exception&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map a regular code exception&#x27;, () =&gt; {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split(&#x27;&#x27;);\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe(&#x27;default Http exceptions&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details and description&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;passing?&#x27;;\n      const details = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe(&#x27;the generic HttpException&#x27;, () =&gt; {\n      it(&#x27;should map HttpException response when called with a string&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const message = &#x27;Not passing&#x27;;\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;some message&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object with empty message&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an array&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: [&#x27;some message&#x27;, &#x27;some message 2&#x27;],\n          error: &#x27;Bad Request&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n      const errorObject: IErrorDetail = {\n        message: &#x27;some message&#x27;,\n        error: {\n          instance: &#x27;instance&#x27;,\n          type: &#x27;some-problem-detail&#x27;,\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;when used outside a module&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;configuration is defined with values&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it(&#x27;should be return application info&#x27;, async () =&gt; {\n      expect(appConfig.project.apiPrefix).toEqual(&#x27;API-TEST&#x27;);\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe(&#x27;configuration is undefined&#x27;, () =&gt; {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f861e391-3d0f-4b4a-a790-6af316fc7177&quot;,&quot;parentUUID&quot;:&quot;4e0fc067-c8de-4af8-9096-d112fd14f523&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;filters &gt; default Http exceptions &gt; the generic HttpException &gt; should map HttpException response when called with an object with empty message&quot;,&quot;title&quot;:&quot;filters &gt; default Http exceptions &gt; the generic HttpException &gt; should map HttpException response when called with an object with empty message&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from &#x27;@nestjs/common&#x27;;\nimport { config } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from &#x27;../&#x27;;\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() =&gt; ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() =&gt; ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() =&gt; ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() =&gt; ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() =&gt; ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() =&gt; ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe(&#x27;filters&#x27;, () =&gt; {\n  describe(&#x27;code exception&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map a regular code exception&#x27;, () =&gt; {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split(&#x27;&#x27;);\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe(&#x27;default Http exceptions&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details and description&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;passing?&#x27;;\n      const details = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe(&#x27;the generic HttpException&#x27;, () =&gt; {\n      it(&#x27;should map HttpException response when called with a string&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const message = &#x27;Not passing&#x27;;\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;some message&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object with empty message&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an array&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: [&#x27;some message&#x27;, &#x27;some message 2&#x27;],\n          error: &#x27;Bad Request&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n      const errorObject: IErrorDetail = {\n        message: &#x27;some message&#x27;,\n        error: {\n          instance: &#x27;instance&#x27;,\n          type: &#x27;some-problem-detail&#x27;,\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;when used outside a module&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;configuration is defined with values&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it(&#x27;should be return application info&#x27;, async () =&gt; {\n      expect(appConfig.project.apiPrefix).toEqual(&#x27;API-TEST&#x27;);\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe(&#x27;configuration is undefined&#x27;, () =&gt; {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7ddfd827-e22b-4bc1-a375-a0e7348850dd&quot;,&quot;parentUUID&quot;:&quot;4e0fc067-c8de-4af8-9096-d112fd14f523&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;filters &gt; default Http exceptions &gt; the generic HttpException &gt; should map HttpException response when called with an array&quot;,&quot;title&quot;:&quot;filters &gt; default Http exceptions &gt; the generic HttpException &gt; should map HttpException response when called with an array&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from &#x27;@nestjs/common&#x27;;\nimport { config } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from &#x27;../&#x27;;\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() =&gt; ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() =&gt; ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() =&gt; ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() =&gt; ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() =&gt; ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() =&gt; ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe(&#x27;filters&#x27;, () =&gt; {\n  describe(&#x27;code exception&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map a regular code exception&#x27;, () =&gt; {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split(&#x27;&#x27;);\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe(&#x27;default Http exceptions&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details and description&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;passing?&#x27;;\n      const details = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe(&#x27;the generic HttpException&#x27;, () =&gt; {\n      it(&#x27;should map HttpException response when called with a string&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const message = &#x27;Not passing&#x27;;\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;some message&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object with empty message&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an array&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: [&#x27;some message&#x27;, &#x27;some message 2&#x27;],\n          error: &#x27;Bad Request&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n      const errorObject: IErrorDetail = {\n        message: &#x27;some message&#x27;,\n        error: {\n          instance: &#x27;instance&#x27;,\n          type: &#x27;some-problem-detail&#x27;,\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;when used outside a module&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;configuration is defined with values&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it(&#x27;should be return application info&#x27;, async () =&gt; {\n      expect(appConfig.project.apiPrefix).toEqual(&#x27;API-TEST&#x27;);\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe(&#x27;configuration is undefined&#x27;, () =&gt; {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;962c9544-619d-4a6a-8958-847b1c8e0c53&quot;,&quot;parentUUID&quot;:&quot;4e0fc067-c8de-4af8-9096-d112fd14f523&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;filters &gt; default Http exceptions &gt; should map HttpException response when called with an object&quot;,&quot;title&quot;:&quot;filters &gt; default Http exceptions &gt; should map HttpException response when called with an object&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:0,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from &#x27;@nestjs/common&#x27;;\nimport { config } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from &#x27;../&#x27;;\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() =&gt; ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() =&gt; ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() =&gt; ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() =&gt; ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() =&gt; ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() =&gt; ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe(&#x27;filters&#x27;, () =&gt; {\n  describe(&#x27;code exception&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map a regular code exception&#x27;, () =&gt; {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split(&#x27;&#x27;);\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe(&#x27;default Http exceptions&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details and description&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;passing?&#x27;;\n      const details = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe(&#x27;the generic HttpException&#x27;, () =&gt; {\n      it(&#x27;should map HttpException response when called with a string&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const message = &#x27;Not passing&#x27;;\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;some message&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object with empty message&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an array&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: [&#x27;some message&#x27;, &#x27;some message 2&#x27;],\n          error: &#x27;Bad Request&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n      const errorObject: IErrorDetail = {\n        message: &#x27;some message&#x27;,\n        error: {\n          instance: &#x27;instance&#x27;,\n          type: &#x27;some-problem-detail&#x27;,\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;when used outside a module&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;configuration is defined with values&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it(&#x27;should be return application info&#x27;, async () =&gt; {\n      expect(appConfig.project.apiPrefix).toEqual(&#x27;API-TEST&#x27;);\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe(&#x27;configuration is undefined&#x27;, () =&gt; {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b4d5699c-de68-402b-8118-daddf80b1bde&quot;,&quot;parentUUID&quot;:&quot;4e0fc067-c8de-4af8-9096-d112fd14f523&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;filters &gt; when used outside a module &gt; should map default exception when thrown with not parameters&quot;,&quot;title&quot;:&quot;filters &gt; when used outside a module &gt; should map default exception when thrown with not parameters&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:0,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from &#x27;@nestjs/common&#x27;;\nimport { config } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from &#x27;../&#x27;;\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() =&gt; ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() =&gt; ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() =&gt; ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() =&gt; ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() =&gt; ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() =&gt; ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe(&#x27;filters&#x27;, () =&gt; {\n  describe(&#x27;code exception&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map a regular code exception&#x27;, () =&gt; {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split(&#x27;&#x27;);\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe(&#x27;default Http exceptions&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details and description&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;passing?&#x27;;\n      const details = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe(&#x27;the generic HttpException&#x27;, () =&gt; {\n      it(&#x27;should map HttpException response when called with a string&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const message = &#x27;Not passing&#x27;;\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;some message&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object with empty message&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an array&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: [&#x27;some message&#x27;, &#x27;some message 2&#x27;],\n          error: &#x27;Bad Request&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n      const errorObject: IErrorDetail = {\n        message: &#x27;some message&#x27;,\n        error: {\n          instance: &#x27;instance&#x27;,\n          type: &#x27;some-problem-detail&#x27;,\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;when used outside a module&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;configuration is defined with values&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it(&#x27;should be return application info&#x27;, async () =&gt; {\n      expect(appConfig.project.apiPrefix).toEqual(&#x27;API-TEST&#x27;);\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe(&#x27;configuration is undefined&#x27;, () =&gt; {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ea8688aa-e22d-43bb-8339-d3797d01f6a5&quot;,&quot;parentUUID&quot;:&quot;4e0fc067-c8de-4af8-9096-d112fd14f523&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;filters &gt; configuration is defined with values &gt; should be return application info&quot;,&quot;title&quot;:&quot;filters &gt; configuration is defined with values &gt; should be return application info&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:0,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from &#x27;@nestjs/common&#x27;;\nimport { config } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from &#x27;../&#x27;;\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() =&gt; ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() =&gt; ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() =&gt; ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() =&gt; ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() =&gt; ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() =&gt; ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe(&#x27;filters&#x27;, () =&gt; {\n  describe(&#x27;code exception&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map a regular code exception&#x27;, () =&gt; {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split(&#x27;&#x27;);\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe(&#x27;default Http exceptions&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details and description&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;passing?&#x27;;\n      const details = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe(&#x27;the generic HttpException&#x27;, () =&gt; {\n      it(&#x27;should map HttpException response when called with a string&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const message = &#x27;Not passing&#x27;;\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;some message&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object with empty message&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an array&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: [&#x27;some message&#x27;, &#x27;some message 2&#x27;],\n          error: &#x27;Bad Request&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n      const errorObject: IErrorDetail = {\n        message: &#x27;some message&#x27;,\n        error: {\n          instance: &#x27;instance&#x27;,\n          type: &#x27;some-problem-detail&#x27;,\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;when used outside a module&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;configuration is defined with values&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it(&#x27;should be return application info&#x27;, async () =&gt; {\n      expect(appConfig.project.apiPrefix).toEqual(&#x27;API-TEST&#x27;);\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe(&#x27;configuration is undefined&#x27;, () =&gt; {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7ffa0cd7-e6c3-42b0-a005-211c7d123570&quot;,&quot;parentUUID&quot;:&quot;4e0fc067-c8de-4af8-9096-d112fd14f523&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;error.utils &gt; should be return code in string&quot;,&quot;title&quot;:&quot;error.utils &gt; should be return code in string&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:7,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { getCode } from &#x27;../&#x27;;\nimport { HttpStatus } from &#x27;@nestjs/common&#x27;;\n\ndescribe(&#x27;error.utils&#x27;, () =&gt; {\n  it(&#x27;should be return code in string&#x27;, () =&gt; {\n    const code = getCode(HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR]);\n    expect(code).toEqual(&#x27;INTERNAL_SERVER_ERROR&#x27;);\n  });\n\n  it(&#x27;should be return code in string obj&#x27;, () =&gt; {\n    const code = getCode({ error: HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR] });\n    expect(code).toEqual(&#x27;INTERNAL_SERVER_ERROR&#x27;);\n  });\n\n  it(&#x27;should be return code in string&#x27;, () =&gt; {\n    const code = getCode({ error: HttpStatus[&#x27;TEST_ERROR&#x27;] });\n    expect(code).toEqual(&#x27;INTERNAL_SERVER_ERROR&#x27;);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9cac9cc4-8442-4cb7-9609-d75010cf1cc3&quot;,&quot;parentUUID&quot;:&quot;4e0fc067-c8de-4af8-9096-d112fd14f523&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;error.utils &gt; should be return code in string obj&quot;,&quot;title&quot;:&quot;error.utils &gt; should be return code in string obj&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { getCode } from &#x27;../&#x27;;\nimport { HttpStatus } from &#x27;@nestjs/common&#x27;;\n\ndescribe(&#x27;error.utils&#x27;, () =&gt; {\n  it(&#x27;should be return code in string&#x27;, () =&gt; {\n    const code = getCode(HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR]);\n    expect(code).toEqual(&#x27;INTERNAL_SERVER_ERROR&#x27;);\n  });\n\n  it(&#x27;should be return code in string obj&#x27;, () =&gt; {\n    const code = getCode({ error: HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR] });\n    expect(code).toEqual(&#x27;INTERNAL_SERVER_ERROR&#x27;);\n  });\n\n  it(&#x27;should be return code in string&#x27;, () =&gt; {\n    const code = getCode({ error: HttpStatus[&#x27;TEST_ERROR&#x27;] });\n    expect(code).toEqual(&#x27;INTERNAL_SERVER_ERROR&#x27;);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;cda3d17c-c490-49ad-8210-4219d997e1ef&quot;,&quot;parentUUID&quot;:&quot;4e0fc067-c8de-4af8-9096-d112fd14f523&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;error.utils &gt; should be return code in string&quot;,&quot;title&quot;:&quot;error.utils &gt; should be return code in string&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:0,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { getCode } from &#x27;../&#x27;;\nimport { HttpStatus } from &#x27;@nestjs/common&#x27;;\n\ndescribe(&#x27;error.utils&#x27;, () =&gt; {\n  it(&#x27;should be return code in string&#x27;, () =&gt; {\n    const code = getCode(HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR]);\n    expect(code).toEqual(&#x27;INTERNAL_SERVER_ERROR&#x27;);\n  });\n\n  it(&#x27;should be return code in string obj&#x27;, () =&gt; {\n    const code = getCode({ error: HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR] });\n    expect(code).toEqual(&#x27;INTERNAL_SERVER_ERROR&#x27;);\n  });\n\n  it(&#x27;should be return code in string&#x27;, () =&gt; {\n    const code = getCode({ error: HttpStatus[&#x27;TEST_ERROR&#x27;] });\n    expect(code).toEqual(&#x27;INTERNAL_SERVER_ERROR&#x27;);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4d2a0693-b16f-4044-a686-52d906f42aa8&quot;,&quot;parentUUID&quot;:&quot;4e0fc067-c8de-4af8-9096-d112fd14f523&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;b4acf2f5-90db-4855-92ff-eb793179824e&quot;,&quot;9e419ce0-bee9-49af-933f-d1c43ac36606&quot;,&quot;b65b96d1-61ec-423c-a772-f9a71b8b412e&quot;,&quot;2ae5669d-9ef1-4c66-9b2a-88ff43f1237e&quot;,&quot;1a0873b3-9a92-41c0-a365-2d11ce793409&quot;,&quot;f861e391-3d0f-4b4a-a790-6af316fc7177&quot;,&quot;7ddfd827-e22b-4bc1-a375-a0e7348850dd&quot;,&quot;962c9544-619d-4a6a-8958-847b1c8e0c53&quot;,&quot;b4d5699c-de68-402b-8118-daddf80b1bde&quot;,&quot;ea8688aa-e22d-43bb-8339-d3797d01f6a5&quot;,&quot;7ffa0cd7-e6c3-42b0-a005-211c7d123570&quot;,&quot;9cac9cc4-8442-4cb7-9609-d75010cf1cc3&quot;,&quot;cda3d17c-c490-49ad-8210-4219d997e1ef&quot;,&quot;4d2a0693-b16f-4044-a686-52d906f42aa8&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:17,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:5000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:5000},{&quot;uuid&quot;:&quot;9f431b87-f9ff-49f2-92b7-967e4b57409c&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/health&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;cb2d6453-56ce-4c60-bd04-f382477fd87a&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/health&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;fullTitle&quot;:&quot;Health &gt; Ready controller - extend config &gt; should be defined with extend config&quot;,&quot;title&quot;:&quot;Health &gt; Ready controller - extend config &gt; should be defined with extend config&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:763,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { HttpModule } from &#x27;@nestjs/axios&#x27;;\nimport {\n  HealthCheckService,\n  HttpHealthIndicator,\n  TerminusModule,\n  TypeOrmHealthIndicator,\n  MicroserviceHealthIndicator,\n} from &#x27;@nestjs/terminus&#x27;;\n\nimport { ReadinessController } from &#x27;../health/controllers/readiness.controller&#x27;;\nimport { CONFIG_OPTIONS } from &#x27;../health/constants&#x27;;\n\nconst mockedConfig = {\n  services: {\n    myService: {\n      url: &#x27;http://localhost:8082&#x27;,\n      timeout: 3000,\n    },\n    demoApi: {\n      url: &#x27;https://nestjs-starter.up.railway.app&#x27;,\n      timeout: 3000,\n      healthPath: &#x27;/v1/health/liveness&#x27;,\n    },\n  },\n  database: {\n    typeorm: {\n      type: &#x27;postgres&#x27;,\n    },\n  },\n  redis: {\n    host: &#x27;localhost&#x27;,\n    port: 6379,\n  },\n  elasticsearch: {\n    name: &#x27;test-app&#x27;,\n    node: &#x27;http://localhost:9200&#x27;,\n  },\n  camunda: {\n    baseUrl: &#x27;http://localhost:8080/engine-rest&#x27;,\n  },\n};\n\nconst mockExpectReadiness = {\n  status: &#x27;ok&#x27;,\n  info: {\n    myService: {\n      status: &#x27;up&#x27;,\n    },\n    typeOrm: {\n      status: &#x27;up&#x27;,\n    },\n    redis: {\n      status: &#x27;up&#x27;,\n    },\n    elasticsearch: {\n      status: &#x27;up&#x27;,\n    },\n    camunda: {\n      status: &#x27;up&#x27;,\n    },\n  },\n  error: {},\n  details: {\n    myService: {\n      status: &#x27;up&#x27;,\n    },\n    typeOrm: {\n      status: &#x27;up&#x27;,\n    },\n    redis: {\n      status: &#x27;up&#x27;,\n    },\n    elasticsearch: {\n      status: &#x27;up&#x27;,\n    },\n    camunda: {\n      status: &#x27;up&#x27;,\n    },\n  },\n};\n\nconst mockExpectReadinessDown = {\n  myService: {\n    status: &#x27;down&#x27;,\n    message: &#x27;connect ECONNREFUSED 127.0.0.1:8082&#x27;,\n  },\n};\n\nconst simpleConfig = {\n  services: {\n    myService: { url: &#x27;http://localhost:8082&#x27; },\n  },\n};\n\ndescribe(&#x27;Health&#x27;, () =&gt; {\n  describe(&#x27;Ready controller - extend config&#x27;, () =&gt; {\n    let controller: ReadinessController;\n    let health: HealthCheckService;\n    let http: HttpHealthIndicator;\n    let typeOrm: TypeOrmHealthIndicator;\n    let redis: MicroserviceHealthIndicator;\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [TerminusModule, HttpModule],\n        controllers: [ReadinessController],\n        providers: [\n          {\n            provide: CONFIG_OPTIONS,\n            useValue: mockedConfig,\n          },\n        ],\n      }).compile();\n\n      controller = module.get&lt;ReadinessController&gt;(ReadinessController);\n      health = await module.resolve&lt;HealthCheckService&gt;(HealthCheckService);\n      http = await module.resolve&lt;HttpHealthIndicator&gt;(HttpHealthIndicator as any);\n      typeOrm = await module.resolve&lt;TypeOrmHealthIndicator&gt;(TypeOrmHealthIndicator);\n      redis = await module.resolve&lt;MicroserviceHealthIndicator&gt;(MicroserviceHealthIndicator);\n    });\n\n    it(&#x27;should be defined with extend config&#x27;, () =&gt; {\n      expect(controller).toBeDefined();\n    });\n\n    it(&#x27;should be return up services with extend config&#x27;, async () =&gt; {\n      http.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      typeOrm.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      redis.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      health.check = jest.fn().mockImplementation(() =&gt; mockExpectReadiness);\n\n      const readinessData = await controller.check();\n      expect(readinessData).toEqual(mockExpectReadiness);\n    });\n  });\n\n  describe(&#x27;Ready controller - simple config&#x27;, () =&gt; {\n    let controller: ReadinessController;\n    let health: HealthCheckService;\n    let http: HttpHealthIndicator;\n    let typeOrm: TypeOrmHealthIndicator;\n    let redis: MicroserviceHealthIndicator;\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [TerminusModule, HttpModule],\n        controllers: [ReadinessController],\n        providers: [\n          {\n            provide: CONFIG_OPTIONS,\n            useValue: simpleConfig,\n          },\n        ],\n      }).compile();\n\n      controller = module.get&lt;ReadinessController&gt;(ReadinessController);\n      health = await module.resolve&lt;HealthCheckService&gt;(HealthCheckService);\n      http = await module.resolve&lt;HttpHealthIndicator&gt;(HttpHealthIndicator as any);\n      typeOrm = await module.resolve&lt;TypeOrmHealthIndicator&gt;(TypeOrmHealthIndicator);\n      redis = await module.resolve&lt;MicroserviceHealthIndicator&gt;(MicroserviceHealthIndicator);\n    });\n\n    it(&#x27;should be defined with simple config&#x27;, () =&gt; {\n      expect(controller).toBeDefined();\n    });\n\n    it(&#x27;should be return up services with simple config&#x27;, async () =&gt; {\n      http.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      typeOrm.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      redis.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      health.check = jest.fn().mockImplementation(() =&gt; mockExpectReadiness);\n\n      const readinessData = await controller.check();\n      expect(readinessData).toEqual(mockExpectReadiness);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e16002b4-8452-459d-bc34-c8de7786309a&quot;,&quot;parentUUID&quot;:&quot;cb2d6453-56ce-4c60-bd04-f382477fd87a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Health &gt; Ready controller - extend config &gt; should be return up services with extend config&quot;,&quot;title&quot;:&quot;Health &gt; Ready controller - extend config &gt; should be return up services with extend config&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:6,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { HttpModule } from &#x27;@nestjs/axios&#x27;;\nimport {\n  HealthCheckService,\n  HttpHealthIndicator,\n  TerminusModule,\n  TypeOrmHealthIndicator,\n  MicroserviceHealthIndicator,\n} from &#x27;@nestjs/terminus&#x27;;\n\nimport { ReadinessController } from &#x27;../health/controllers/readiness.controller&#x27;;\nimport { CONFIG_OPTIONS } from &#x27;../health/constants&#x27;;\n\nconst mockedConfig = {\n  services: {\n    myService: {\n      url: &#x27;http://localhost:8082&#x27;,\n      timeout: 3000,\n    },\n    demoApi: {\n      url: &#x27;https://nestjs-starter.up.railway.app&#x27;,\n      timeout: 3000,\n      healthPath: &#x27;/v1/health/liveness&#x27;,\n    },\n  },\n  database: {\n    typeorm: {\n      type: &#x27;postgres&#x27;,\n    },\n  },\n  redis: {\n    host: &#x27;localhost&#x27;,\n    port: 6379,\n  },\n  elasticsearch: {\n    name: &#x27;test-app&#x27;,\n    node: &#x27;http://localhost:9200&#x27;,\n  },\n  camunda: {\n    baseUrl: &#x27;http://localhost:8080/engine-rest&#x27;,\n  },\n};\n\nconst mockExpectReadiness = {\n  status: &#x27;ok&#x27;,\n  info: {\n    myService: {\n      status: &#x27;up&#x27;,\n    },\n    typeOrm: {\n      status: &#x27;up&#x27;,\n    },\n    redis: {\n      status: &#x27;up&#x27;,\n    },\n    elasticsearch: {\n      status: &#x27;up&#x27;,\n    },\n    camunda: {\n      status: &#x27;up&#x27;,\n    },\n  },\n  error: {},\n  details: {\n    myService: {\n      status: &#x27;up&#x27;,\n    },\n    typeOrm: {\n      status: &#x27;up&#x27;,\n    },\n    redis: {\n      status: &#x27;up&#x27;,\n    },\n    elasticsearch: {\n      status: &#x27;up&#x27;,\n    },\n    camunda: {\n      status: &#x27;up&#x27;,\n    },\n  },\n};\n\nconst mockExpectReadinessDown = {\n  myService: {\n    status: &#x27;down&#x27;,\n    message: &#x27;connect ECONNREFUSED 127.0.0.1:8082&#x27;,\n  },\n};\n\nconst simpleConfig = {\n  services: {\n    myService: { url: &#x27;http://localhost:8082&#x27; },\n  },\n};\n\ndescribe(&#x27;Health&#x27;, () =&gt; {\n  describe(&#x27;Ready controller - extend config&#x27;, () =&gt; {\n    let controller: ReadinessController;\n    let health: HealthCheckService;\n    let http: HttpHealthIndicator;\n    let typeOrm: TypeOrmHealthIndicator;\n    let redis: MicroserviceHealthIndicator;\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [TerminusModule, HttpModule],\n        controllers: [ReadinessController],\n        providers: [\n          {\n            provide: CONFIG_OPTIONS,\n            useValue: mockedConfig,\n          },\n        ],\n      }).compile();\n\n      controller = module.get&lt;ReadinessController&gt;(ReadinessController);\n      health = await module.resolve&lt;HealthCheckService&gt;(HealthCheckService);\n      http = await module.resolve&lt;HttpHealthIndicator&gt;(HttpHealthIndicator as any);\n      typeOrm = await module.resolve&lt;TypeOrmHealthIndicator&gt;(TypeOrmHealthIndicator);\n      redis = await module.resolve&lt;MicroserviceHealthIndicator&gt;(MicroserviceHealthIndicator);\n    });\n\n    it(&#x27;should be defined with extend config&#x27;, () =&gt; {\n      expect(controller).toBeDefined();\n    });\n\n    it(&#x27;should be return up services with extend config&#x27;, async () =&gt; {\n      http.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      typeOrm.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      redis.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      health.check = jest.fn().mockImplementation(() =&gt; mockExpectReadiness);\n\n      const readinessData = await controller.check();\n      expect(readinessData).toEqual(mockExpectReadiness);\n    });\n  });\n\n  describe(&#x27;Ready controller - simple config&#x27;, () =&gt; {\n    let controller: ReadinessController;\n    let health: HealthCheckService;\n    let http: HttpHealthIndicator;\n    let typeOrm: TypeOrmHealthIndicator;\n    let redis: MicroserviceHealthIndicator;\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [TerminusModule, HttpModule],\n        controllers: [ReadinessController],\n        providers: [\n          {\n            provide: CONFIG_OPTIONS,\n            useValue: simpleConfig,\n          },\n        ],\n      }).compile();\n\n      controller = module.get&lt;ReadinessController&gt;(ReadinessController);\n      health = await module.resolve&lt;HealthCheckService&gt;(HealthCheckService);\n      http = await module.resolve&lt;HttpHealthIndicator&gt;(HttpHealthIndicator as any);\n      typeOrm = await module.resolve&lt;TypeOrmHealthIndicator&gt;(TypeOrmHealthIndicator);\n      redis = await module.resolve&lt;MicroserviceHealthIndicator&gt;(MicroserviceHealthIndicator);\n    });\n\n    it(&#x27;should be defined with simple config&#x27;, () =&gt; {\n      expect(controller).toBeDefined();\n    });\n\n    it(&#x27;should be return up services with simple config&#x27;, async () =&gt; {\n      http.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      typeOrm.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      redis.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      health.check = jest.fn().mockImplementation(() =&gt; mockExpectReadiness);\n\n      const readinessData = await controller.check();\n      expect(readinessData).toEqual(mockExpectReadiness);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f98ed6d1-8348-468b-ae68-4c067c8d1ac3&quot;,&quot;parentUUID&quot;:&quot;cb2d6453-56ce-4c60-bd04-f382477fd87a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Health &gt; Ready controller - simple config &gt; should be defined with simple config&quot;,&quot;title&quot;:&quot;Health &gt; Ready controller - simple config &gt; should be defined with simple config&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { HttpModule } from &#x27;@nestjs/axios&#x27;;\nimport {\n  HealthCheckService,\n  HttpHealthIndicator,\n  TerminusModule,\n  TypeOrmHealthIndicator,\n  MicroserviceHealthIndicator,\n} from &#x27;@nestjs/terminus&#x27;;\n\nimport { ReadinessController } from &#x27;../health/controllers/readiness.controller&#x27;;\nimport { CONFIG_OPTIONS } from &#x27;../health/constants&#x27;;\n\nconst mockedConfig = {\n  services: {\n    myService: {\n      url: &#x27;http://localhost:8082&#x27;,\n      timeout: 3000,\n    },\n    demoApi: {\n      url: &#x27;https://nestjs-starter.up.railway.app&#x27;,\n      timeout: 3000,\n      healthPath: &#x27;/v1/health/liveness&#x27;,\n    },\n  },\n  database: {\n    typeorm: {\n      type: &#x27;postgres&#x27;,\n    },\n  },\n  redis: {\n    host: &#x27;localhost&#x27;,\n    port: 6379,\n  },\n  elasticsearch: {\n    name: &#x27;test-app&#x27;,\n    node: &#x27;http://localhost:9200&#x27;,\n  },\n  camunda: {\n    baseUrl: &#x27;http://localhost:8080/engine-rest&#x27;,\n  },\n};\n\nconst mockExpectReadiness = {\n  status: &#x27;ok&#x27;,\n  info: {\n    myService: {\n      status: &#x27;up&#x27;,\n    },\n    typeOrm: {\n      status: &#x27;up&#x27;,\n    },\n    redis: {\n      status: &#x27;up&#x27;,\n    },\n    elasticsearch: {\n      status: &#x27;up&#x27;,\n    },\n    camunda: {\n      status: &#x27;up&#x27;,\n    },\n  },\n  error: {},\n  details: {\n    myService: {\n      status: &#x27;up&#x27;,\n    },\n    typeOrm: {\n      status: &#x27;up&#x27;,\n    },\n    redis: {\n      status: &#x27;up&#x27;,\n    },\n    elasticsearch: {\n      status: &#x27;up&#x27;,\n    },\n    camunda: {\n      status: &#x27;up&#x27;,\n    },\n  },\n};\n\nconst mockExpectReadinessDown = {\n  myService: {\n    status: &#x27;down&#x27;,\n    message: &#x27;connect ECONNREFUSED 127.0.0.1:8082&#x27;,\n  },\n};\n\nconst simpleConfig = {\n  services: {\n    myService: { url: &#x27;http://localhost:8082&#x27; },\n  },\n};\n\ndescribe(&#x27;Health&#x27;, () =&gt; {\n  describe(&#x27;Ready controller - extend config&#x27;, () =&gt; {\n    let controller: ReadinessController;\n    let health: HealthCheckService;\n    let http: HttpHealthIndicator;\n    let typeOrm: TypeOrmHealthIndicator;\n    let redis: MicroserviceHealthIndicator;\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [TerminusModule, HttpModule],\n        controllers: [ReadinessController],\n        providers: [\n          {\n            provide: CONFIG_OPTIONS,\n            useValue: mockedConfig,\n          },\n        ],\n      }).compile();\n\n      controller = module.get&lt;ReadinessController&gt;(ReadinessController);\n      health = await module.resolve&lt;HealthCheckService&gt;(HealthCheckService);\n      http = await module.resolve&lt;HttpHealthIndicator&gt;(HttpHealthIndicator as any);\n      typeOrm = await module.resolve&lt;TypeOrmHealthIndicator&gt;(TypeOrmHealthIndicator);\n      redis = await module.resolve&lt;MicroserviceHealthIndicator&gt;(MicroserviceHealthIndicator);\n    });\n\n    it(&#x27;should be defined with extend config&#x27;, () =&gt; {\n      expect(controller).toBeDefined();\n    });\n\n    it(&#x27;should be return up services with extend config&#x27;, async () =&gt; {\n      http.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      typeOrm.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      redis.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      health.check = jest.fn().mockImplementation(() =&gt; mockExpectReadiness);\n\n      const readinessData = await controller.check();\n      expect(readinessData).toEqual(mockExpectReadiness);\n    });\n  });\n\n  describe(&#x27;Ready controller - simple config&#x27;, () =&gt; {\n    let controller: ReadinessController;\n    let health: HealthCheckService;\n    let http: HttpHealthIndicator;\n    let typeOrm: TypeOrmHealthIndicator;\n    let redis: MicroserviceHealthIndicator;\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [TerminusModule, HttpModule],\n        controllers: [ReadinessController],\n        providers: [\n          {\n            provide: CONFIG_OPTIONS,\n            useValue: simpleConfig,\n          },\n        ],\n      }).compile();\n\n      controller = module.get&lt;ReadinessController&gt;(ReadinessController);\n      health = await module.resolve&lt;HealthCheckService&gt;(HealthCheckService);\n      http = await module.resolve&lt;HttpHealthIndicator&gt;(HttpHealthIndicator as any);\n      typeOrm = await module.resolve&lt;TypeOrmHealthIndicator&gt;(TypeOrmHealthIndicator);\n      redis = await module.resolve&lt;MicroserviceHealthIndicator&gt;(MicroserviceHealthIndicator);\n    });\n\n    it(&#x27;should be defined with simple config&#x27;, () =&gt; {\n      expect(controller).toBeDefined();\n    });\n\n    it(&#x27;should be return up services with simple config&#x27;, async () =&gt; {\n      http.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      typeOrm.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      redis.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      health.check = jest.fn().mockImplementation(() =&gt; mockExpectReadiness);\n\n      const readinessData = await controller.check();\n      expect(readinessData).toEqual(mockExpectReadiness);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3eb85d7b-dc99-4629-b52d-b8c6c9733284&quot;,&quot;parentUUID&quot;:&quot;cb2d6453-56ce-4c60-bd04-f382477fd87a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Health &gt; Ready controller - simple config &gt; should be return up services with simple config&quot;,&quot;title&quot;:&quot;Health &gt; Ready controller - simple config &gt; should be return up services with simple config&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { HttpModule } from &#x27;@nestjs/axios&#x27;;\nimport {\n  HealthCheckService,\n  HttpHealthIndicator,\n  TerminusModule,\n  TypeOrmHealthIndicator,\n  MicroserviceHealthIndicator,\n} from &#x27;@nestjs/terminus&#x27;;\n\nimport { ReadinessController } from &#x27;../health/controllers/readiness.controller&#x27;;\nimport { CONFIG_OPTIONS } from &#x27;../health/constants&#x27;;\n\nconst mockedConfig = {\n  services: {\n    myService: {\n      url: &#x27;http://localhost:8082&#x27;,\n      timeout: 3000,\n    },\n    demoApi: {\n      url: &#x27;https://nestjs-starter.up.railway.app&#x27;,\n      timeout: 3000,\n      healthPath: &#x27;/v1/health/liveness&#x27;,\n    },\n  },\n  database: {\n    typeorm: {\n      type: &#x27;postgres&#x27;,\n    },\n  },\n  redis: {\n    host: &#x27;localhost&#x27;,\n    port: 6379,\n  },\n  elasticsearch: {\n    name: &#x27;test-app&#x27;,\n    node: &#x27;http://localhost:9200&#x27;,\n  },\n  camunda: {\n    baseUrl: &#x27;http://localhost:8080/engine-rest&#x27;,\n  },\n};\n\nconst mockExpectReadiness = {\n  status: &#x27;ok&#x27;,\n  info: {\n    myService: {\n      status: &#x27;up&#x27;,\n    },\n    typeOrm: {\n      status: &#x27;up&#x27;,\n    },\n    redis: {\n      status: &#x27;up&#x27;,\n    },\n    elasticsearch: {\n      status: &#x27;up&#x27;,\n    },\n    camunda: {\n      status: &#x27;up&#x27;,\n    },\n  },\n  error: {},\n  details: {\n    myService: {\n      status: &#x27;up&#x27;,\n    },\n    typeOrm: {\n      status: &#x27;up&#x27;,\n    },\n    redis: {\n      status: &#x27;up&#x27;,\n    },\n    elasticsearch: {\n      status: &#x27;up&#x27;,\n    },\n    camunda: {\n      status: &#x27;up&#x27;,\n    },\n  },\n};\n\nconst mockExpectReadinessDown = {\n  myService: {\n    status: &#x27;down&#x27;,\n    message: &#x27;connect ECONNREFUSED 127.0.0.1:8082&#x27;,\n  },\n};\n\nconst simpleConfig = {\n  services: {\n    myService: { url: &#x27;http://localhost:8082&#x27; },\n  },\n};\n\ndescribe(&#x27;Health&#x27;, () =&gt; {\n  describe(&#x27;Ready controller - extend config&#x27;, () =&gt; {\n    let controller: ReadinessController;\n    let health: HealthCheckService;\n    let http: HttpHealthIndicator;\n    let typeOrm: TypeOrmHealthIndicator;\n    let redis: MicroserviceHealthIndicator;\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [TerminusModule, HttpModule],\n        controllers: [ReadinessController],\n        providers: [\n          {\n            provide: CONFIG_OPTIONS,\n            useValue: mockedConfig,\n          },\n        ],\n      }).compile();\n\n      controller = module.get&lt;ReadinessController&gt;(ReadinessController);\n      health = await module.resolve&lt;HealthCheckService&gt;(HealthCheckService);\n      http = await module.resolve&lt;HttpHealthIndicator&gt;(HttpHealthIndicator as any);\n      typeOrm = await module.resolve&lt;TypeOrmHealthIndicator&gt;(TypeOrmHealthIndicator);\n      redis = await module.resolve&lt;MicroserviceHealthIndicator&gt;(MicroserviceHealthIndicator);\n    });\n\n    it(&#x27;should be defined with extend config&#x27;, () =&gt; {\n      expect(controller).toBeDefined();\n    });\n\n    it(&#x27;should be return up services with extend config&#x27;, async () =&gt; {\n      http.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      typeOrm.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      redis.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      health.check = jest.fn().mockImplementation(() =&gt; mockExpectReadiness);\n\n      const readinessData = await controller.check();\n      expect(readinessData).toEqual(mockExpectReadiness);\n    });\n  });\n\n  describe(&#x27;Ready controller - simple config&#x27;, () =&gt; {\n    let controller: ReadinessController;\n    let health: HealthCheckService;\n    let http: HttpHealthIndicator;\n    let typeOrm: TypeOrmHealthIndicator;\n    let redis: MicroserviceHealthIndicator;\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [TerminusModule, HttpModule],\n        controllers: [ReadinessController],\n        providers: [\n          {\n            provide: CONFIG_OPTIONS,\n            useValue: simpleConfig,\n          },\n        ],\n      }).compile();\n\n      controller = module.get&lt;ReadinessController&gt;(ReadinessController);\n      health = await module.resolve&lt;HealthCheckService&gt;(HealthCheckService);\n      http = await module.resolve&lt;HttpHealthIndicator&gt;(HttpHealthIndicator as any);\n      typeOrm = await module.resolve&lt;TypeOrmHealthIndicator&gt;(TypeOrmHealthIndicator);\n      redis = await module.resolve&lt;MicroserviceHealthIndicator&gt;(MicroserviceHealthIndicator);\n    });\n\n    it(&#x27;should be defined with simple config&#x27;, () =&gt; {\n      expect(controller).toBeDefined();\n    });\n\n    it(&#x27;should be return up services with simple config&#x27;, async () =&gt; {\n      http.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      typeOrm.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      redis.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      health.check = jest.fn().mockImplementation(() =&gt; mockExpectReadiness);\n\n      const readinessData = await controller.check();\n      expect(readinessData).toEqual(mockExpectReadiness);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6faf44be-0201-4a9b-949d-78f77e75958b&quot;,&quot;parentUUID&quot;:&quot;cb2d6453-56ce-4c60-bd04-f382477fd87a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;HealthModule &gt; should be define&quot;,&quot;title&quot;:&quot;HealthModule &gt; should be define&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:506,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport { config } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\n\nimport { HealthModule } from &#x27;../health/health.module&#x27;;\nimport { LivenessController } from &#x27;../health/controllers/liveness.controller&#x27;;\nimport { ReadinessController } from &#x27;../health/controllers/readiness.controller&#x27;;\n\ndescribe(&#x27;HealthModule&#x27;, () =&gt; {\n  let app: INestApplication;\n  let livenessController: LivenessController;\n  let readinessController: ReadinessController;\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HealthModule,\n      ],\n    }).compile();\n\n    app = module.createNestApplication();\n    livenessController = module.get&lt;LivenessController&gt;(LivenessController);\n    readinessController = module.get&lt;ReadinessController&gt;(ReadinessController);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await Promise.all([app.close()]);\n  });\n\n  it(&#x27;should be define&#x27;, async () =&gt; {\n    expect(app).toBeDefined();\n  });\n\n  it(&#x27;should be return status up&#x27;, async () =&gt; {\n    expect(livenessController.getLiveness()).toEqual({ status: &#x27;up&#x27; });\n  });\n\n  it(&#x27;should be return readiness services&#x27;, async () =&gt; {\n    const result = await readinessController.check();\n    expect(result).toHaveProperty(&#x27;details&#x27;);\n    expect(result).toHaveProperty(&#x27;error&#x27;);\n    expect(result).toHaveProperty(&#x27;info&#x27;);\n    expect(result).toHaveProperty(&#x27;status&#x27;);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3d01cbb9-57b1-46a2-a35e-24d78b23aa47&quot;,&quot;parentUUID&quot;:&quot;cb2d6453-56ce-4c60-bd04-f382477fd87a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;HealthModule &gt; should be return status up&quot;,&quot;title&quot;:&quot;HealthModule &gt; should be return status up&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport { config } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\n\nimport { HealthModule } from &#x27;../health/health.module&#x27;;\nimport { LivenessController } from &#x27;../health/controllers/liveness.controller&#x27;;\nimport { ReadinessController } from &#x27;../health/controllers/readiness.controller&#x27;;\n\ndescribe(&#x27;HealthModule&#x27;, () =&gt; {\n  let app: INestApplication;\n  let livenessController: LivenessController;\n  let readinessController: ReadinessController;\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HealthModule,\n      ],\n    }).compile();\n\n    app = module.createNestApplication();\n    livenessController = module.get&lt;LivenessController&gt;(LivenessController);\n    readinessController = module.get&lt;ReadinessController&gt;(ReadinessController);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await Promise.all([app.close()]);\n  });\n\n  it(&#x27;should be define&#x27;, async () =&gt; {\n    expect(app).toBeDefined();\n  });\n\n  it(&#x27;should be return status up&#x27;, async () =&gt; {\n    expect(livenessController.getLiveness()).toEqual({ status: &#x27;up&#x27; });\n  });\n\n  it(&#x27;should be return readiness services&#x27;, async () =&gt; {\n    const result = await readinessController.check();\n    expect(result).toHaveProperty(&#x27;details&#x27;);\n    expect(result).toHaveProperty(&#x27;error&#x27;);\n    expect(result).toHaveProperty(&#x27;info&#x27;);\n    expect(result).toHaveProperty(&#x27;status&#x27;);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;aab22efc-38b4-44a4-a650-c7431222cfb6&quot;,&quot;parentUUID&quot;:&quot;cb2d6453-56ce-4c60-bd04-f382477fd87a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;HealthModule &gt; should be return readiness services&quot;,&quot;title&quot;:&quot;HealthModule &gt; should be return readiness services&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:427,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport { config } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\n\nimport { HealthModule } from &#x27;../health/health.module&#x27;;\nimport { LivenessController } from &#x27;../health/controllers/liveness.controller&#x27;;\nimport { ReadinessController } from &#x27;../health/controllers/readiness.controller&#x27;;\n\ndescribe(&#x27;HealthModule&#x27;, () =&gt; {\n  let app: INestApplication;\n  let livenessController: LivenessController;\n  let readinessController: ReadinessController;\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HealthModule,\n      ],\n    }).compile();\n\n    app = module.createNestApplication();\n    livenessController = module.get&lt;LivenessController&gt;(LivenessController);\n    readinessController = module.get&lt;ReadinessController&gt;(ReadinessController);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await Promise.all([app.close()]);\n  });\n\n  it(&#x27;should be define&#x27;, async () =&gt; {\n    expect(app).toBeDefined();\n  });\n\n  it(&#x27;should be return status up&#x27;, async () =&gt; {\n    expect(livenessController.getLiveness()).toEqual({ status: &#x27;up&#x27; });\n  });\n\n  it(&#x27;should be return readiness services&#x27;, async () =&gt; {\n    const result = await readinessController.check();\n    expect(result).toHaveProperty(&#x27;details&#x27;);\n    expect(result).toHaveProperty(&#x27;error&#x27;);\n    expect(result).toHaveProperty(&#x27;info&#x27;);\n    expect(result).toHaveProperty(&#x27;status&#x27;);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a5b9b8e7-69f7-4241-9799-476af3bd819c&quot;,&quot;parentUUID&quot;:&quot;cb2d6453-56ce-4c60-bd04-f382477fd87a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Health - Live controller &gt; should be defined&quot;,&quot;title&quot;:&quot;Health - Live controller &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { LivenessController } from &#x27;../health/controllers/liveness.controller&#x27;;\n\ndescribe(&#x27;Health - Live controller&#x27;, () =&gt; {\n  let controller: LivenessController;\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      controllers: [LivenessController],\n    }).compile();\n\n    controller = module.get&lt;LivenessController&gt;(LivenessController);\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(controller).toBeDefined();\n  });\n\n  it(&#x27;should be return up liveness&#x27;, () =&gt; {\n    expect(controller.getLiveness()).toEqual({ status: &#x27;up&#x27; });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e5af7378-76aa-47bd-8e2c-8678f5287c21&quot;,&quot;parentUUID&quot;:&quot;cb2d6453-56ce-4c60-bd04-f382477fd87a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Health - Live controller &gt; should be return up liveness&quot;,&quot;title&quot;:&quot;Health - Live controller &gt; should be return up liveness&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { LivenessController } from &#x27;../health/controllers/liveness.controller&#x27;;\n\ndescribe(&#x27;Health - Live controller&#x27;, () =&gt; {\n  let controller: LivenessController;\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      controllers: [LivenessController],\n    }).compile();\n\n    controller = module.get&lt;LivenessController&gt;(LivenessController);\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(controller).toBeDefined();\n  });\n\n  it(&#x27;should be return up liveness&#x27;, () =&gt; {\n    expect(controller.getLiveness()).toEqual({ status: &#x27;up&#x27; });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2025b2bf-2c75-4001-bcb6-460717141069&quot;,&quot;parentUUID&quot;:&quot;cb2d6453-56ce-4c60-bd04-f382477fd87a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;healthConstants &gt; should be return exclude to prefix global&quot;,&quot;title&quot;:&quot;healthConstants &gt; should be return exclude to prefix global&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { RequestMethod } from &#x27;@nestjs/common&#x27;;\nimport { controllersExcludes } from &#x27;../health/constants&#x27;;\n\ndescribe(&#x27;healthConstants&#x27;, () =&gt; {\n  it(&#x27;should be return exclude to prefix global&#x27;, async () =&gt; {\n    expect(controllersExcludes).toEqual(expect.any(Array));\n    expect(controllersExcludes).toMatchObject([\n      {\n        path: &#x27;/health/liveness&#x27;,\n        method: RequestMethod.GET,\n      },\n      {\n        path: &#x27;/health/readiness&#x27;,\n        method: RequestMethod.GET,\n      },\n    ]);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;40b4bc7a-027b-48a1-a38b-4e443d63702c&quot;,&quot;parentUUID&quot;:&quot;cb2d6453-56ce-4c60-bd04-f382477fd87a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;e16002b4-8452-459d-bc34-c8de7786309a&quot;,&quot;f98ed6d1-8348-468b-ae68-4c067c8d1ac3&quot;,&quot;3eb85d7b-dc99-4629-b52d-b8c6c9733284&quot;,&quot;6faf44be-0201-4a9b-949d-78f77e75958b&quot;,&quot;3d01cbb9-57b1-46a2-a35e-24d78b23aa47&quot;,&quot;aab22efc-38b4-44a4-a650-c7431222cfb6&quot;,&quot;a5b9b8e7-69f7-4241-9799-476af3bd819c&quot;,&quot;e5af7378-76aa-47bd-8e2c-8678f5287c21&quot;,&quot;2025b2bf-2c75-4001-bcb6-460717141069&quot;,&quot;40b4bc7a-027b-48a1-a38b-4e443d63702c&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:1739,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:5000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:5000},{&quot;uuid&quot;:&quot;10759335-075c-4edf-b9d1-64775e32ed88&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/http-client&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;e4e47e1f-5a40-4eb8-851c-7904e9c78814&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/http-client&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;fullTitle&quot;:&quot;HttpService &gt; should be defined&quot;,&quot;title&quot;:&quot;HttpService &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:229,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule, ConfigService } from &#x27;@nestjs/config&#x27;;\n\nimport { HttpClientService } from &#x27;../http/services/httpClient.service&#x27;;\nimport { HttpClientModule } from &#x27;../http/httpClient.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\n\nconst API_NESTJS_STARTER = &#x27;https://jsonplaceholder.typicode.com&#x27;;\n\nconst mockRequestBody = {\n  userId: 1,\n  id: 1,\n  title: &#x27;sunt aut facere repellat provident occaecati excepturi optio reprehenderit&#x27;,\n  body: &#x27;quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto&#x27;,\n};\n\ndescribe(&#x27;HttpService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let service: HttpClientService;\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HttpClientModule.registerAsync({\n          imports: [ConfigModule],\n          useFactory: async (configService: ConfigService) =&gt;\n            configService.get(&#x27;config.httpOptions&#x27;),\n          inject: [ConfigService],\n        }),\n      ],\n    }).compile();\n    app = module.createNestApplication();\n    await app.init;\n    service = module.get&lt;HttpClientService&gt;(HttpClientService);\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(service).toBeDefined();\n    expect(service).toBeInstanceOf(HttpClientService);\n    expect(service.axiosRef).not.toBeNull();\n  });\n\n  it(&#x27;should be return status 200 - request&#x27;, async () =&gt; {\n    const { status, data } = await service.request({\n      url: `${API_NESTJS_STARTER}/posts`,\n      method: &#x27;GET&#x27;,\n    });\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 200 - get&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 201 - post&#x27;, async () =&gt; {\n    const { status, data } = await service.post(`${API_NESTJS_STARTER}/posts`, {\n      data: mockRequestBody,\n    });\n    expect(status).toBe(201);\n    expect(data).toEqual({\n      ...mockRequestBody,\n      id: 101,\n    });\n  });\n\n  it(&#x27;should be return status 200 - get by id&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts/1`);\n    expect(status).toBe(200);\n    expect(data).toEqual(mockRequestBody);\n  });\n\n  it(&#x27;should be return status 200 - put&#x27;, async () =&gt; {\n    const { status, data } = await service.put(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - delete&#x27;, async () =&gt; {\n    const { status, data } = await service.delete(`${API_NESTJS_STARTER}/posts/2`);\n    expect(status).toBe(200);\n    expect(data).toEqual({});\n  });\n\n  it(&#x27;should be return status 200 - patch&#x27;, async () =&gt; {\n    const { status, data } = await service.patch(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - head&#x27;, async () =&gt; {\n    const { status, headers } = await service.head(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(headers).toHaveProperty(&#x27;etag&#x27;);\n  });\n\n  it(&#x27;should be return error&#x27;, async () =&gt; {\n    try {\n      const { data } = await service.get(`${API_NESTJS_STARTER}/postss`);\n      expect(data).toBe(200);\n    } catch (error) {\n      expect(error.response.status).toBe(404);\n      expect(error.message).toBe(&#x27;Request failed with status code 404&#x27;);\n    }\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;01392ef8-c46d-416e-8b14-8b488a37891b&quot;,&quot;parentUUID&quot;:&quot;e4e47e1f-5a40-4eb8-851c-7904e9c78814&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;HttpService &gt; should be return status 200 - request&quot;,&quot;title&quot;:&quot;HttpService &gt; should be return status 200 - request&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:328,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule, ConfigService } from &#x27;@nestjs/config&#x27;;\n\nimport { HttpClientService } from &#x27;../http/services/httpClient.service&#x27;;\nimport { HttpClientModule } from &#x27;../http/httpClient.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\n\nconst API_NESTJS_STARTER = &#x27;https://jsonplaceholder.typicode.com&#x27;;\n\nconst mockRequestBody = {\n  userId: 1,\n  id: 1,\n  title: &#x27;sunt aut facere repellat provident occaecati excepturi optio reprehenderit&#x27;,\n  body: &#x27;quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto&#x27;,\n};\n\ndescribe(&#x27;HttpService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let service: HttpClientService;\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HttpClientModule.registerAsync({\n          imports: [ConfigModule],\n          useFactory: async (configService: ConfigService) =&gt;\n            configService.get(&#x27;config.httpOptions&#x27;),\n          inject: [ConfigService],\n        }),\n      ],\n    }).compile();\n    app = module.createNestApplication();\n    await app.init;\n    service = module.get&lt;HttpClientService&gt;(HttpClientService);\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(service).toBeDefined();\n    expect(service).toBeInstanceOf(HttpClientService);\n    expect(service.axiosRef).not.toBeNull();\n  });\n\n  it(&#x27;should be return status 200 - request&#x27;, async () =&gt; {\n    const { status, data } = await service.request({\n      url: `${API_NESTJS_STARTER}/posts`,\n      method: &#x27;GET&#x27;,\n    });\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 200 - get&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 201 - post&#x27;, async () =&gt; {\n    const { status, data } = await service.post(`${API_NESTJS_STARTER}/posts`, {\n      data: mockRequestBody,\n    });\n    expect(status).toBe(201);\n    expect(data).toEqual({\n      ...mockRequestBody,\n      id: 101,\n    });\n  });\n\n  it(&#x27;should be return status 200 - get by id&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts/1`);\n    expect(status).toBe(200);\n    expect(data).toEqual(mockRequestBody);\n  });\n\n  it(&#x27;should be return status 200 - put&#x27;, async () =&gt; {\n    const { status, data } = await service.put(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - delete&#x27;, async () =&gt; {\n    const { status, data } = await service.delete(`${API_NESTJS_STARTER}/posts/2`);\n    expect(status).toBe(200);\n    expect(data).toEqual({});\n  });\n\n  it(&#x27;should be return status 200 - patch&#x27;, async () =&gt; {\n    const { status, data } = await service.patch(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - head&#x27;, async () =&gt; {\n    const { status, headers } = await service.head(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(headers).toHaveProperty(&#x27;etag&#x27;);\n  });\n\n  it(&#x27;should be return error&#x27;, async () =&gt; {\n    try {\n      const { data } = await service.get(`${API_NESTJS_STARTER}/postss`);\n      expect(data).toBe(200);\n    } catch (error) {\n      expect(error.response.status).toBe(404);\n      expect(error.message).toBe(&#x27;Request failed with status code 404&#x27;);\n    }\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e15cdea4-97a4-4baf-9b9b-cf0cd24b13df&quot;,&quot;parentUUID&quot;:&quot;e4e47e1f-5a40-4eb8-851c-7904e9c78814&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;HttpService &gt; should be return status 200 - get&quot;,&quot;title&quot;:&quot;HttpService &gt; should be return status 200 - get&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:94,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule, ConfigService } from &#x27;@nestjs/config&#x27;;\n\nimport { HttpClientService } from &#x27;../http/services/httpClient.service&#x27;;\nimport { HttpClientModule } from &#x27;../http/httpClient.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\n\nconst API_NESTJS_STARTER = &#x27;https://jsonplaceholder.typicode.com&#x27;;\n\nconst mockRequestBody = {\n  userId: 1,\n  id: 1,\n  title: &#x27;sunt aut facere repellat provident occaecati excepturi optio reprehenderit&#x27;,\n  body: &#x27;quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto&#x27;,\n};\n\ndescribe(&#x27;HttpService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let service: HttpClientService;\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HttpClientModule.registerAsync({\n          imports: [ConfigModule],\n          useFactory: async (configService: ConfigService) =&gt;\n            configService.get(&#x27;config.httpOptions&#x27;),\n          inject: [ConfigService],\n        }),\n      ],\n    }).compile();\n    app = module.createNestApplication();\n    await app.init;\n    service = module.get&lt;HttpClientService&gt;(HttpClientService);\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(service).toBeDefined();\n    expect(service).toBeInstanceOf(HttpClientService);\n    expect(service.axiosRef).not.toBeNull();\n  });\n\n  it(&#x27;should be return status 200 - request&#x27;, async () =&gt; {\n    const { status, data } = await service.request({\n      url: `${API_NESTJS_STARTER}/posts`,\n      method: &#x27;GET&#x27;,\n    });\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 200 - get&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 201 - post&#x27;, async () =&gt; {\n    const { status, data } = await service.post(`${API_NESTJS_STARTER}/posts`, {\n      data: mockRequestBody,\n    });\n    expect(status).toBe(201);\n    expect(data).toEqual({\n      ...mockRequestBody,\n      id: 101,\n    });\n  });\n\n  it(&#x27;should be return status 200 - get by id&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts/1`);\n    expect(status).toBe(200);\n    expect(data).toEqual(mockRequestBody);\n  });\n\n  it(&#x27;should be return status 200 - put&#x27;, async () =&gt; {\n    const { status, data } = await service.put(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - delete&#x27;, async () =&gt; {\n    const { status, data } = await service.delete(`${API_NESTJS_STARTER}/posts/2`);\n    expect(status).toBe(200);\n    expect(data).toEqual({});\n  });\n\n  it(&#x27;should be return status 200 - patch&#x27;, async () =&gt; {\n    const { status, data } = await service.patch(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - head&#x27;, async () =&gt; {\n    const { status, headers } = await service.head(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(headers).toHaveProperty(&#x27;etag&#x27;);\n  });\n\n  it(&#x27;should be return error&#x27;, async () =&gt; {\n    try {\n      const { data } = await service.get(`${API_NESTJS_STARTER}/postss`);\n      expect(data).toBe(200);\n    } catch (error) {\n      expect(error.response.status).toBe(404);\n      expect(error.message).toBe(&#x27;Request failed with status code 404&#x27;);\n    }\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c4d6a6c7-e872-4647-b4f1-90aacb1421fd&quot;,&quot;parentUUID&quot;:&quot;e4e47e1f-5a40-4eb8-851c-7904e9c78814&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;HttpService &gt; should be return status 201 - post&quot;,&quot;title&quot;:&quot;HttpService &gt; should be return status 201 - post&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:420,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule, ConfigService } from &#x27;@nestjs/config&#x27;;\n\nimport { HttpClientService } from &#x27;../http/services/httpClient.service&#x27;;\nimport { HttpClientModule } from &#x27;../http/httpClient.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\n\nconst API_NESTJS_STARTER = &#x27;https://jsonplaceholder.typicode.com&#x27;;\n\nconst mockRequestBody = {\n  userId: 1,\n  id: 1,\n  title: &#x27;sunt aut facere repellat provident occaecati excepturi optio reprehenderit&#x27;,\n  body: &#x27;quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto&#x27;,\n};\n\ndescribe(&#x27;HttpService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let service: HttpClientService;\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HttpClientModule.registerAsync({\n          imports: [ConfigModule],\n          useFactory: async (configService: ConfigService) =&gt;\n            configService.get(&#x27;config.httpOptions&#x27;),\n          inject: [ConfigService],\n        }),\n      ],\n    }).compile();\n    app = module.createNestApplication();\n    await app.init;\n    service = module.get&lt;HttpClientService&gt;(HttpClientService);\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(service).toBeDefined();\n    expect(service).toBeInstanceOf(HttpClientService);\n    expect(service.axiosRef).not.toBeNull();\n  });\n\n  it(&#x27;should be return status 200 - request&#x27;, async () =&gt; {\n    const { status, data } = await service.request({\n      url: `${API_NESTJS_STARTER}/posts`,\n      method: &#x27;GET&#x27;,\n    });\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 200 - get&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 201 - post&#x27;, async () =&gt; {\n    const { status, data } = await service.post(`${API_NESTJS_STARTER}/posts`, {\n      data: mockRequestBody,\n    });\n    expect(status).toBe(201);\n    expect(data).toEqual({\n      ...mockRequestBody,\n      id: 101,\n    });\n  });\n\n  it(&#x27;should be return status 200 - get by id&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts/1`);\n    expect(status).toBe(200);\n    expect(data).toEqual(mockRequestBody);\n  });\n\n  it(&#x27;should be return status 200 - put&#x27;, async () =&gt; {\n    const { status, data } = await service.put(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - delete&#x27;, async () =&gt; {\n    const { status, data } = await service.delete(`${API_NESTJS_STARTER}/posts/2`);\n    expect(status).toBe(200);\n    expect(data).toEqual({});\n  });\n\n  it(&#x27;should be return status 200 - patch&#x27;, async () =&gt; {\n    const { status, data } = await service.patch(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - head&#x27;, async () =&gt; {\n    const { status, headers } = await service.head(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(headers).toHaveProperty(&#x27;etag&#x27;);\n  });\n\n  it(&#x27;should be return error&#x27;, async () =&gt; {\n    try {\n      const { data } = await service.get(`${API_NESTJS_STARTER}/postss`);\n      expect(data).toBe(200);\n    } catch (error) {\n      expect(error.response.status).toBe(404);\n      expect(error.message).toBe(&#x27;Request failed with status code 404&#x27;);\n    }\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a85e5925-a1d7-4537-9f67-78b1b6f4a9cf&quot;,&quot;parentUUID&quot;:&quot;e4e47e1f-5a40-4eb8-851c-7904e9c78814&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;HttpService &gt; should be return status 200 - get by id&quot;,&quot;title&quot;:&quot;HttpService &gt; should be return status 200 - get by id&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:75,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule, ConfigService } from &#x27;@nestjs/config&#x27;;\n\nimport { HttpClientService } from &#x27;../http/services/httpClient.service&#x27;;\nimport { HttpClientModule } from &#x27;../http/httpClient.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\n\nconst API_NESTJS_STARTER = &#x27;https://jsonplaceholder.typicode.com&#x27;;\n\nconst mockRequestBody = {\n  userId: 1,\n  id: 1,\n  title: &#x27;sunt aut facere repellat provident occaecati excepturi optio reprehenderit&#x27;,\n  body: &#x27;quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto&#x27;,\n};\n\ndescribe(&#x27;HttpService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let service: HttpClientService;\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HttpClientModule.registerAsync({\n          imports: [ConfigModule],\n          useFactory: async (configService: ConfigService) =&gt;\n            configService.get(&#x27;config.httpOptions&#x27;),\n          inject: [ConfigService],\n        }),\n      ],\n    }).compile();\n    app = module.createNestApplication();\n    await app.init;\n    service = module.get&lt;HttpClientService&gt;(HttpClientService);\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(service).toBeDefined();\n    expect(service).toBeInstanceOf(HttpClientService);\n    expect(service.axiosRef).not.toBeNull();\n  });\n\n  it(&#x27;should be return status 200 - request&#x27;, async () =&gt; {\n    const { status, data } = await service.request({\n      url: `${API_NESTJS_STARTER}/posts`,\n      method: &#x27;GET&#x27;,\n    });\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 200 - get&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 201 - post&#x27;, async () =&gt; {\n    const { status, data } = await service.post(`${API_NESTJS_STARTER}/posts`, {\n      data: mockRequestBody,\n    });\n    expect(status).toBe(201);\n    expect(data).toEqual({\n      ...mockRequestBody,\n      id: 101,\n    });\n  });\n\n  it(&#x27;should be return status 200 - get by id&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts/1`);\n    expect(status).toBe(200);\n    expect(data).toEqual(mockRequestBody);\n  });\n\n  it(&#x27;should be return status 200 - put&#x27;, async () =&gt; {\n    const { status, data } = await service.put(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - delete&#x27;, async () =&gt; {\n    const { status, data } = await service.delete(`${API_NESTJS_STARTER}/posts/2`);\n    expect(status).toBe(200);\n    expect(data).toEqual({});\n  });\n\n  it(&#x27;should be return status 200 - patch&#x27;, async () =&gt; {\n    const { status, data } = await service.patch(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - head&#x27;, async () =&gt; {\n    const { status, headers } = await service.head(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(headers).toHaveProperty(&#x27;etag&#x27;);\n  });\n\n  it(&#x27;should be return error&#x27;, async () =&gt; {\n    try {\n      const { data } = await service.get(`${API_NESTJS_STARTER}/postss`);\n      expect(data).toBe(200);\n    } catch (error) {\n      expect(error.response.status).toBe(404);\n      expect(error.message).toBe(&#x27;Request failed with status code 404&#x27;);\n    }\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;cda2ffb3-7d7a-4bba-935a-aebf0151fac8&quot;,&quot;parentUUID&quot;:&quot;e4e47e1f-5a40-4eb8-851c-7904e9c78814&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;HttpService &gt; should be return status 200 - put&quot;,&quot;title&quot;:&quot;HttpService &gt; should be return status 200 - put&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:426,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule, ConfigService } from &#x27;@nestjs/config&#x27;;\n\nimport { HttpClientService } from &#x27;../http/services/httpClient.service&#x27;;\nimport { HttpClientModule } from &#x27;../http/httpClient.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\n\nconst API_NESTJS_STARTER = &#x27;https://jsonplaceholder.typicode.com&#x27;;\n\nconst mockRequestBody = {\n  userId: 1,\n  id: 1,\n  title: &#x27;sunt aut facere repellat provident occaecati excepturi optio reprehenderit&#x27;,\n  body: &#x27;quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto&#x27;,\n};\n\ndescribe(&#x27;HttpService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let service: HttpClientService;\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HttpClientModule.registerAsync({\n          imports: [ConfigModule],\n          useFactory: async (configService: ConfigService) =&gt;\n            configService.get(&#x27;config.httpOptions&#x27;),\n          inject: [ConfigService],\n        }),\n      ],\n    }).compile();\n    app = module.createNestApplication();\n    await app.init;\n    service = module.get&lt;HttpClientService&gt;(HttpClientService);\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(service).toBeDefined();\n    expect(service).toBeInstanceOf(HttpClientService);\n    expect(service.axiosRef).not.toBeNull();\n  });\n\n  it(&#x27;should be return status 200 - request&#x27;, async () =&gt; {\n    const { status, data } = await service.request({\n      url: `${API_NESTJS_STARTER}/posts`,\n      method: &#x27;GET&#x27;,\n    });\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 200 - get&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 201 - post&#x27;, async () =&gt; {\n    const { status, data } = await service.post(`${API_NESTJS_STARTER}/posts`, {\n      data: mockRequestBody,\n    });\n    expect(status).toBe(201);\n    expect(data).toEqual({\n      ...mockRequestBody,\n      id: 101,\n    });\n  });\n\n  it(&#x27;should be return status 200 - get by id&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts/1`);\n    expect(status).toBe(200);\n    expect(data).toEqual(mockRequestBody);\n  });\n\n  it(&#x27;should be return status 200 - put&#x27;, async () =&gt; {\n    const { status, data } = await service.put(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - delete&#x27;, async () =&gt; {\n    const { status, data } = await service.delete(`${API_NESTJS_STARTER}/posts/2`);\n    expect(status).toBe(200);\n    expect(data).toEqual({});\n  });\n\n  it(&#x27;should be return status 200 - patch&#x27;, async () =&gt; {\n    const { status, data } = await service.patch(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - head&#x27;, async () =&gt; {\n    const { status, headers } = await service.head(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(headers).toHaveProperty(&#x27;etag&#x27;);\n  });\n\n  it(&#x27;should be return error&#x27;, async () =&gt; {\n    try {\n      const { data } = await service.get(`${API_NESTJS_STARTER}/postss`);\n      expect(data).toBe(200);\n    } catch (error) {\n      expect(error.response.status).toBe(404);\n      expect(error.message).toBe(&#x27;Request failed with status code 404&#x27;);\n    }\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a988cb86-970c-49e0-b911-1b5f569dc634&quot;,&quot;parentUUID&quot;:&quot;e4e47e1f-5a40-4eb8-851c-7904e9c78814&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;HttpService &gt; should be return status 200 - delete&quot;,&quot;title&quot;:&quot;HttpService &gt; should be return status 200 - delete&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:424,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule, ConfigService } from &#x27;@nestjs/config&#x27;;\n\nimport { HttpClientService } from &#x27;../http/services/httpClient.service&#x27;;\nimport { HttpClientModule } from &#x27;../http/httpClient.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\n\nconst API_NESTJS_STARTER = &#x27;https://jsonplaceholder.typicode.com&#x27;;\n\nconst mockRequestBody = {\n  userId: 1,\n  id: 1,\n  title: &#x27;sunt aut facere repellat provident occaecati excepturi optio reprehenderit&#x27;,\n  body: &#x27;quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto&#x27;,\n};\n\ndescribe(&#x27;HttpService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let service: HttpClientService;\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HttpClientModule.registerAsync({\n          imports: [ConfigModule],\n          useFactory: async (configService: ConfigService) =&gt;\n            configService.get(&#x27;config.httpOptions&#x27;),\n          inject: [ConfigService],\n        }),\n      ],\n    }).compile();\n    app = module.createNestApplication();\n    await app.init;\n    service = module.get&lt;HttpClientService&gt;(HttpClientService);\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(service).toBeDefined();\n    expect(service).toBeInstanceOf(HttpClientService);\n    expect(service.axiosRef).not.toBeNull();\n  });\n\n  it(&#x27;should be return status 200 - request&#x27;, async () =&gt; {\n    const { status, data } = await service.request({\n      url: `${API_NESTJS_STARTER}/posts`,\n      method: &#x27;GET&#x27;,\n    });\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 200 - get&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 201 - post&#x27;, async () =&gt; {\n    const { status, data } = await service.post(`${API_NESTJS_STARTER}/posts`, {\n      data: mockRequestBody,\n    });\n    expect(status).toBe(201);\n    expect(data).toEqual({\n      ...mockRequestBody,\n      id: 101,\n    });\n  });\n\n  it(&#x27;should be return status 200 - get by id&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts/1`);\n    expect(status).toBe(200);\n    expect(data).toEqual(mockRequestBody);\n  });\n\n  it(&#x27;should be return status 200 - put&#x27;, async () =&gt; {\n    const { status, data } = await service.put(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - delete&#x27;, async () =&gt; {\n    const { status, data } = await service.delete(`${API_NESTJS_STARTER}/posts/2`);\n    expect(status).toBe(200);\n    expect(data).toEqual({});\n  });\n\n  it(&#x27;should be return status 200 - patch&#x27;, async () =&gt; {\n    const { status, data } = await service.patch(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - head&#x27;, async () =&gt; {\n    const { status, headers } = await service.head(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(headers).toHaveProperty(&#x27;etag&#x27;);\n  });\n\n  it(&#x27;should be return error&#x27;, async () =&gt; {\n    try {\n      const { data } = await service.get(`${API_NESTJS_STARTER}/postss`);\n      expect(data).toBe(200);\n    } catch (error) {\n      expect(error.response.status).toBe(404);\n      expect(error.message).toBe(&#x27;Request failed with status code 404&#x27;);\n    }\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;8a13c851-7d44-4d50-bd09-f3f5093a8063&quot;,&quot;parentUUID&quot;:&quot;e4e47e1f-5a40-4eb8-851c-7904e9c78814&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;HttpService &gt; should be return status 200 - patch&quot;,&quot;title&quot;:&quot;HttpService &gt; should be return status 200 - patch&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:644,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule, ConfigService } from &#x27;@nestjs/config&#x27;;\n\nimport { HttpClientService } from &#x27;../http/services/httpClient.service&#x27;;\nimport { HttpClientModule } from &#x27;../http/httpClient.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\n\nconst API_NESTJS_STARTER = &#x27;https://jsonplaceholder.typicode.com&#x27;;\n\nconst mockRequestBody = {\n  userId: 1,\n  id: 1,\n  title: &#x27;sunt aut facere repellat provident occaecati excepturi optio reprehenderit&#x27;,\n  body: &#x27;quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto&#x27;,\n};\n\ndescribe(&#x27;HttpService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let service: HttpClientService;\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HttpClientModule.registerAsync({\n          imports: [ConfigModule],\n          useFactory: async (configService: ConfigService) =&gt;\n            configService.get(&#x27;config.httpOptions&#x27;),\n          inject: [ConfigService],\n        }),\n      ],\n    }).compile();\n    app = module.createNestApplication();\n    await app.init;\n    service = module.get&lt;HttpClientService&gt;(HttpClientService);\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(service).toBeDefined();\n    expect(service).toBeInstanceOf(HttpClientService);\n    expect(service.axiosRef).not.toBeNull();\n  });\n\n  it(&#x27;should be return status 200 - request&#x27;, async () =&gt; {\n    const { status, data } = await service.request({\n      url: `${API_NESTJS_STARTER}/posts`,\n      method: &#x27;GET&#x27;,\n    });\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 200 - get&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 201 - post&#x27;, async () =&gt; {\n    const { status, data } = await service.post(`${API_NESTJS_STARTER}/posts`, {\n      data: mockRequestBody,\n    });\n    expect(status).toBe(201);\n    expect(data).toEqual({\n      ...mockRequestBody,\n      id: 101,\n    });\n  });\n\n  it(&#x27;should be return status 200 - get by id&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts/1`);\n    expect(status).toBe(200);\n    expect(data).toEqual(mockRequestBody);\n  });\n\n  it(&#x27;should be return status 200 - put&#x27;, async () =&gt; {\n    const { status, data } = await service.put(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - delete&#x27;, async () =&gt; {\n    const { status, data } = await service.delete(`${API_NESTJS_STARTER}/posts/2`);\n    expect(status).toBe(200);\n    expect(data).toEqual({});\n  });\n\n  it(&#x27;should be return status 200 - patch&#x27;, async () =&gt; {\n    const { status, data } = await service.patch(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - head&#x27;, async () =&gt; {\n    const { status, headers } = await service.head(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(headers).toHaveProperty(&#x27;etag&#x27;);\n  });\n\n  it(&#x27;should be return error&#x27;, async () =&gt; {\n    try {\n      const { data } = await service.get(`${API_NESTJS_STARTER}/postss`);\n      expect(data).toBe(200);\n    } catch (error) {\n      expect(error.response.status).toBe(404);\n      expect(error.message).toBe(&#x27;Request failed with status code 404&#x27;);\n    }\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9aeecf01-166e-42b6-8087-dffad821d978&quot;,&quot;parentUUID&quot;:&quot;e4e47e1f-5a40-4eb8-851c-7904e9c78814&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;HttpService &gt; should be return status 200 - head&quot;,&quot;title&quot;:&quot;HttpService &gt; should be return status 200 - head&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:81,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule, ConfigService } from &#x27;@nestjs/config&#x27;;\n\nimport { HttpClientService } from &#x27;../http/services/httpClient.service&#x27;;\nimport { HttpClientModule } from &#x27;../http/httpClient.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\n\nconst API_NESTJS_STARTER = &#x27;https://jsonplaceholder.typicode.com&#x27;;\n\nconst mockRequestBody = {\n  userId: 1,\n  id: 1,\n  title: &#x27;sunt aut facere repellat provident occaecati excepturi optio reprehenderit&#x27;,\n  body: &#x27;quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto&#x27;,\n};\n\ndescribe(&#x27;HttpService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let service: HttpClientService;\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HttpClientModule.registerAsync({\n          imports: [ConfigModule],\n          useFactory: async (configService: ConfigService) =&gt;\n            configService.get(&#x27;config.httpOptions&#x27;),\n          inject: [ConfigService],\n        }),\n      ],\n    }).compile();\n    app = module.createNestApplication();\n    await app.init;\n    service = module.get&lt;HttpClientService&gt;(HttpClientService);\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(service).toBeDefined();\n    expect(service).toBeInstanceOf(HttpClientService);\n    expect(service.axiosRef).not.toBeNull();\n  });\n\n  it(&#x27;should be return status 200 - request&#x27;, async () =&gt; {\n    const { status, data } = await service.request({\n      url: `${API_NESTJS_STARTER}/posts`,\n      method: &#x27;GET&#x27;,\n    });\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 200 - get&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 201 - post&#x27;, async () =&gt; {\n    const { status, data } = await service.post(`${API_NESTJS_STARTER}/posts`, {\n      data: mockRequestBody,\n    });\n    expect(status).toBe(201);\n    expect(data).toEqual({\n      ...mockRequestBody,\n      id: 101,\n    });\n  });\n\n  it(&#x27;should be return status 200 - get by id&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts/1`);\n    expect(status).toBe(200);\n    expect(data).toEqual(mockRequestBody);\n  });\n\n  it(&#x27;should be return status 200 - put&#x27;, async () =&gt; {\n    const { status, data } = await service.put(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - delete&#x27;, async () =&gt; {\n    const { status, data } = await service.delete(`${API_NESTJS_STARTER}/posts/2`);\n    expect(status).toBe(200);\n    expect(data).toEqual({});\n  });\n\n  it(&#x27;should be return status 200 - patch&#x27;, async () =&gt; {\n    const { status, data } = await service.patch(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - head&#x27;, async () =&gt; {\n    const { status, headers } = await service.head(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(headers).toHaveProperty(&#x27;etag&#x27;);\n  });\n\n  it(&#x27;should be return error&#x27;, async () =&gt; {\n    try {\n      const { data } = await service.get(`${API_NESTJS_STARTER}/postss`);\n      expect(data).toBe(200);\n    } catch (error) {\n      expect(error.response.status).toBe(404);\n      expect(error.message).toBe(&#x27;Request failed with status code 404&#x27;);\n    }\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6892fae6-80a8-4cee-998e-4f0a2615acdf&quot;,&quot;parentUUID&quot;:&quot;e4e47e1f-5a40-4eb8-851c-7904e9c78814&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;HttpService &gt; should be return error&quot;,&quot;title&quot;:&quot;HttpService &gt; should be return error&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:441,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule, ConfigService } from &#x27;@nestjs/config&#x27;;\n\nimport { HttpClientService } from &#x27;../http/services/httpClient.service&#x27;;\nimport { HttpClientModule } from &#x27;../http/httpClient.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\n\nconst API_NESTJS_STARTER = &#x27;https://jsonplaceholder.typicode.com&#x27;;\n\nconst mockRequestBody = {\n  userId: 1,\n  id: 1,\n  title: &#x27;sunt aut facere repellat provident occaecati excepturi optio reprehenderit&#x27;,\n  body: &#x27;quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto&#x27;,\n};\n\ndescribe(&#x27;HttpService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let service: HttpClientService;\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HttpClientModule.registerAsync({\n          imports: [ConfigModule],\n          useFactory: async (configService: ConfigService) =&gt;\n            configService.get(&#x27;config.httpOptions&#x27;),\n          inject: [ConfigService],\n        }),\n      ],\n    }).compile();\n    app = module.createNestApplication();\n    await app.init;\n    service = module.get&lt;HttpClientService&gt;(HttpClientService);\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(service).toBeDefined();\n    expect(service).toBeInstanceOf(HttpClientService);\n    expect(service.axiosRef).not.toBeNull();\n  });\n\n  it(&#x27;should be return status 200 - request&#x27;, async () =&gt; {\n    const { status, data } = await service.request({\n      url: `${API_NESTJS_STARTER}/posts`,\n      method: &#x27;GET&#x27;,\n    });\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 200 - get&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 201 - post&#x27;, async () =&gt; {\n    const { status, data } = await service.post(`${API_NESTJS_STARTER}/posts`, {\n      data: mockRequestBody,\n    });\n    expect(status).toBe(201);\n    expect(data).toEqual({\n      ...mockRequestBody,\n      id: 101,\n    });\n  });\n\n  it(&#x27;should be return status 200 - get by id&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts/1`);\n    expect(status).toBe(200);\n    expect(data).toEqual(mockRequestBody);\n  });\n\n  it(&#x27;should be return status 200 - put&#x27;, async () =&gt; {\n    const { status, data } = await service.put(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - delete&#x27;, async () =&gt; {\n    const { status, data } = await service.delete(`${API_NESTJS_STARTER}/posts/2`);\n    expect(status).toBe(200);\n    expect(data).toEqual({});\n  });\n\n  it(&#x27;should be return status 200 - patch&#x27;, async () =&gt; {\n    const { status, data } = await service.patch(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - head&#x27;, async () =&gt; {\n    const { status, headers } = await service.head(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(headers).toHaveProperty(&#x27;etag&#x27;);\n  });\n\n  it(&#x27;should be return error&#x27;, async () =&gt; {\n    try {\n      const { data } = await service.get(`${API_NESTJS_STARTER}/postss`);\n      expect(data).toBe(200);\n    } catch (error) {\n      expect(error.response.status).toBe(404);\n      expect(error.message).toBe(&#x27;Request failed with status code 404&#x27;);\n    }\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;da246b4d-93fb-4db3-84b6-513164062dc7&quot;,&quot;parentUUID&quot;:&quot;e4e47e1f-5a40-4eb8-851c-7904e9c78814&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;HttpInterceptor &gt; should be defined&quot;,&quot;title&quot;:&quot;HttpInterceptor &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:75,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\n\nimport { HttpClientService } from &#x27;../http/services/httpClient.service&#x27;;\nimport { HttpClientInterceptor } from &#x27;../http/interceptors/httpClient.interceptor&#x27;;\nimport { HttpClientModule } from &#x27;../http/httpClient.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\n\nconst executionContext: any = {\n  switchToHttp: jest.fn().mockReturnThis(),\n  getRequest: jest.fn().mockReturnThis(),\n  getResponse: jest.fn().mockReturnThis(),\n};\n\nconst callHandler: any = {\n  handle: jest.fn(),\n};\n\ndescribe(&#x27;HttpInterceptor&#x27;, () =&gt; {\n  let app: INestApplication;\n  let service: HttpClientService;\n  let interceptor: HttpClientInterceptor&lt;any&gt;;\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HttpClientModule,\n      ],\n    }).compile();\n    app = module.createNestApplication();\n    await app.init;\n\n    service = module.get&lt;HttpClientService&gt;(HttpClientService);\n    interceptor = new HttpClientInterceptor(service);\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(interceptor).toBeDefined();\n  });\n\n  it(&#x27;should be intercept and pass headers&#x27;, async () =&gt; {\n    await interceptor.intercept(executionContext, callHandler);\n    expect(callHandler.handle).toBeCalledTimes(1);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6beb7206-8573-4edf-b6ee-dc8d2a273aaa&quot;,&quot;parentUUID&quot;:&quot;e4e47e1f-5a40-4eb8-851c-7904e9c78814&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;HttpInterceptor &gt; should be intercept and pass headers&quot;,&quot;title&quot;:&quot;HttpInterceptor &gt; should be intercept and pass headers&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\n\nimport { HttpClientService } from &#x27;../http/services/httpClient.service&#x27;;\nimport { HttpClientInterceptor } from &#x27;../http/interceptors/httpClient.interceptor&#x27;;\nimport { HttpClientModule } from &#x27;../http/httpClient.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\n\nconst executionContext: any = {\n  switchToHttp: jest.fn().mockReturnThis(),\n  getRequest: jest.fn().mockReturnThis(),\n  getResponse: jest.fn().mockReturnThis(),\n};\n\nconst callHandler: any = {\n  handle: jest.fn(),\n};\n\ndescribe(&#x27;HttpInterceptor&#x27;, () =&gt; {\n  let app: INestApplication;\n  let service: HttpClientService;\n  let interceptor: HttpClientInterceptor&lt;any&gt;;\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HttpClientModule,\n      ],\n    }).compile();\n    app = module.createNestApplication();\n    await app.init;\n\n    service = module.get&lt;HttpClientService&gt;(HttpClientService);\n    interceptor = new HttpClientInterceptor(service);\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(interceptor).toBeDefined();\n  });\n\n  it(&#x27;should be intercept and pass headers&#x27;, async () =&gt; {\n    await interceptor.intercept(executionContext, callHandler);\n    expect(callHandler.handle).toBeCalledTimes(1);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e9c0a462-5343-4a9a-8376-91df74402bea&quot;,&quot;parentUUID&quot;:&quot;e4e47e1f-5a40-4eb8-851c-7904e9c78814&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;HttpModule &gt; registerAsync useFactory &gt; should be define&quot;,&quot;title&quot;:&quot;HttpModule &gt; registerAsync useFactory &gt; should be define&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:78,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\n\nimport { HttpClientModule } from &#x27;../http/httpClient.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\nimport { HttpModuleAsyncOptions } from &#x27;../http/interfaces/http-module.interface&#x27;;\n\nclass MockedClass {\n  createHttpOptions() {\n    return {\n      timeout: 5000,\n      maxRedirects: 5,\n    };\n  }\n}\n\ndescribe(&#x27;HttpModule&#x27;, () =&gt; {\n  const mockedUseFactory: HttpModuleAsyncOptions = {\n    useFactory: async () =&gt; ({\n      timeout: 5000,\n      maxRedirects: 5,\n    }),\n  };\n\n  describe(&#x27;registerAsync useFactory&#x27;, () =&gt; {\n    let app: INestApplication;\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.registerAsync(mockedUseFactory),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be define&#x27;, async () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n\n  const mockedUseClassOptions: HttpModuleAsyncOptions = {\n    useClass: MockedClass,\n  };\n\n  describe(&#x27;registerAsync useClass&#x27;, () =&gt; {\n    let app: INestApplication;\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.registerAsync(mockedUseClassOptions),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be define&#x27;, async () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n\n  const mockedUseExistingOptions: HttpModuleAsyncOptions = {\n    extraProviders: [MockedClass],\n    useExisting: MockedClass,\n  };\n\n  describe(&#x27;registerAsync useExisting&#x27;, () =&gt; {\n    let app: INestApplication;\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.registerAsync(mockedUseExistingOptions),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be define&#x27;, async () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n\n  describe(&#x27;register&#x27;, () =&gt; {\n    let app: INestApplication;\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.register({ ...config().httOptions }),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be define&#x27;, async () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;77403594-c004-4586-b2f3-6d5e278512b3&quot;,&quot;parentUUID&quot;:&quot;e4e47e1f-5a40-4eb8-851c-7904e9c78814&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;HttpModule &gt; registerAsync useClass &gt; should be define&quot;,&quot;title&quot;:&quot;HttpModule &gt; registerAsync useClass &gt; should be define&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:6,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\n\nimport { HttpClientModule } from &#x27;../http/httpClient.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\nimport { HttpModuleAsyncOptions } from &#x27;../http/interfaces/http-module.interface&#x27;;\n\nclass MockedClass {\n  createHttpOptions() {\n    return {\n      timeout: 5000,\n      maxRedirects: 5,\n    };\n  }\n}\n\ndescribe(&#x27;HttpModule&#x27;, () =&gt; {\n  const mockedUseFactory: HttpModuleAsyncOptions = {\n    useFactory: async () =&gt; ({\n      timeout: 5000,\n      maxRedirects: 5,\n    }),\n  };\n\n  describe(&#x27;registerAsync useFactory&#x27;, () =&gt; {\n    let app: INestApplication;\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.registerAsync(mockedUseFactory),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be define&#x27;, async () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n\n  const mockedUseClassOptions: HttpModuleAsyncOptions = {\n    useClass: MockedClass,\n  };\n\n  describe(&#x27;registerAsync useClass&#x27;, () =&gt; {\n    let app: INestApplication;\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.registerAsync(mockedUseClassOptions),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be define&#x27;, async () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n\n  const mockedUseExistingOptions: HttpModuleAsyncOptions = {\n    extraProviders: [MockedClass],\n    useExisting: MockedClass,\n  };\n\n  describe(&#x27;registerAsync useExisting&#x27;, () =&gt; {\n    let app: INestApplication;\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.registerAsync(mockedUseExistingOptions),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be define&#x27;, async () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n\n  describe(&#x27;register&#x27;, () =&gt; {\n    let app: INestApplication;\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.register({ ...config().httOptions }),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be define&#x27;, async () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;12b2846a-fcfe-46fd-9061-bd60214831f1&quot;,&quot;parentUUID&quot;:&quot;e4e47e1f-5a40-4eb8-851c-7904e9c78814&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;HttpModule &gt; registerAsync useExisting &gt; should be define&quot;,&quot;title&quot;:&quot;HttpModule &gt; registerAsync useExisting &gt; should be define&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\n\nimport { HttpClientModule } from &#x27;../http/httpClient.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\nimport { HttpModuleAsyncOptions } from &#x27;../http/interfaces/http-module.interface&#x27;;\n\nclass MockedClass {\n  createHttpOptions() {\n    return {\n      timeout: 5000,\n      maxRedirects: 5,\n    };\n  }\n}\n\ndescribe(&#x27;HttpModule&#x27;, () =&gt; {\n  const mockedUseFactory: HttpModuleAsyncOptions = {\n    useFactory: async () =&gt; ({\n      timeout: 5000,\n      maxRedirects: 5,\n    }),\n  };\n\n  describe(&#x27;registerAsync useFactory&#x27;, () =&gt; {\n    let app: INestApplication;\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.registerAsync(mockedUseFactory),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be define&#x27;, async () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n\n  const mockedUseClassOptions: HttpModuleAsyncOptions = {\n    useClass: MockedClass,\n  };\n\n  describe(&#x27;registerAsync useClass&#x27;, () =&gt; {\n    let app: INestApplication;\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.registerAsync(mockedUseClassOptions),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be define&#x27;, async () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n\n  const mockedUseExistingOptions: HttpModuleAsyncOptions = {\n    extraProviders: [MockedClass],\n    useExisting: MockedClass,\n  };\n\n  describe(&#x27;registerAsync useExisting&#x27;, () =&gt; {\n    let app: INestApplication;\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.registerAsync(mockedUseExistingOptions),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be define&#x27;, async () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n\n  describe(&#x27;register&#x27;, () =&gt; {\n    let app: INestApplication;\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.register({ ...config().httOptions }),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be define&#x27;, async () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;5e7b9720-0329-4013-9122-0a6bf6b378f6&quot;,&quot;parentUUID&quot;:&quot;e4e47e1f-5a40-4eb8-851c-7904e9c78814&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;HttpModule &gt; register &gt; should be define&quot;,&quot;title&quot;:&quot;HttpModule &gt; register &gt; should be define&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\n\nimport { HttpClientModule } from &#x27;../http/httpClient.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\nimport { HttpModuleAsyncOptions } from &#x27;../http/interfaces/http-module.interface&#x27;;\n\nclass MockedClass {\n  createHttpOptions() {\n    return {\n      timeout: 5000,\n      maxRedirects: 5,\n    };\n  }\n}\n\ndescribe(&#x27;HttpModule&#x27;, () =&gt; {\n  const mockedUseFactory: HttpModuleAsyncOptions = {\n    useFactory: async () =&gt; ({\n      timeout: 5000,\n      maxRedirects: 5,\n    }),\n  };\n\n  describe(&#x27;registerAsync useFactory&#x27;, () =&gt; {\n    let app: INestApplication;\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.registerAsync(mockedUseFactory),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be define&#x27;, async () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n\n  const mockedUseClassOptions: HttpModuleAsyncOptions = {\n    useClass: MockedClass,\n  };\n\n  describe(&#x27;registerAsync useClass&#x27;, () =&gt; {\n    let app: INestApplication;\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.registerAsync(mockedUseClassOptions),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be define&#x27;, async () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n\n  const mockedUseExistingOptions: HttpModuleAsyncOptions = {\n    extraProviders: [MockedClass],\n    useExisting: MockedClass,\n  };\n\n  describe(&#x27;registerAsync useExisting&#x27;, () =&gt; {\n    let app: INestApplication;\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.registerAsync(mockedUseExistingOptions),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be define&#x27;, async () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n\n  describe(&#x27;register&#x27;, () =&gt; {\n    let app: INestApplication;\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.register({ ...config().httOptions }),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be define&#x27;, async () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4651145d-737a-4d74-b970-9300d80e0f9e&quot;,&quot;parentUUID&quot;:&quot;e4e47e1f-5a40-4eb8-851c-7904e9c78814&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;01392ef8-c46d-416e-8b14-8b488a37891b&quot;,&quot;e15cdea4-97a4-4baf-9b9b-cf0cd24b13df&quot;,&quot;c4d6a6c7-e872-4647-b4f1-90aacb1421fd&quot;,&quot;a85e5925-a1d7-4537-9f67-78b1b6f4a9cf&quot;,&quot;cda2ffb3-7d7a-4bba-935a-aebf0151fac8&quot;,&quot;a988cb86-970c-49e0-b911-1b5f569dc634&quot;,&quot;8a13c851-7d44-4d50-bd09-f3f5093a8063&quot;,&quot;9aeecf01-166e-42b6-8087-dffad821d978&quot;,&quot;6892fae6-80a8-4cee-998e-4f0a2615acdf&quot;,&quot;da246b4d-93fb-4db3-84b6-513164062dc7&quot;,&quot;6beb7206-8573-4edf-b6ee-dc8d2a273aaa&quot;,&quot;e9c0a462-5343-4a9a-8376-91df74402bea&quot;,&quot;77403594-c004-4586-b2f3-6d5e278512b3&quot;,&quot;12b2846a-fcfe-46fd-9061-bd60214831f1&quot;,&quot;5e7b9720-0329-4013-9122-0a6bf6b378f6&quot;,&quot;4651145d-737a-4d74-b970-9300d80e0f9e&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:3333,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:5000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:5000},{&quot;uuid&quot;:&quot;711a1818-3569-4b49-bc6f-5a6a9f7dd036&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/mailer&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;523b2ad6-7258-473b-8a13-419105450da5&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/mailer&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;fullTitle&quot;:&quot;MailerService &gt; should not be defined if a transport is not provided&quot;,&quot;title&quot;:&quot;MailerService &gt; should not be defined if a transport is not provided&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;52fc7fb9-9bb4-4e09-9818-cc98e383ac88&quot;,&quot;parentUUID&quot;:&quot;523b2ad6-7258-473b-8a13-419105450da5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should accept a smtp transport string&quot;,&quot;title&quot;:&quot;MailerService &gt; should accept a smtp transport string&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:6,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ff5491c4-bd95-4b5c-9a5f-0d740aaa2b5d&quot;,&quot;parentUUID&quot;:&quot;523b2ad6-7258-473b-8a13-419105450da5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should accept a smtp transports string&quot;,&quot;title&quot;:&quot;MailerService &gt; should accept a smtp transports string&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f63abc46-1239-48ae-ace1-6d34d53e9804&quot;,&quot;parentUUID&quot;:&quot;523b2ad6-7258-473b-8a13-419105450da5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should accept smtp transport options&quot;,&quot;title&quot;:&quot;MailerService &gt; should accept smtp transport options&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2b40a82e-febb-4d57-b887-5c3d914e47c2&quot;,&quot;parentUUID&quot;:&quot;523b2ad6-7258-473b-8a13-419105450da5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should accept a smtp transport instance&quot;,&quot;title&quot;:&quot;MailerService &gt; should accept a smtp transport instance&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;39f941d7-f0ad-4f44-9560-7ad4742374ab&quot;,&quot;parentUUID&quot;:&quot;523b2ad6-7258-473b-8a13-419105450da5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should send emails with nodemailer&quot;,&quot;title&quot;:&quot;MailerService &gt; should send emails with nodemailer&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:7,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;bae792da-29da-4110-9c1d-4d4e28aa7f46&quot;,&quot;parentUUID&quot;:&quot;523b2ad6-7258-473b-8a13-419105450da5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should send emails with nodemailer transports&quot;,&quot;title&quot;:&quot;MailerService &gt; should send emails with nodemailer transports&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;cba95eb4-3975-4e5b-a0f1-f755b0794b6c&quot;,&quot;parentUUID&quot;:&quot;523b2ad6-7258-473b-8a13-419105450da5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should send emails with nodemailer with different transports name&quot;,&quot;title&quot;:&quot;MailerService &gt; should send emails with nodemailer with different transports name&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4dc56762-cd3c-4f26-9835-cc65d25639ff&quot;,&quot;parentUUID&quot;:&quot;523b2ad6-7258-473b-8a13-419105450da5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should send emails with nodemailer without transports&quot;,&quot;title&quot;:&quot;MailerService &gt; should send emails with nodemailer without transports&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;31b21d0c-b653-4a0f-9f5f-1bb32afe76dd&quot;,&quot;parentUUID&quot;:&quot;523b2ad6-7258-473b-8a13-419105450da5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should use mailerOptions.defaults when send emails&quot;,&quot;title&quot;:&quot;MailerService &gt; should use mailerOptions.defaults when send emails&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b32d6557-ac3d-430c-860b-293606aa2e16&quot;,&quot;parentUUID&quot;:&quot;523b2ad6-7258-473b-8a13-419105450da5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should use custom transport to send mail&quot;,&quot;title&quot;:&quot;MailerService &gt; should use custom transport to send mail&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c05d45f8-ce4a-4d38-b6df-0de7883d9db0&quot;,&quot;parentUUID&quot;:&quot;523b2ad6-7258-473b-8a13-419105450da5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should compile template with the handlebars adapter&quot;,&quot;title&quot;:&quot;MailerService &gt; should compile template with the handlebars adapter&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:18,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2a6fdb36-4f31-48f0-89a9-24d224552b43&quot;,&quot;parentUUID&quot;:&quot;523b2ad6-7258-473b-8a13-419105450da5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should compile template with the handlebars adapter with relative path&quot;,&quot;title&quot;:&quot;MailerService &gt; should compile template with the handlebars adapter with relative path&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:18,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;87647877-9657-40b2-a705-368180177047&quot;,&quot;parentUUID&quot;:&quot;523b2ad6-7258-473b-8a13-419105450da5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should compile template with the handlebars adapter with error template path&quot;,&quot;title&quot;:&quot;MailerService &gt; should compile template with the handlebars adapter with error template path&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3b9b66c6-5fe8-4148-885e-bb110a2221dc&quot;,&quot;parentUUID&quot;:&quot;523b2ad6-7258-473b-8a13-419105450da5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should compile template with the handlebars adapter with disabled inline-css&quot;,&quot;title&quot;:&quot;MailerService &gt; should compile template with the handlebars adapter with disabled inline-css&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b534aa8f-d114-4f80-9d3d-4f3547e59479&quot;,&quot;parentUUID&quot;:&quot;523b2ad6-7258-473b-8a13-419105450da5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should compile template with the handlebars adapter with enabled inline-css and media query&quot;,&quot;title&quot;:&quot;MailerService &gt; should compile template with the handlebars adapter with enabled inline-css and media query&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:6,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e901561e-400c-469f-b96e-afeb05986f15&quot;,&quot;parentUUID&quot;:&quot;523b2ad6-7258-473b-8a13-419105450da5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should compile template with the pug adapter&quot;,&quot;title&quot;:&quot;MailerService &gt; should compile template with the pug adapter&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:22,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;565c2b07-6dd1-4bab-b284-8a492ad4dfb0&quot;,&quot;parentUUID&quot;:&quot;523b2ad6-7258-473b-8a13-419105450da5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should compile template with the pug adapter with relative path&quot;,&quot;title&quot;:&quot;MailerService &gt; should compile template with the pug adapter with relative path&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:6,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1b264ffd-e064-4064-a6c6-43c5bebb378a&quot;,&quot;parentUUID&quot;:&quot;523b2ad6-7258-473b-8a13-419105450da5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should compile template with the pug adapter with error to read template&quot;,&quot;title&quot;:&quot;MailerService &gt; should compile template with the pug adapter with error to read template&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a311b1a6-3fe6-416b-b8f8-7c40be31b31d&quot;,&quot;parentUUID&quot;:&quot;523b2ad6-7258-473b-8a13-419105450da5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should compile template with the pug adapter without inline css&quot;,&quot;title&quot;:&quot;MailerService &gt; should compile template with the pug adapter without inline css&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;defab326-b749-4d51-818e-1b0064d7db1a&quot;,&quot;parentUUID&quot;:&quot;523b2ad6-7258-473b-8a13-419105450da5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should compile template with the ejs adapter&quot;,&quot;title&quot;:&quot;MailerService &gt; should compile template with the ejs adapter&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;eda902ed-9e69-47e5-9bed-c5439cedbf17&quot;,&quot;parentUUID&quot;:&quot;523b2ad6-7258-473b-8a13-419105450da5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should compile template with the ejs adapter with error to read template&quot;,&quot;title&quot;:&quot;MailerService &gt; should compile template with the ejs adapter with error to read template&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c0889da1-14e0-4910-8a9a-4892115a4b2a&quot;,&quot;parentUUID&quot;:&quot;523b2ad6-7258-473b-8a13-419105450da5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should compile template with the ejs adapter read template relative url&quot;,&quot;title&quot;:&quot;MailerService &gt; should compile template with the ejs adapter read template relative url&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d5f75db4-0e47-46dc-a427-6199e7103048&quot;,&quot;parentUUID&quot;:&quot;523b2ad6-7258-473b-8a13-419105450da5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should compile template with the ejs adapter without css inline&quot;,&quot;title&quot;:&quot;MailerService &gt; should compile template with the ejs adapter without css inline&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;36108f0f-c968-4658-ab81-7df4312e659f&quot;,&quot;parentUUID&quot;:&quot;523b2ad6-7258-473b-8a13-419105450da5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should compile template with the ejs adapter with css inline&quot;,&quot;title&quot;:&quot;MailerService &gt; should compile template with the ejs adapter with css inline&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2a70f433-9c7d-4b7d-ad5e-c213bbeec5b8&quot;,&quot;parentUUID&quot;:&quot;523b2ad6-7258-473b-8a13-419105450da5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerModule &gt; forRoot &gt; should be defined&quot;,&quot;title&quot;:&quot;MailerModule &gt; forRoot &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:149,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { MailerModule } from &#x27;../mailer/mailer.module&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport { dynamicConfig } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\n\ndescribe(&#x27;MailerModule&#x27;, () =&gt; {\n  let app: INestApplication;\n\n  describe(&#x27;forRoot&#x27;, () =&gt; {\n    beforeEach(async () =&gt; {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          MailerModule.forRoot({\n            transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n            defaults: {\n              from: &#x27;\&quot;nest-modules\&quot; &lt;modules@nestjs.com&gt;&#x27;,\n            },\n          }),\n        ],\n      }).compile();\n\n      app = moduleFixture.createNestApplication();\n      await app.init();\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n\n  describe(&#x27;forRootAsync&#x27;, () =&gt; {\n    beforeEach(async () =&gt; {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [\n              dynamicConfig({\n                mailer: {\n                  transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n                  defaults: {\n                    from: &#x27;\&quot;nest-modules\&quot; &lt;modules@nestjs.com&gt;&#x27;,\n                  },\n                },\n              }),\n            ],\n          }),\n          MailerModule,\n        ],\n      }).compile();\n\n      app = moduleFixture.createNestApplication();\n      await app.init();\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d047f066-4074-494c-83b6-8cf75b351ec7&quot;,&quot;parentUUID&quot;:&quot;523b2ad6-7258-473b-8a13-419105450da5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerModule &gt; forRootAsync &gt; should be defined&quot;,&quot;title&quot;:&quot;MailerModule &gt; forRootAsync &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:7,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { MailerModule } from &#x27;../mailer/mailer.module&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport { dynamicConfig } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\n\ndescribe(&#x27;MailerModule&#x27;, () =&gt; {\n  let app: INestApplication;\n\n  describe(&#x27;forRoot&#x27;, () =&gt; {\n    beforeEach(async () =&gt; {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          MailerModule.forRoot({\n            transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n            defaults: {\n              from: &#x27;\&quot;nest-modules\&quot; &lt;modules@nestjs.com&gt;&#x27;,\n            },\n          }),\n        ],\n      }).compile();\n\n      app = moduleFixture.createNestApplication();\n      await app.init();\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n\n  describe(&#x27;forRootAsync&#x27;, () =&gt; {\n    beforeEach(async () =&gt; {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [\n              dynamicConfig({\n                mailer: {\n                  transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n                  defaults: {\n                    from: &#x27;\&quot;nest-modules\&quot; &lt;modules@nestjs.com&gt;&#x27;,\n                  },\n                },\n              }),\n            ],\n          }),\n          MailerModule,\n        ],\n      }).compile();\n\n      app = moduleFixture.createNestApplication();\n      await app.init();\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;864ea9b7-b6d9-4d29-bc69-f5652c0d108d&quot;,&quot;parentUUID&quot;:&quot;523b2ad6-7258-473b-8a13-419105450da5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;52fc7fb9-9bb4-4e09-9818-cc98e383ac88&quot;,&quot;ff5491c4-bd95-4b5c-9a5f-0d740aaa2b5d&quot;,&quot;f63abc46-1239-48ae-ace1-6d34d53e9804&quot;,&quot;2b40a82e-febb-4d57-b887-5c3d914e47c2&quot;,&quot;39f941d7-f0ad-4f44-9560-7ad4742374ab&quot;,&quot;bae792da-29da-4110-9c1d-4d4e28aa7f46&quot;,&quot;cba95eb4-3975-4e5b-a0f1-f755b0794b6c&quot;,&quot;4dc56762-cd3c-4f26-9835-cc65d25639ff&quot;,&quot;31b21d0c-b653-4a0f-9f5f-1bb32afe76dd&quot;,&quot;b32d6557-ac3d-430c-860b-293606aa2e16&quot;,&quot;c05d45f8-ce4a-4d38-b6df-0de7883d9db0&quot;,&quot;2a6fdb36-4f31-48f0-89a9-24d224552b43&quot;,&quot;87647877-9657-40b2-a705-368180177047&quot;,&quot;3b9b66c6-5fe8-4148-885e-bb110a2221dc&quot;,&quot;b534aa8f-d114-4f80-9d3d-4f3547e59479&quot;,&quot;e901561e-400c-469f-b96e-afeb05986f15&quot;,&quot;565c2b07-6dd1-4bab-b284-8a492ad4dfb0&quot;,&quot;1b264ffd-e064-4064-a6c6-43c5bebb378a&quot;,&quot;a311b1a6-3fe6-416b-b8f8-7c40be31b31d&quot;,&quot;defab326-b749-4d51-818e-1b0064d7db1a&quot;,&quot;eda902ed-9e69-47e5-9bed-c5439cedbf17&quot;,&quot;c0889da1-14e0-4910-8a9a-4892115a4b2a&quot;,&quot;d5f75db4-0e47-46dc-a427-6199e7103048&quot;,&quot;36108f0f-c968-4658-ab81-7df4312e659f&quot;,&quot;2a70f433-9c7d-4b7d-ad5e-c213bbeec5b8&quot;,&quot;d047f066-4074-494c-83b6-8cf75b351ec7&quot;,&quot;864ea9b7-b6d9-4d29-bc69-f5652c0d108d&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:296,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:5000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:5000},{&quot;uuid&quot;:&quot;e0063c2a-85cb-4b0a-907c-14dcde957be3&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/redis&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;f91a5298-822f-4969-b8a3-08efa9095d2a&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/redis&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;fullTitle&quot;:&quot;RedisService &gt; should be defined&quot;,&quot;title&quot;:&quot;RedisService &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:192,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { delay, tcName, TCRedisOptions, testContainers } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { RedisModule } from &#x27;../redis/redis.module&#x27;;\nimport { RedisService } from &#x27;../redis/services/redis.service&#x27;;\n\ndescribe(&#x27;RedisService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () =&gt; {\n    container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n      ...TCRedisOptions,\n      command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: &#x27;test-redis-module&#x27;,\n          username: encodeURIComponent(&#x27;default&#x27;),\n          password: encodeURIComponent(&#x27;123456&#x27;),\n          host: global.hostContainer,\n          port: parseInt(&#x27;6379&#x27;, 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, async () =&gt; {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it(&#x27;should be return echo&#x27;, async () =&gt; {\n    const msg = &#x27;hello world&#x27;;\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it(&#x27;should be return false if key dont exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return OK when set value in redis&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKey&#x27;, &#x27;hello world&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return value of key&#x27;, async () =&gt; {\n    expect(await service.get(&#x27;myKey&#x27;)).toEqual(&#x27;hello world&#x27;);\n  });\n\n  it(&#x27;should be return true if key exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be set value in redis with expiration date&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKeyEx&#x27;, &#x27;hello world&#x27;, 2)).toEqual(&#x27;OK&#x27;);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey&#x27;, &#x27;copyKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be return false when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey2&#x27;, &#x27;copyKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be rename a key&#x27;, async () =&gt; {\n    expect(await service.rename(&#x27;copyKey&#x27;, &#x27;newKey&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return false when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;testKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;newKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be flush all&#x27;, async () =&gt; {\n    expect(await service.flushAll()).toEqual(&#x27;OK&#x27;);\n    expect(await service.get(&#x27;myKey&#x27;)).toBeNull();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;736d0be0-4533-47b2-90b9-c64749567884&quot;,&quot;parentUUID&quot;:&quot;f91a5298-822f-4969-b8a3-08efa9095d2a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;RedisService &gt; should be return echo&quot;,&quot;title&quot;:&quot;RedisService &gt; should be return echo&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:14,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { delay, tcName, TCRedisOptions, testContainers } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { RedisModule } from &#x27;../redis/redis.module&#x27;;\nimport { RedisService } from &#x27;../redis/services/redis.service&#x27;;\n\ndescribe(&#x27;RedisService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () =&gt; {\n    container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n      ...TCRedisOptions,\n      command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: &#x27;test-redis-module&#x27;,\n          username: encodeURIComponent(&#x27;default&#x27;),\n          password: encodeURIComponent(&#x27;123456&#x27;),\n          host: global.hostContainer,\n          port: parseInt(&#x27;6379&#x27;, 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, async () =&gt; {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it(&#x27;should be return echo&#x27;, async () =&gt; {\n    const msg = &#x27;hello world&#x27;;\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it(&#x27;should be return false if key dont exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return OK when set value in redis&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKey&#x27;, &#x27;hello world&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return value of key&#x27;, async () =&gt; {\n    expect(await service.get(&#x27;myKey&#x27;)).toEqual(&#x27;hello world&#x27;);\n  });\n\n  it(&#x27;should be return true if key exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be set value in redis with expiration date&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKeyEx&#x27;, &#x27;hello world&#x27;, 2)).toEqual(&#x27;OK&#x27;);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey&#x27;, &#x27;copyKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be return false when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey2&#x27;, &#x27;copyKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be rename a key&#x27;, async () =&gt; {\n    expect(await service.rename(&#x27;copyKey&#x27;, &#x27;newKey&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return false when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;testKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;newKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be flush all&#x27;, async () =&gt; {\n    expect(await service.flushAll()).toEqual(&#x27;OK&#x27;);\n    expect(await service.get(&#x27;myKey&#x27;)).toBeNull();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7dfeb273-b8bb-441d-a8f9-7389891ca300&quot;,&quot;parentUUID&quot;:&quot;f91a5298-822f-4969-b8a3-08efa9095d2a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;RedisService &gt; should be return false if key dont exist in redis&quot;,&quot;title&quot;:&quot;RedisService &gt; should be return false if key dont exist in redis&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { delay, tcName, TCRedisOptions, testContainers } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { RedisModule } from &#x27;../redis/redis.module&#x27;;\nimport { RedisService } from &#x27;../redis/services/redis.service&#x27;;\n\ndescribe(&#x27;RedisService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () =&gt; {\n    container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n      ...TCRedisOptions,\n      command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: &#x27;test-redis-module&#x27;,\n          username: encodeURIComponent(&#x27;default&#x27;),\n          password: encodeURIComponent(&#x27;123456&#x27;),\n          host: global.hostContainer,\n          port: parseInt(&#x27;6379&#x27;, 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, async () =&gt; {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it(&#x27;should be return echo&#x27;, async () =&gt; {\n    const msg = &#x27;hello world&#x27;;\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it(&#x27;should be return false if key dont exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return OK when set value in redis&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKey&#x27;, &#x27;hello world&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return value of key&#x27;, async () =&gt; {\n    expect(await service.get(&#x27;myKey&#x27;)).toEqual(&#x27;hello world&#x27;);\n  });\n\n  it(&#x27;should be return true if key exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be set value in redis with expiration date&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKeyEx&#x27;, &#x27;hello world&#x27;, 2)).toEqual(&#x27;OK&#x27;);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey&#x27;, &#x27;copyKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be return false when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey2&#x27;, &#x27;copyKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be rename a key&#x27;, async () =&gt; {\n    expect(await service.rename(&#x27;copyKey&#x27;, &#x27;newKey&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return false when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;testKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;newKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be flush all&#x27;, async () =&gt; {\n    expect(await service.flushAll()).toEqual(&#x27;OK&#x27;);\n    expect(await service.get(&#x27;myKey&#x27;)).toBeNull();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e7e0d3aa-fcfa-4d5b-af7f-c5fb96f66cec&quot;,&quot;parentUUID&quot;:&quot;f91a5298-822f-4969-b8a3-08efa9095d2a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;RedisService &gt; should be return OK when set value in redis&quot;,&quot;title&quot;:&quot;RedisService &gt; should be return OK when set value in redis&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { delay, tcName, TCRedisOptions, testContainers } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { RedisModule } from &#x27;../redis/redis.module&#x27;;\nimport { RedisService } from &#x27;../redis/services/redis.service&#x27;;\n\ndescribe(&#x27;RedisService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () =&gt; {\n    container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n      ...TCRedisOptions,\n      command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: &#x27;test-redis-module&#x27;,\n          username: encodeURIComponent(&#x27;default&#x27;),\n          password: encodeURIComponent(&#x27;123456&#x27;),\n          host: global.hostContainer,\n          port: parseInt(&#x27;6379&#x27;, 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, async () =&gt; {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it(&#x27;should be return echo&#x27;, async () =&gt; {\n    const msg = &#x27;hello world&#x27;;\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it(&#x27;should be return false if key dont exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return OK when set value in redis&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKey&#x27;, &#x27;hello world&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return value of key&#x27;, async () =&gt; {\n    expect(await service.get(&#x27;myKey&#x27;)).toEqual(&#x27;hello world&#x27;);\n  });\n\n  it(&#x27;should be return true if key exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be set value in redis with expiration date&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKeyEx&#x27;, &#x27;hello world&#x27;, 2)).toEqual(&#x27;OK&#x27;);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey&#x27;, &#x27;copyKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be return false when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey2&#x27;, &#x27;copyKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be rename a key&#x27;, async () =&gt; {\n    expect(await service.rename(&#x27;copyKey&#x27;, &#x27;newKey&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return false when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;testKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;newKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be flush all&#x27;, async () =&gt; {\n    expect(await service.flushAll()).toEqual(&#x27;OK&#x27;);\n    expect(await service.get(&#x27;myKey&#x27;)).toBeNull();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4eee2f73-b926-4739-8acb-453823c0ede6&quot;,&quot;parentUUID&quot;:&quot;f91a5298-822f-4969-b8a3-08efa9095d2a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;RedisService &gt; should be return value of key&quot;,&quot;title&quot;:&quot;RedisService &gt; should be return value of key&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:12,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { delay, tcName, TCRedisOptions, testContainers } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { RedisModule } from &#x27;../redis/redis.module&#x27;;\nimport { RedisService } from &#x27;../redis/services/redis.service&#x27;;\n\ndescribe(&#x27;RedisService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () =&gt; {\n    container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n      ...TCRedisOptions,\n      command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: &#x27;test-redis-module&#x27;,\n          username: encodeURIComponent(&#x27;default&#x27;),\n          password: encodeURIComponent(&#x27;123456&#x27;),\n          host: global.hostContainer,\n          port: parseInt(&#x27;6379&#x27;, 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, async () =&gt; {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it(&#x27;should be return echo&#x27;, async () =&gt; {\n    const msg = &#x27;hello world&#x27;;\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it(&#x27;should be return false if key dont exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return OK when set value in redis&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKey&#x27;, &#x27;hello world&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return value of key&#x27;, async () =&gt; {\n    expect(await service.get(&#x27;myKey&#x27;)).toEqual(&#x27;hello world&#x27;);\n  });\n\n  it(&#x27;should be return true if key exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be set value in redis with expiration date&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKeyEx&#x27;, &#x27;hello world&#x27;, 2)).toEqual(&#x27;OK&#x27;);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey&#x27;, &#x27;copyKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be return false when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey2&#x27;, &#x27;copyKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be rename a key&#x27;, async () =&gt; {\n    expect(await service.rename(&#x27;copyKey&#x27;, &#x27;newKey&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return false when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;testKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;newKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be flush all&#x27;, async () =&gt; {\n    expect(await service.flushAll()).toEqual(&#x27;OK&#x27;);\n    expect(await service.get(&#x27;myKey&#x27;)).toBeNull();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4896a766-6c8b-43b1-81df-9cc32fe7ea8a&quot;,&quot;parentUUID&quot;:&quot;f91a5298-822f-4969-b8a3-08efa9095d2a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;RedisService &gt; should be return true if key exist in redis&quot;,&quot;title&quot;:&quot;RedisService &gt; should be return true if key exist in redis&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:11,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { delay, tcName, TCRedisOptions, testContainers } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { RedisModule } from &#x27;../redis/redis.module&#x27;;\nimport { RedisService } from &#x27;../redis/services/redis.service&#x27;;\n\ndescribe(&#x27;RedisService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () =&gt; {\n    container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n      ...TCRedisOptions,\n      command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: &#x27;test-redis-module&#x27;,\n          username: encodeURIComponent(&#x27;default&#x27;),\n          password: encodeURIComponent(&#x27;123456&#x27;),\n          host: global.hostContainer,\n          port: parseInt(&#x27;6379&#x27;, 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, async () =&gt; {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it(&#x27;should be return echo&#x27;, async () =&gt; {\n    const msg = &#x27;hello world&#x27;;\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it(&#x27;should be return false if key dont exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return OK when set value in redis&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKey&#x27;, &#x27;hello world&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return value of key&#x27;, async () =&gt; {\n    expect(await service.get(&#x27;myKey&#x27;)).toEqual(&#x27;hello world&#x27;);\n  });\n\n  it(&#x27;should be return true if key exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be set value in redis with expiration date&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKeyEx&#x27;, &#x27;hello world&#x27;, 2)).toEqual(&#x27;OK&#x27;);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey&#x27;, &#x27;copyKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be return false when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey2&#x27;, &#x27;copyKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be rename a key&#x27;, async () =&gt; {\n    expect(await service.rename(&#x27;copyKey&#x27;, &#x27;newKey&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return false when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;testKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;newKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be flush all&#x27;, async () =&gt; {\n    expect(await service.flushAll()).toEqual(&#x27;OK&#x27;);\n    expect(await service.get(&#x27;myKey&#x27;)).toBeNull();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;61e780a8-1d7d-473d-ad3e-9ee5d5a69a81&quot;,&quot;parentUUID&quot;:&quot;f91a5298-822f-4969-b8a3-08efa9095d2a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;RedisService &gt; should be set value in redis with expiration date&quot;,&quot;title&quot;:&quot;RedisService &gt; should be set value in redis with expiration date&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3012,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { delay, tcName, TCRedisOptions, testContainers } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { RedisModule } from &#x27;../redis/redis.module&#x27;;\nimport { RedisService } from &#x27;../redis/services/redis.service&#x27;;\n\ndescribe(&#x27;RedisService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () =&gt; {\n    container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n      ...TCRedisOptions,\n      command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: &#x27;test-redis-module&#x27;,\n          username: encodeURIComponent(&#x27;default&#x27;),\n          password: encodeURIComponent(&#x27;123456&#x27;),\n          host: global.hostContainer,\n          port: parseInt(&#x27;6379&#x27;, 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, async () =&gt; {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it(&#x27;should be return echo&#x27;, async () =&gt; {\n    const msg = &#x27;hello world&#x27;;\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it(&#x27;should be return false if key dont exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return OK when set value in redis&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKey&#x27;, &#x27;hello world&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return value of key&#x27;, async () =&gt; {\n    expect(await service.get(&#x27;myKey&#x27;)).toEqual(&#x27;hello world&#x27;);\n  });\n\n  it(&#x27;should be return true if key exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be set value in redis with expiration date&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKeyEx&#x27;, &#x27;hello world&#x27;, 2)).toEqual(&#x27;OK&#x27;);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey&#x27;, &#x27;copyKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be return false when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey2&#x27;, &#x27;copyKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be rename a key&#x27;, async () =&gt; {\n    expect(await service.rename(&#x27;copyKey&#x27;, &#x27;newKey&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return false when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;testKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;newKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be flush all&#x27;, async () =&gt; {\n    expect(await service.flushAll()).toEqual(&#x27;OK&#x27;);\n    expect(await service.get(&#x27;myKey&#x27;)).toBeNull();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;8f59a20c-61a4-4ac2-bd92-0b6b28b2abf0&quot;,&quot;parentUUID&quot;:&quot;f91a5298-822f-4969-b8a3-08efa9095d2a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;RedisService &gt; should be return true when copy key&quot;,&quot;title&quot;:&quot;RedisService &gt; should be return true when copy key&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { delay, tcName, TCRedisOptions, testContainers } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { RedisModule } from &#x27;../redis/redis.module&#x27;;\nimport { RedisService } from &#x27;../redis/services/redis.service&#x27;;\n\ndescribe(&#x27;RedisService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () =&gt; {\n    container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n      ...TCRedisOptions,\n      command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: &#x27;test-redis-module&#x27;,\n          username: encodeURIComponent(&#x27;default&#x27;),\n          password: encodeURIComponent(&#x27;123456&#x27;),\n          host: global.hostContainer,\n          port: parseInt(&#x27;6379&#x27;, 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, async () =&gt; {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it(&#x27;should be return echo&#x27;, async () =&gt; {\n    const msg = &#x27;hello world&#x27;;\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it(&#x27;should be return false if key dont exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return OK when set value in redis&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKey&#x27;, &#x27;hello world&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return value of key&#x27;, async () =&gt; {\n    expect(await service.get(&#x27;myKey&#x27;)).toEqual(&#x27;hello world&#x27;);\n  });\n\n  it(&#x27;should be return true if key exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be set value in redis with expiration date&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKeyEx&#x27;, &#x27;hello world&#x27;, 2)).toEqual(&#x27;OK&#x27;);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey&#x27;, &#x27;copyKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be return false when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey2&#x27;, &#x27;copyKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be rename a key&#x27;, async () =&gt; {\n    expect(await service.rename(&#x27;copyKey&#x27;, &#x27;newKey&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return false when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;testKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;newKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be flush all&#x27;, async () =&gt; {\n    expect(await service.flushAll()).toEqual(&#x27;OK&#x27;);\n    expect(await service.get(&#x27;myKey&#x27;)).toBeNull();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2939e4b3-ffa7-4536-89ee-52cdfec2d7ea&quot;,&quot;parentUUID&quot;:&quot;f91a5298-822f-4969-b8a3-08efa9095d2a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;RedisService &gt; should be return false when copy key&quot;,&quot;title&quot;:&quot;RedisService &gt; should be return false when copy key&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:14,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { delay, tcName, TCRedisOptions, testContainers } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { RedisModule } from &#x27;../redis/redis.module&#x27;;\nimport { RedisService } from &#x27;../redis/services/redis.service&#x27;;\n\ndescribe(&#x27;RedisService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () =&gt; {\n    container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n      ...TCRedisOptions,\n      command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: &#x27;test-redis-module&#x27;,\n          username: encodeURIComponent(&#x27;default&#x27;),\n          password: encodeURIComponent(&#x27;123456&#x27;),\n          host: global.hostContainer,\n          port: parseInt(&#x27;6379&#x27;, 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, async () =&gt; {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it(&#x27;should be return echo&#x27;, async () =&gt; {\n    const msg = &#x27;hello world&#x27;;\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it(&#x27;should be return false if key dont exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return OK when set value in redis&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKey&#x27;, &#x27;hello world&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return value of key&#x27;, async () =&gt; {\n    expect(await service.get(&#x27;myKey&#x27;)).toEqual(&#x27;hello world&#x27;);\n  });\n\n  it(&#x27;should be return true if key exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be set value in redis with expiration date&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKeyEx&#x27;, &#x27;hello world&#x27;, 2)).toEqual(&#x27;OK&#x27;);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey&#x27;, &#x27;copyKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be return false when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey2&#x27;, &#x27;copyKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be rename a key&#x27;, async () =&gt; {\n    expect(await service.rename(&#x27;copyKey&#x27;, &#x27;newKey&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return false when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;testKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;newKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be flush all&#x27;, async () =&gt; {\n    expect(await service.flushAll()).toEqual(&#x27;OK&#x27;);\n    expect(await service.get(&#x27;myKey&#x27;)).toBeNull();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7b30220a-9d35-4f08-ba46-c9e6be550f43&quot;,&quot;parentUUID&quot;:&quot;f91a5298-822f-4969-b8a3-08efa9095d2a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;RedisService &gt; should be rename a key&quot;,&quot;title&quot;:&quot;RedisService &gt; should be rename a key&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:11,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { delay, tcName, TCRedisOptions, testContainers } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { RedisModule } from &#x27;../redis/redis.module&#x27;;\nimport { RedisService } from &#x27;../redis/services/redis.service&#x27;;\n\ndescribe(&#x27;RedisService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () =&gt; {\n    container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n      ...TCRedisOptions,\n      command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: &#x27;test-redis-module&#x27;,\n          username: encodeURIComponent(&#x27;default&#x27;),\n          password: encodeURIComponent(&#x27;123456&#x27;),\n          host: global.hostContainer,\n          port: parseInt(&#x27;6379&#x27;, 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, async () =&gt; {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it(&#x27;should be return echo&#x27;, async () =&gt; {\n    const msg = &#x27;hello world&#x27;;\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it(&#x27;should be return false if key dont exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return OK when set value in redis&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKey&#x27;, &#x27;hello world&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return value of key&#x27;, async () =&gt; {\n    expect(await service.get(&#x27;myKey&#x27;)).toEqual(&#x27;hello world&#x27;);\n  });\n\n  it(&#x27;should be return true if key exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be set value in redis with expiration date&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKeyEx&#x27;, &#x27;hello world&#x27;, 2)).toEqual(&#x27;OK&#x27;);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey&#x27;, &#x27;copyKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be return false when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey2&#x27;, &#x27;copyKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be rename a key&#x27;, async () =&gt; {\n    expect(await service.rename(&#x27;copyKey&#x27;, &#x27;newKey&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return false when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;testKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;newKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be flush all&#x27;, async () =&gt; {\n    expect(await service.flushAll()).toEqual(&#x27;OK&#x27;);\n    expect(await service.get(&#x27;myKey&#x27;)).toBeNull();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;188a1188-caeb-4b59-8c4f-962cdac2e070&quot;,&quot;parentUUID&quot;:&quot;f91a5298-822f-4969-b8a3-08efa9095d2a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;RedisService &gt; should be return false when delete a key&quot;,&quot;title&quot;:&quot;RedisService &gt; should be return false when delete a key&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { delay, tcName, TCRedisOptions, testContainers } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { RedisModule } from &#x27;../redis/redis.module&#x27;;\nimport { RedisService } from &#x27;../redis/services/redis.service&#x27;;\n\ndescribe(&#x27;RedisService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () =&gt; {\n    container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n      ...TCRedisOptions,\n      command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: &#x27;test-redis-module&#x27;,\n          username: encodeURIComponent(&#x27;default&#x27;),\n          password: encodeURIComponent(&#x27;123456&#x27;),\n          host: global.hostContainer,\n          port: parseInt(&#x27;6379&#x27;, 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, async () =&gt; {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it(&#x27;should be return echo&#x27;, async () =&gt; {\n    const msg = &#x27;hello world&#x27;;\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it(&#x27;should be return false if key dont exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return OK when set value in redis&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKey&#x27;, &#x27;hello world&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return value of key&#x27;, async () =&gt; {\n    expect(await service.get(&#x27;myKey&#x27;)).toEqual(&#x27;hello world&#x27;);\n  });\n\n  it(&#x27;should be return true if key exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be set value in redis with expiration date&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKeyEx&#x27;, &#x27;hello world&#x27;, 2)).toEqual(&#x27;OK&#x27;);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey&#x27;, &#x27;copyKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be return false when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey2&#x27;, &#x27;copyKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be rename a key&#x27;, async () =&gt; {\n    expect(await service.rename(&#x27;copyKey&#x27;, &#x27;newKey&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return false when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;testKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;newKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be flush all&#x27;, async () =&gt; {\n    expect(await service.flushAll()).toEqual(&#x27;OK&#x27;);\n    expect(await service.get(&#x27;myKey&#x27;)).toBeNull();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;76ce8772-8a75-4b7b-87f3-cd755fb1b4bd&quot;,&quot;parentUUID&quot;:&quot;f91a5298-822f-4969-b8a3-08efa9095d2a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;RedisService &gt; should be return true when delete a key&quot;,&quot;title&quot;:&quot;RedisService &gt; should be return true when delete a key&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:14,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { delay, tcName, TCRedisOptions, testContainers } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { RedisModule } from &#x27;../redis/redis.module&#x27;;\nimport { RedisService } from &#x27;../redis/services/redis.service&#x27;;\n\ndescribe(&#x27;RedisService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () =&gt; {\n    container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n      ...TCRedisOptions,\n      command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: &#x27;test-redis-module&#x27;,\n          username: encodeURIComponent(&#x27;default&#x27;),\n          password: encodeURIComponent(&#x27;123456&#x27;),\n          host: global.hostContainer,\n          port: parseInt(&#x27;6379&#x27;, 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, async () =&gt; {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it(&#x27;should be return echo&#x27;, async () =&gt; {\n    const msg = &#x27;hello world&#x27;;\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it(&#x27;should be return false if key dont exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return OK when set value in redis&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKey&#x27;, &#x27;hello world&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return value of key&#x27;, async () =&gt; {\n    expect(await service.get(&#x27;myKey&#x27;)).toEqual(&#x27;hello world&#x27;);\n  });\n\n  it(&#x27;should be return true if key exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be set value in redis with expiration date&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKeyEx&#x27;, &#x27;hello world&#x27;, 2)).toEqual(&#x27;OK&#x27;);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey&#x27;, &#x27;copyKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be return false when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey2&#x27;, &#x27;copyKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be rename a key&#x27;, async () =&gt; {\n    expect(await service.rename(&#x27;copyKey&#x27;, &#x27;newKey&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return false when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;testKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;newKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be flush all&#x27;, async () =&gt; {\n    expect(await service.flushAll()).toEqual(&#x27;OK&#x27;);\n    expect(await service.get(&#x27;myKey&#x27;)).toBeNull();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f891fddd-37e9-454f-82d1-b3415d67c742&quot;,&quot;parentUUID&quot;:&quot;f91a5298-822f-4969-b8a3-08efa9095d2a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;RedisService &gt; should be flush all&quot;,&quot;title&quot;:&quot;RedisService &gt; should be flush all&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:14,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { delay, tcName, TCRedisOptions, testContainers } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { RedisModule } from &#x27;../redis/redis.module&#x27;;\nimport { RedisService } from &#x27;../redis/services/redis.service&#x27;;\n\ndescribe(&#x27;RedisService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () =&gt; {\n    container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n      ...TCRedisOptions,\n      command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: &#x27;test-redis-module&#x27;,\n          username: encodeURIComponent(&#x27;default&#x27;),\n          password: encodeURIComponent(&#x27;123456&#x27;),\n          host: global.hostContainer,\n          port: parseInt(&#x27;6379&#x27;, 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, async () =&gt; {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it(&#x27;should be return echo&#x27;, async () =&gt; {\n    const msg = &#x27;hello world&#x27;;\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it(&#x27;should be return false if key dont exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return OK when set value in redis&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKey&#x27;, &#x27;hello world&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return value of key&#x27;, async () =&gt; {\n    expect(await service.get(&#x27;myKey&#x27;)).toEqual(&#x27;hello world&#x27;);\n  });\n\n  it(&#x27;should be return true if key exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be set value in redis with expiration date&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKeyEx&#x27;, &#x27;hello world&#x27;, 2)).toEqual(&#x27;OK&#x27;);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey&#x27;, &#x27;copyKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be return false when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey2&#x27;, &#x27;copyKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be rename a key&#x27;, async () =&gt; {\n    expect(await service.rename(&#x27;copyKey&#x27;, &#x27;newKey&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return false when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;testKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;newKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be flush all&#x27;, async () =&gt; {\n    expect(await service.flushAll()).toEqual(&#x27;OK&#x27;);\n    expect(await service.get(&#x27;myKey&#x27;)).toBeNull();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a2ef4bba-8989-44ed-9590-8114f74e4552&quot;,&quot;parentUUID&quot;:&quot;f91a5298-822f-4969-b8a3-08efa9095d2a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;RedisModule &gt; with auth &gt; forRootAsync &gt; should be defined&quot;,&quot;title&quot;:&quot;RedisModule &gt; with auth &gt; forRootAsync &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:109,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport { tcName, TCRedisOptions, testContainers } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\n\nimport { RedisModule } from &#x27;../redis/redis.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;RedisModule&#x27;, () =&gt; {\n  describe(&#x27;with auth&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n        containerName: `${tcName}-redis-module-with-auth`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    describe(&#x27;forRootAsync&#x27;, () =&gt; {\n      beforeEach(async () =&gt; {\n        const module: TestingModule = await Test.createTestingModule({\n          imports: [\n            ConfigModule.forRoot({\n              isGlobal: true,\n              load: [config],\n            }),\n            RedisModule,\n          ],\n        }).compile();\n\n        app = module.createNestApplication();\n        await app.init();\n      });\n\n      afterEach(async () =&gt; {\n        await app.close();\n      });\n\n      it(&#x27;should be defined&#x27;, async () =&gt; {\n        await expect(app).toBeDefined();\n      }, 50000);\n    });\n\n    describe(&#x27;register&#x27;, () =&gt; {\n      beforeEach(async () =&gt; {\n        const module: TestingModule = await Test.createTestingModule({\n          imports: [\n            RedisModule.register({\n              name: &#x27;test-redis-module&#x27;,\n              username: encodeURIComponent(&#x27;default&#x27;),\n              password: encodeURIComponent(&#x27;123456&#x27;),\n              host: global.hostContainer,\n              port: parseInt(&#x27;6379&#x27;, 10),\n            }),\n          ],\n        }).compile();\n\n        app = module.createNestApplication();\n        await app.init();\n      });\n\n      afterEach(async () =&gt; {\n        await app.close();\n      });\n\n      it(&#x27;should be defined&#x27;, async () =&gt; {\n        await expect(app).toBeDefined();\n      }, 50000);\n    });\n  });\n\n  describe(&#x27;without auth&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        containerName: `${tcName}-redis-module-without-auth`,\n        envs: {},\n        ports: [\n          {\n            container: 6379,\n            host: 6380,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          RedisModule.register({\n            host: global.hostContainer,\n            port: parseInt(&#x27;6380&#x27;, 10),\n            database: 1,\n          }),\n        ],\n      }).compile();\n\n      app = module.createNestApplication();\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1aef0271-9816-4181-ba86-e2096f1bc6e6&quot;,&quot;parentUUID&quot;:&quot;f91a5298-822f-4969-b8a3-08efa9095d2a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;RedisModule &gt; with auth &gt; register &gt; should be defined&quot;,&quot;title&quot;:&quot;RedisModule &gt; with auth &gt; register &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport { tcName, TCRedisOptions, testContainers } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\n\nimport { RedisModule } from &#x27;../redis/redis.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;RedisModule&#x27;, () =&gt; {\n  describe(&#x27;with auth&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n        containerName: `${tcName}-redis-module-with-auth`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    describe(&#x27;forRootAsync&#x27;, () =&gt; {\n      beforeEach(async () =&gt; {\n        const module: TestingModule = await Test.createTestingModule({\n          imports: [\n            ConfigModule.forRoot({\n              isGlobal: true,\n              load: [config],\n            }),\n            RedisModule,\n          ],\n        }).compile();\n\n        app = module.createNestApplication();\n        await app.init();\n      });\n\n      afterEach(async () =&gt; {\n        await app.close();\n      });\n\n      it(&#x27;should be defined&#x27;, async () =&gt; {\n        await expect(app).toBeDefined();\n      }, 50000);\n    });\n\n    describe(&#x27;register&#x27;, () =&gt; {\n      beforeEach(async () =&gt; {\n        const module: TestingModule = await Test.createTestingModule({\n          imports: [\n            RedisModule.register({\n              name: &#x27;test-redis-module&#x27;,\n              username: encodeURIComponent(&#x27;default&#x27;),\n              password: encodeURIComponent(&#x27;123456&#x27;),\n              host: global.hostContainer,\n              port: parseInt(&#x27;6379&#x27;, 10),\n            }),\n          ],\n        }).compile();\n\n        app = module.createNestApplication();\n        await app.init();\n      });\n\n      afterEach(async () =&gt; {\n        await app.close();\n      });\n\n      it(&#x27;should be defined&#x27;, async () =&gt; {\n        await expect(app).toBeDefined();\n      }, 50000);\n    });\n  });\n\n  describe(&#x27;without auth&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        containerName: `${tcName}-redis-module-without-auth`,\n        envs: {},\n        ports: [\n          {\n            container: 6379,\n            host: 6380,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          RedisModule.register({\n            host: global.hostContainer,\n            port: parseInt(&#x27;6380&#x27;, 10),\n            database: 1,\n          }),\n        ],\n      }).compile();\n\n      app = module.createNestApplication();\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c53da8e0-f2ee-4a08-9d40-fca870c98a52&quot;,&quot;parentUUID&quot;:&quot;f91a5298-822f-4969-b8a3-08efa9095d2a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;RedisModule &gt; without auth &gt; should be defined&quot;,&quot;title&quot;:&quot;RedisModule &gt; without auth &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport { tcName, TCRedisOptions, testContainers } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\n\nimport { RedisModule } from &#x27;../redis/redis.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;RedisModule&#x27;, () =&gt; {\n  describe(&#x27;with auth&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n        containerName: `${tcName}-redis-module-with-auth`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    describe(&#x27;forRootAsync&#x27;, () =&gt; {\n      beforeEach(async () =&gt; {\n        const module: TestingModule = await Test.createTestingModule({\n          imports: [\n            ConfigModule.forRoot({\n              isGlobal: true,\n              load: [config],\n            }),\n            RedisModule,\n          ],\n        }).compile();\n\n        app = module.createNestApplication();\n        await app.init();\n      });\n\n      afterEach(async () =&gt; {\n        await app.close();\n      });\n\n      it(&#x27;should be defined&#x27;, async () =&gt; {\n        await expect(app).toBeDefined();\n      }, 50000);\n    });\n\n    describe(&#x27;register&#x27;, () =&gt; {\n      beforeEach(async () =&gt; {\n        const module: TestingModule = await Test.createTestingModule({\n          imports: [\n            RedisModule.register({\n              name: &#x27;test-redis-module&#x27;,\n              username: encodeURIComponent(&#x27;default&#x27;),\n              password: encodeURIComponent(&#x27;123456&#x27;),\n              host: global.hostContainer,\n              port: parseInt(&#x27;6379&#x27;, 10),\n            }),\n          ],\n        }).compile();\n\n        app = module.createNestApplication();\n        await app.init();\n      });\n\n      afterEach(async () =&gt; {\n        await app.close();\n      });\n\n      it(&#x27;should be defined&#x27;, async () =&gt; {\n        await expect(app).toBeDefined();\n      }, 50000);\n    });\n  });\n\n  describe(&#x27;without auth&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        containerName: `${tcName}-redis-module-without-auth`,\n        envs: {},\n        ports: [\n          {\n            container: 6379,\n            host: 6380,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          RedisModule.register({\n            host: global.hostContainer,\n            port: parseInt(&#x27;6380&#x27;, 10),\n            database: 1,\n          }),\n        ],\n      }).compile();\n\n      app = module.createNestApplication();\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;15491cc9-1c61-4432-acff-d65b426d82ce&quot;,&quot;parentUUID&quot;:&quot;f91a5298-822f-4969-b8a3-08efa9095d2a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;736d0be0-4533-47b2-90b9-c64749567884&quot;,&quot;7dfeb273-b8bb-441d-a8f9-7389891ca300&quot;,&quot;e7e0d3aa-fcfa-4d5b-af7f-c5fb96f66cec&quot;,&quot;4eee2f73-b926-4739-8acb-453823c0ede6&quot;,&quot;4896a766-6c8b-43b1-81df-9cc32fe7ea8a&quot;,&quot;61e780a8-1d7d-473d-ad3e-9ee5d5a69a81&quot;,&quot;8f59a20c-61a4-4ac2-bd92-0b6b28b2abf0&quot;,&quot;2939e4b3-ffa7-4536-89ee-52cdfec2d7ea&quot;,&quot;7b30220a-9d35-4f08-ba46-c9e6be550f43&quot;,&quot;188a1188-caeb-4b59-8c4f-962cdac2e070&quot;,&quot;76ce8772-8a75-4b7b-87f3-cd755fb1b4bd&quot;,&quot;f891fddd-37e9-454f-82d1-b3415d67c742&quot;,&quot;a2ef4bba-8989-44ed-9590-8114f74e4552&quot;,&quot;1aef0271-9816-4181-ba86-e2096f1bc6e6&quot;,&quot;c53da8e0-f2ee-4a08-9d40-fca870c98a52&quot;,&quot;15491cc9-1c61-4432-acff-d65b426d82ce&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:3465,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:5000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:5000},{&quot;uuid&quot;:&quot;dfb2f10c-5f41-451a-bedd-553050ea2f1b&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/response-parser&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;1beb1fec-473e-4439-a467-4590ee0f9733&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/response-parser&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;fullTitle&quot;:&quot;ResponseInterceptor &gt; should be defined&quot;,&quot;title&quot;:&quot;ResponseInterceptor &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { ResponseInterceptor } from &#x27;../response/response.interceptor&#x27;;\nimport {\n  JestFN,\n  fixtureUserResponse,\n  fixtureUserArrayResponse,\n} from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { of } from &#x27;rxjs&#x27;;\n\nconst executionContext: any = JestFN.executionContext;\n\ndescribe(&#x27;ResponseInterceptor&#x27;, () =&gt; {\n  let interceptor = new ResponseInterceptor();\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(interceptor).toBeDefined();\n  });\n\n  it(&#x27;should return an ResponseInterceptor instance simple entity&#x27;, (done) =&gt; {\n    const callHandler: any = {\n      handle: jest.fn(() =&gt; of(fixtureUserResponse)),\n    };\n\n    const obs = interceptor.intercept(executionContext, callHandler);\n    expect(callHandler.handle).toBeCalledTimes(1);\n\n    obs.subscribe({\n      next: (value) =&gt; {\n        expect(value).toMatchObject(fixtureUserResponse);\n      },\n      error: (error) =&gt; {\n        throw error;\n      },\n      complete: () =&gt; {\n        done();\n      },\n    });\n  });\n\n  it(&#x27;should return an ResponseInterceptor instance multiple entity&#x27;, (done) =&gt; {\n    const callHandler: any = {\n      handle: jest.fn(() =&gt; of(fixtureUserArrayResponse)),\n    };\n    const obs = interceptor.intercept(executionContext, callHandler);\n    expect(callHandler.handle).toBeCalledTimes(1);\n\n    obs.subscribe({\n      next: (value) =&gt; {\n        expect(value).toMatchObject({ data: fixtureUserArrayResponse });\n      },\n      error: (error) =&gt; {\n        throw error;\n      },\n      complete: () =&gt; {\n        done();\n      },\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9d0e654b-17f9-412d-8b7c-1e3fe28d9616&quot;,&quot;parentUUID&quot;:&quot;1beb1fec-473e-4439-a467-4590ee0f9733&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;ResponseInterceptor &gt; should return an ResponseInterceptor instance simple entity&quot;,&quot;title&quot;:&quot;ResponseInterceptor &gt; should return an ResponseInterceptor instance simple entity&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { ResponseInterceptor } from &#x27;../response/response.interceptor&#x27;;\nimport {\n  JestFN,\n  fixtureUserResponse,\n  fixtureUserArrayResponse,\n} from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { of } from &#x27;rxjs&#x27;;\n\nconst executionContext: any = JestFN.executionContext;\n\ndescribe(&#x27;ResponseInterceptor&#x27;, () =&gt; {\n  let interceptor = new ResponseInterceptor();\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(interceptor).toBeDefined();\n  });\n\n  it(&#x27;should return an ResponseInterceptor instance simple entity&#x27;, (done) =&gt; {\n    const callHandler: any = {\n      handle: jest.fn(() =&gt; of(fixtureUserResponse)),\n    };\n\n    const obs = interceptor.intercept(executionContext, callHandler);\n    expect(callHandler.handle).toBeCalledTimes(1);\n\n    obs.subscribe({\n      next: (value) =&gt; {\n        expect(value).toMatchObject(fixtureUserResponse);\n      },\n      error: (error) =&gt; {\n        throw error;\n      },\n      complete: () =&gt; {\n        done();\n      },\n    });\n  });\n\n  it(&#x27;should return an ResponseInterceptor instance multiple entity&#x27;, (done) =&gt; {\n    const callHandler: any = {\n      handle: jest.fn(() =&gt; of(fixtureUserArrayResponse)),\n    };\n    const obs = interceptor.intercept(executionContext, callHandler);\n    expect(callHandler.handle).toBeCalledTimes(1);\n\n    obs.subscribe({\n      next: (value) =&gt; {\n        expect(value).toMatchObject({ data: fixtureUserArrayResponse });\n      },\n      error: (error) =&gt; {\n        throw error;\n      },\n      complete: () =&gt; {\n        done();\n      },\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;fe0308c7-8df2-4cc8-89c0-d95401759fe1&quot;,&quot;parentUUID&quot;:&quot;1beb1fec-473e-4439-a467-4590ee0f9733&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;ResponseInterceptor &gt; should return an ResponseInterceptor instance multiple entity&quot;,&quot;title&quot;:&quot;ResponseInterceptor &gt; should return an ResponseInterceptor instance multiple entity&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { ResponseInterceptor } from &#x27;../response/response.interceptor&#x27;;\nimport {\n  JestFN,\n  fixtureUserResponse,\n  fixtureUserArrayResponse,\n} from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { of } from &#x27;rxjs&#x27;;\n\nconst executionContext: any = JestFN.executionContext;\n\ndescribe(&#x27;ResponseInterceptor&#x27;, () =&gt; {\n  let interceptor = new ResponseInterceptor();\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(interceptor).toBeDefined();\n  });\n\n  it(&#x27;should return an ResponseInterceptor instance simple entity&#x27;, (done) =&gt; {\n    const callHandler: any = {\n      handle: jest.fn(() =&gt; of(fixtureUserResponse)),\n    };\n\n    const obs = interceptor.intercept(executionContext, callHandler);\n    expect(callHandler.handle).toBeCalledTimes(1);\n\n    obs.subscribe({\n      next: (value) =&gt; {\n        expect(value).toMatchObject(fixtureUserResponse);\n      },\n      error: (error) =&gt; {\n        throw error;\n      },\n      complete: () =&gt; {\n        done();\n      },\n    });\n  });\n\n  it(&#x27;should return an ResponseInterceptor instance multiple entity&#x27;, (done) =&gt; {\n    const callHandler: any = {\n      handle: jest.fn(() =&gt; of(fixtureUserArrayResponse)),\n    };\n    const obs = interceptor.intercept(executionContext, callHandler);\n    expect(callHandler.handle).toBeCalledTimes(1);\n\n    obs.subscribe({\n      next: (value) =&gt; {\n        expect(value).toMatchObject({ data: fixtureUserArrayResponse });\n      },\n      error: (error) =&gt; {\n        throw error;\n      },\n      complete: () =&gt; {\n        done();\n      },\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;32deb931-f75d-4711-aa56-1142ff35b08d&quot;,&quot;parentUUID&quot;:&quot;1beb1fec-473e-4439-a467-4590ee0f9733&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;9d0e654b-17f9-412d-8b7c-1e3fe28d9616&quot;,&quot;fe0308c7-8df2-4cc8-89c0-d95401759fe1&quot;,&quot;32deb931-f75d-4711-aa56-1142ff35b08d&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:6,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:5000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:5000},{&quot;uuid&quot;:&quot;dea4d602-c5db-4133-975e-de6213f9c1f6&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/test-utils&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;955034f6-e2ee-42f4-a3df-bd65c23b6c64&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/test-utils&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;fullTitle&quot;:&quot;globalTestContainers &gt; should be initialize service from docker-compose.yml&quot;,&quot;title&quot;:&quot;globalTestContainers &gt; should be initialize service from docker-compose.yml&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13505,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { StartedDockerComposeEnvironment } from &#x27;testcontainers&#x27;;\nimport { closeDockerCompose, initDockerCompose } from &#x27;../testcontainers&#x27;;\nimport path from &#x27;path&#x27;;\n\ndescribe(&#x27;globalTestContainers&#x27;, () =&gt; {\n  const composeFilePath = path.resolve(__dirname, &#x27;..&#x27;, &#x27;fixtures&#x27;, &#x27;docker-compose&#x27;);\n  const composeFile = &#x27;docker-compose.yml&#x27;;\n\n  it(&#x27;should be initialize service from docker-compose.yml&#x27;, async () =&gt; {\n    const services = [&#x27;mongo&#x27;];\n    const environment: StartedDockerComposeEnvironment = await initDockerCompose(\n      services,\n      composeFilePath,\n      composeFile,\n    )();\n    expect(environment).toBeDefined();\n    expect(environment).toBeInstanceOf(StartedDockerComposeEnvironment);\n    await closeDockerCompose({ removeVolumes: true })();\n  });\n\n  it(&#x27;should be initialize all services from docker-compose.yml&#x27;, async () =&gt; {\n    const services = [];\n    const environment: StartedDockerComposeEnvironment = await initDockerCompose(\n      services,\n      composeFilePath,\n      composeFile,\n    )();\n    expect(environment).toBeDefined();\n    expect(environment).toBeInstanceOf(StartedDockerComposeEnvironment);\n    await closeDockerCompose({ removeVolumes: true })();\n  });\n\n  it(&#x27;should be initialize services from docker-compose.yml in default path and filename&#x27;, async () =&gt; {\n    const services = [];\n    const environment: StartedDockerComposeEnvironment = await initDockerCompose(services)();\n    expect(environment).toBeDefined();\n    expect(environment).toBeInstanceOf(StartedDockerComposeEnvironment);\n    await closeDockerCompose({ removeVolumes: true })();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1bb3bed5-4684-4710-ba85-a4b285791c0c&quot;,&quot;parentUUID&quot;:&quot;955034f6-e2ee-42f4-a3df-bd65c23b6c64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;globalTestContainers &gt; should be initialize all services from docker-compose.yml&quot;,&quot;title&quot;:&quot;globalTestContainers &gt; should be initialize all services from docker-compose.yml&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:14563,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { StartedDockerComposeEnvironment } from &#x27;testcontainers&#x27;;\nimport { closeDockerCompose, initDockerCompose } from &#x27;../testcontainers&#x27;;\nimport path from &#x27;path&#x27;;\n\ndescribe(&#x27;globalTestContainers&#x27;, () =&gt; {\n  const composeFilePath = path.resolve(__dirname, &#x27;..&#x27;, &#x27;fixtures&#x27;, &#x27;docker-compose&#x27;);\n  const composeFile = &#x27;docker-compose.yml&#x27;;\n\n  it(&#x27;should be initialize service from docker-compose.yml&#x27;, async () =&gt; {\n    const services = [&#x27;mongo&#x27;];\n    const environment: StartedDockerComposeEnvironment = await initDockerCompose(\n      services,\n      composeFilePath,\n      composeFile,\n    )();\n    expect(environment).toBeDefined();\n    expect(environment).toBeInstanceOf(StartedDockerComposeEnvironment);\n    await closeDockerCompose({ removeVolumes: true })();\n  });\n\n  it(&#x27;should be initialize all services from docker-compose.yml&#x27;, async () =&gt; {\n    const services = [];\n    const environment: StartedDockerComposeEnvironment = await initDockerCompose(\n      services,\n      composeFilePath,\n      composeFile,\n    )();\n    expect(environment).toBeDefined();\n    expect(environment).toBeInstanceOf(StartedDockerComposeEnvironment);\n    await closeDockerCompose({ removeVolumes: true })();\n  });\n\n  it(&#x27;should be initialize services from docker-compose.yml in default path and filename&#x27;, async () =&gt; {\n    const services = [];\n    const environment: StartedDockerComposeEnvironment = await initDockerCompose(services)();\n    expect(environment).toBeDefined();\n    expect(environment).toBeInstanceOf(StartedDockerComposeEnvironment);\n    await closeDockerCompose({ removeVolumes: true })();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;176e46ee-fd85-43f1-bc1e-209c013df4ba&quot;,&quot;parentUUID&quot;:&quot;955034f6-e2ee-42f4-a3df-bd65c23b6c64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;globalTestContainers &gt; should be initialize services from docker-compose.yml in default path and filename&quot;,&quot;title&quot;:&quot;globalTestContainers &gt; should be initialize services from docker-compose.yml in default path and filename&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:11929,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { StartedDockerComposeEnvironment } from &#x27;testcontainers&#x27;;\nimport { closeDockerCompose, initDockerCompose } from &#x27;../testcontainers&#x27;;\nimport path from &#x27;path&#x27;;\n\ndescribe(&#x27;globalTestContainers&#x27;, () =&gt; {\n  const composeFilePath = path.resolve(__dirname, &#x27;..&#x27;, &#x27;fixtures&#x27;, &#x27;docker-compose&#x27;);\n  const composeFile = &#x27;docker-compose.yml&#x27;;\n\n  it(&#x27;should be initialize service from docker-compose.yml&#x27;, async () =&gt; {\n    const services = [&#x27;mongo&#x27;];\n    const environment: StartedDockerComposeEnvironment = await initDockerCompose(\n      services,\n      composeFilePath,\n      composeFile,\n    )();\n    expect(environment).toBeDefined();\n    expect(environment).toBeInstanceOf(StartedDockerComposeEnvironment);\n    await closeDockerCompose({ removeVolumes: true })();\n  });\n\n  it(&#x27;should be initialize all services from docker-compose.yml&#x27;, async () =&gt; {\n    const services = [];\n    const environment: StartedDockerComposeEnvironment = await initDockerCompose(\n      services,\n      composeFilePath,\n      composeFile,\n    )();\n    expect(environment).toBeDefined();\n    expect(environment).toBeInstanceOf(StartedDockerComposeEnvironment);\n    await closeDockerCompose({ removeVolumes: true })();\n  });\n\n  it(&#x27;should be initialize services from docker-compose.yml in default path and filename&#x27;, async () =&gt; {\n    const services = [];\n    const environment: StartedDockerComposeEnvironment = await initDockerCompose(services)();\n    expect(environment).toBeDefined();\n    expect(environment).toBeInstanceOf(StartedDockerComposeEnvironment);\n    await closeDockerCompose({ removeVolumes: true })();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b935cc87-5a41-4248-87c3-891cc7c2dac4&quot;,&quot;parentUUID&quot;:&quot;955034f6-e2ee-42f4-a3df-bd65c23b6c64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;TestContainers &gt; Redis &gt; should be defined&quot;,&quot;title&quot;:&quot;TestContainers &gt; Redis &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { testContainers } from &#x27;../testcontainers&#x27;;\nimport { StartedGenericContainer } from &#x27;testcontainers/dist/src/generic-container/started-generic-container&#x27;;\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from &#x27;../fixtures&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TestContainers&#x27;, () =&gt; {\n  describe(&#x27;Redis&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return exception of instance&#x27;, async () =&gt; {\n      try {\n        await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe(&#x27;Use testContainers.getInstance() instead of new.&#x27;);\n      }\n    });\n\n    it(&#x27;should be get instance of test container&#x27;, () =&gt; {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return envs of instance&#x27;, () =&gt; {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it(&#x27;should be return container instance&#x27;, () =&gt; {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it(&#x27;should be return host of container instance&#x27;, () =&gt; {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual(&#x27;localhost&#x27;);\n    });\n\n    it(&#x27;should be return name of container instance&#x27;, () =&gt; {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it(&#x27;should be return mapped port&#x27;, () =&gt; {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe(&#x27;DynamoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;amazon/dynamodb-local:latest&#x27;, {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MongoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;ElasticSearch&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2fda0ca2-8b42-4094-9428-a9c26cbfcd0f&quot;,&quot;parentUUID&quot;:&quot;955034f6-e2ee-42f4-a3df-bd65c23b6c64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;TestContainers &gt; Redis &gt; should be return exception of instance&quot;,&quot;title&quot;:&quot;TestContainers &gt; Redis &gt; should be return exception of instance&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { testContainers } from &#x27;../testcontainers&#x27;;\nimport { StartedGenericContainer } from &#x27;testcontainers/dist/src/generic-container/started-generic-container&#x27;;\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from &#x27;../fixtures&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TestContainers&#x27;, () =&gt; {\n  describe(&#x27;Redis&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return exception of instance&#x27;, async () =&gt; {\n      try {\n        await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe(&#x27;Use testContainers.getInstance() instead of new.&#x27;);\n      }\n    });\n\n    it(&#x27;should be get instance of test container&#x27;, () =&gt; {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return envs of instance&#x27;, () =&gt; {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it(&#x27;should be return container instance&#x27;, () =&gt; {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it(&#x27;should be return host of container instance&#x27;, () =&gt; {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual(&#x27;localhost&#x27;);\n    });\n\n    it(&#x27;should be return name of container instance&#x27;, () =&gt; {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it(&#x27;should be return mapped port&#x27;, () =&gt; {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe(&#x27;DynamoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;amazon/dynamodb-local:latest&#x27;, {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MongoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;ElasticSearch&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;68b721a3-fcdb-4c12-bd58-f9d71e7be663&quot;,&quot;parentUUID&quot;:&quot;955034f6-e2ee-42f4-a3df-bd65c23b6c64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;TestContainers &gt; Redis &gt; should be get instance of test container&quot;,&quot;title&quot;:&quot;TestContainers &gt; Redis &gt; should be get instance of test container&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:0,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { testContainers } from &#x27;../testcontainers&#x27;;\nimport { StartedGenericContainer } from &#x27;testcontainers/dist/src/generic-container/started-generic-container&#x27;;\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from &#x27;../fixtures&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TestContainers&#x27;, () =&gt; {\n  describe(&#x27;Redis&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return exception of instance&#x27;, async () =&gt; {\n      try {\n        await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe(&#x27;Use testContainers.getInstance() instead of new.&#x27;);\n      }\n    });\n\n    it(&#x27;should be get instance of test container&#x27;, () =&gt; {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return envs of instance&#x27;, () =&gt; {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it(&#x27;should be return container instance&#x27;, () =&gt; {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it(&#x27;should be return host of container instance&#x27;, () =&gt; {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual(&#x27;localhost&#x27;);\n    });\n\n    it(&#x27;should be return name of container instance&#x27;, () =&gt; {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it(&#x27;should be return mapped port&#x27;, () =&gt; {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe(&#x27;DynamoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;amazon/dynamodb-local:latest&#x27;, {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MongoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;ElasticSearch&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;039a5bd4-04bf-4a64-9b03-644a327641a6&quot;,&quot;parentUUID&quot;:&quot;955034f6-e2ee-42f4-a3df-bd65c23b6c64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;TestContainers &gt; Redis &gt; should be return envs of instance&quot;,&quot;title&quot;:&quot;TestContainers &gt; Redis &gt; should be return envs of instance&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { testContainers } from &#x27;../testcontainers&#x27;;\nimport { StartedGenericContainer } from &#x27;testcontainers/dist/src/generic-container/started-generic-container&#x27;;\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from &#x27;../fixtures&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TestContainers&#x27;, () =&gt; {\n  describe(&#x27;Redis&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return exception of instance&#x27;, async () =&gt; {\n      try {\n        await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe(&#x27;Use testContainers.getInstance() instead of new.&#x27;);\n      }\n    });\n\n    it(&#x27;should be get instance of test container&#x27;, () =&gt; {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return envs of instance&#x27;, () =&gt; {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it(&#x27;should be return container instance&#x27;, () =&gt; {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it(&#x27;should be return host of container instance&#x27;, () =&gt; {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual(&#x27;localhost&#x27;);\n    });\n\n    it(&#x27;should be return name of container instance&#x27;, () =&gt; {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it(&#x27;should be return mapped port&#x27;, () =&gt; {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe(&#x27;DynamoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;amazon/dynamodb-local:latest&#x27;, {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MongoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;ElasticSearch&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;8c3ed895-4920-47ad-95f4-b353d26a7803&quot;,&quot;parentUUID&quot;:&quot;955034f6-e2ee-42f4-a3df-bd65c23b6c64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;TestContainers &gt; Redis &gt; should be return container instance&quot;,&quot;title&quot;:&quot;TestContainers &gt; Redis &gt; should be return container instance&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { testContainers } from &#x27;../testcontainers&#x27;;\nimport { StartedGenericContainer } from &#x27;testcontainers/dist/src/generic-container/started-generic-container&#x27;;\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from &#x27;../fixtures&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TestContainers&#x27;, () =&gt; {\n  describe(&#x27;Redis&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return exception of instance&#x27;, async () =&gt; {\n      try {\n        await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe(&#x27;Use testContainers.getInstance() instead of new.&#x27;);\n      }\n    });\n\n    it(&#x27;should be get instance of test container&#x27;, () =&gt; {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return envs of instance&#x27;, () =&gt; {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it(&#x27;should be return container instance&#x27;, () =&gt; {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it(&#x27;should be return host of container instance&#x27;, () =&gt; {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual(&#x27;localhost&#x27;);\n    });\n\n    it(&#x27;should be return name of container instance&#x27;, () =&gt; {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it(&#x27;should be return mapped port&#x27;, () =&gt; {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe(&#x27;DynamoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;amazon/dynamodb-local:latest&#x27;, {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MongoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;ElasticSearch&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a3a99614-5a4b-43af-8613-121187178d7b&quot;,&quot;parentUUID&quot;:&quot;955034f6-e2ee-42f4-a3df-bd65c23b6c64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;TestContainers &gt; Redis &gt; should be return host of container instance&quot;,&quot;title&quot;:&quot;TestContainers &gt; Redis &gt; should be return host of container instance&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { testContainers } from &#x27;../testcontainers&#x27;;\nimport { StartedGenericContainer } from &#x27;testcontainers/dist/src/generic-container/started-generic-container&#x27;;\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from &#x27;../fixtures&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TestContainers&#x27;, () =&gt; {\n  describe(&#x27;Redis&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return exception of instance&#x27;, async () =&gt; {\n      try {\n        await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe(&#x27;Use testContainers.getInstance() instead of new.&#x27;);\n      }\n    });\n\n    it(&#x27;should be get instance of test container&#x27;, () =&gt; {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return envs of instance&#x27;, () =&gt; {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it(&#x27;should be return container instance&#x27;, () =&gt; {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it(&#x27;should be return host of container instance&#x27;, () =&gt; {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual(&#x27;localhost&#x27;);\n    });\n\n    it(&#x27;should be return name of container instance&#x27;, () =&gt; {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it(&#x27;should be return mapped port&#x27;, () =&gt; {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe(&#x27;DynamoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;amazon/dynamodb-local:latest&#x27;, {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MongoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;ElasticSearch&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c4fce2eb-9ae7-43b6-8fa1-1427971d8a08&quot;,&quot;parentUUID&quot;:&quot;955034f6-e2ee-42f4-a3df-bd65c23b6c64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;TestContainers &gt; Redis &gt; should be return name of container instance&quot;,&quot;title&quot;:&quot;TestContainers &gt; Redis &gt; should be return name of container instance&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:0,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { testContainers } from &#x27;../testcontainers&#x27;;\nimport { StartedGenericContainer } from &#x27;testcontainers/dist/src/generic-container/started-generic-container&#x27;;\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from &#x27;../fixtures&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TestContainers&#x27;, () =&gt; {\n  describe(&#x27;Redis&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return exception of instance&#x27;, async () =&gt; {\n      try {\n        await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe(&#x27;Use testContainers.getInstance() instead of new.&#x27;);\n      }\n    });\n\n    it(&#x27;should be get instance of test container&#x27;, () =&gt; {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return envs of instance&#x27;, () =&gt; {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it(&#x27;should be return container instance&#x27;, () =&gt; {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it(&#x27;should be return host of container instance&#x27;, () =&gt; {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual(&#x27;localhost&#x27;);\n    });\n\n    it(&#x27;should be return name of container instance&#x27;, () =&gt; {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it(&#x27;should be return mapped port&#x27;, () =&gt; {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe(&#x27;DynamoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;amazon/dynamodb-local:latest&#x27;, {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MongoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;ElasticSearch&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e115d45e-9ecc-4d1d-81bc-6b9025a9591b&quot;,&quot;parentUUID&quot;:&quot;955034f6-e2ee-42f4-a3df-bd65c23b6c64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;TestContainers &gt; Redis &gt; should be return mapped port&quot;,&quot;title&quot;:&quot;TestContainers &gt; Redis &gt; should be return mapped port&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:0,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { testContainers } from &#x27;../testcontainers&#x27;;\nimport { StartedGenericContainer } from &#x27;testcontainers/dist/src/generic-container/started-generic-container&#x27;;\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from &#x27;../fixtures&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TestContainers&#x27;, () =&gt; {\n  describe(&#x27;Redis&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return exception of instance&#x27;, async () =&gt; {\n      try {\n        await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe(&#x27;Use testContainers.getInstance() instead of new.&#x27;);\n      }\n    });\n\n    it(&#x27;should be get instance of test container&#x27;, () =&gt; {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return envs of instance&#x27;, () =&gt; {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it(&#x27;should be return container instance&#x27;, () =&gt; {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it(&#x27;should be return host of container instance&#x27;, () =&gt; {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual(&#x27;localhost&#x27;);\n    });\n\n    it(&#x27;should be return name of container instance&#x27;, () =&gt; {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it(&#x27;should be return mapped port&#x27;, () =&gt; {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe(&#x27;DynamoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;amazon/dynamodb-local:latest&#x27;, {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MongoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;ElasticSearch&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;70c4dd82-7d65-4f16-a22f-f580e5d4dba4&quot;,&quot;parentUUID&quot;:&quot;955034f6-e2ee-42f4-a3df-bd65c23b6c64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;TestContainers &gt; DynamoDB &gt; should be defined&quot;,&quot;title&quot;:&quot;TestContainers &gt; DynamoDB &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { testContainers } from &#x27;../testcontainers&#x27;;\nimport { StartedGenericContainer } from &#x27;testcontainers/dist/src/generic-container/started-generic-container&#x27;;\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from &#x27;../fixtures&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TestContainers&#x27;, () =&gt; {\n  describe(&#x27;Redis&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return exception of instance&#x27;, async () =&gt; {\n      try {\n        await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe(&#x27;Use testContainers.getInstance() instead of new.&#x27;);\n      }\n    });\n\n    it(&#x27;should be get instance of test container&#x27;, () =&gt; {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return envs of instance&#x27;, () =&gt; {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it(&#x27;should be return container instance&#x27;, () =&gt; {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it(&#x27;should be return host of container instance&#x27;, () =&gt; {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual(&#x27;localhost&#x27;);\n    });\n\n    it(&#x27;should be return name of container instance&#x27;, () =&gt; {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it(&#x27;should be return mapped port&#x27;, () =&gt; {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe(&#x27;DynamoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;amazon/dynamodb-local:latest&#x27;, {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MongoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;ElasticSearch&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;75a38f7d-1937-46fb-ac3f-0374bbba8400&quot;,&quot;parentUUID&quot;:&quot;955034f6-e2ee-42f4-a3df-bd65c23b6c64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;TestContainers &gt; MongoDB &gt; should be defined&quot;,&quot;title&quot;:&quot;TestContainers &gt; MongoDB &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { testContainers } from &#x27;../testcontainers&#x27;;\nimport { StartedGenericContainer } from &#x27;testcontainers/dist/src/generic-container/started-generic-container&#x27;;\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from &#x27;../fixtures&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TestContainers&#x27;, () =&gt; {\n  describe(&#x27;Redis&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return exception of instance&#x27;, async () =&gt; {\n      try {\n        await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe(&#x27;Use testContainers.getInstance() instead of new.&#x27;);\n      }\n    });\n\n    it(&#x27;should be get instance of test container&#x27;, () =&gt; {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return envs of instance&#x27;, () =&gt; {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it(&#x27;should be return container instance&#x27;, () =&gt; {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it(&#x27;should be return host of container instance&#x27;, () =&gt; {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual(&#x27;localhost&#x27;);\n    });\n\n    it(&#x27;should be return name of container instance&#x27;, () =&gt; {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it(&#x27;should be return mapped port&#x27;, () =&gt; {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe(&#x27;DynamoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;amazon/dynamodb-local:latest&#x27;, {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MongoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;ElasticSearch&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;fe98144c-a2c2-4d0b-b8b6-dd69a79a411a&quot;,&quot;parentUUID&quot;:&quot;955034f6-e2ee-42f4-a3df-bd65c23b6c64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;TestContainers &gt; MySql &gt; should be defined&quot;,&quot;title&quot;:&quot;TestContainers &gt; MySql &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { testContainers } from &#x27;../testcontainers&#x27;;\nimport { StartedGenericContainer } from &#x27;testcontainers/dist/src/generic-container/started-generic-container&#x27;;\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from &#x27;../fixtures&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TestContainers&#x27;, () =&gt; {\n  describe(&#x27;Redis&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return exception of instance&#x27;, async () =&gt; {\n      try {\n        await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe(&#x27;Use testContainers.getInstance() instead of new.&#x27;);\n      }\n    });\n\n    it(&#x27;should be get instance of test container&#x27;, () =&gt; {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return envs of instance&#x27;, () =&gt; {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it(&#x27;should be return container instance&#x27;, () =&gt; {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it(&#x27;should be return host of container instance&#x27;, () =&gt; {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual(&#x27;localhost&#x27;);\n    });\n\n    it(&#x27;should be return name of container instance&#x27;, () =&gt; {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it(&#x27;should be return mapped port&#x27;, () =&gt; {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe(&#x27;DynamoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;amazon/dynamodb-local:latest&#x27;, {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MongoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;ElasticSearch&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3c5e2304-b489-4c39-a7f5-393171606680&quot;,&quot;parentUUID&quot;:&quot;955034f6-e2ee-42f4-a3df-bd65c23b6c64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;TestContainers &gt; Postgres &gt; should be defined&quot;,&quot;title&quot;:&quot;TestContainers &gt; Postgres &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { testContainers } from &#x27;../testcontainers&#x27;;\nimport { StartedGenericContainer } from &#x27;testcontainers/dist/src/generic-container/started-generic-container&#x27;;\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from &#x27;../fixtures&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TestContainers&#x27;, () =&gt; {\n  describe(&#x27;Redis&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return exception of instance&#x27;, async () =&gt; {\n      try {\n        await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe(&#x27;Use testContainers.getInstance() instead of new.&#x27;);\n      }\n    });\n\n    it(&#x27;should be get instance of test container&#x27;, () =&gt; {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return envs of instance&#x27;, () =&gt; {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it(&#x27;should be return container instance&#x27;, () =&gt; {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it(&#x27;should be return host of container instance&#x27;, () =&gt; {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual(&#x27;localhost&#x27;);\n    });\n\n    it(&#x27;should be return name of container instance&#x27;, () =&gt; {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it(&#x27;should be return mapped port&#x27;, () =&gt; {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe(&#x27;DynamoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;amazon/dynamodb-local:latest&#x27;, {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MongoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;ElasticSearch&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4429cadf-41bb-438e-8288-86110415b4e6&quot;,&quot;parentUUID&quot;:&quot;955034f6-e2ee-42f4-a3df-bd65c23b6c64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;TestContainers &gt; ElasticSearch &gt; should be defined&quot;,&quot;title&quot;:&quot;TestContainers &gt; ElasticSearch &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { testContainers } from &#x27;../testcontainers&#x27;;\nimport { StartedGenericContainer } from &#x27;testcontainers/dist/src/generic-container/started-generic-container&#x27;;\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from &#x27;../fixtures&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TestContainers&#x27;, () =&gt; {\n  describe(&#x27;Redis&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return exception of instance&#x27;, async () =&gt; {\n      try {\n        await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe(&#x27;Use testContainers.getInstance() instead of new.&#x27;);\n      }\n    });\n\n    it(&#x27;should be get instance of test container&#x27;, () =&gt; {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return envs of instance&#x27;, () =&gt; {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it(&#x27;should be return container instance&#x27;, () =&gt; {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it(&#x27;should be return host of container instance&#x27;, () =&gt; {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual(&#x27;localhost&#x27;);\n    });\n\n    it(&#x27;should be return name of container instance&#x27;, () =&gt; {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it(&#x27;should be return mapped port&#x27;, () =&gt; {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe(&#x27;DynamoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;amazon/dynamodb-local:latest&#x27;, {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MongoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;ElasticSearch&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;86a24f69-e77f-4682-9b05-350c9eeb0da6&quot;,&quot;parentUUID&quot;:&quot;955034f6-e2ee-42f4-a3df-bd65c23b6c64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;utilities &gt; should be return delay default time&quot;,&quot;title&quot;:&quot;utilities &gt; should be return delay default time&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10005,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { delay, pathJoin } from &#x27;../utilities&#x27;;\nimport path from &#x27;path&#x27;;\n\ndescribe(&#x27;utilities&#x27;, () =&gt; {\n  it(&#x27;should be return delay default time&#x27;, async () =&gt; {\n    jest.spyOn(global, &#x27;setTimeout&#x27;);\n    await delay();\n    expect(setTimeout).toHaveBeenCalledTimes(1);\n    expect(setTimeout).toHaveBeenLastCalledWith(expect.any(Function), 10000);\n  });\n\n  it(&#x27;should be return delay custom time&#x27;, async () =&gt; {\n    jest.spyOn(global, &#x27;setTimeout&#x27;);\n    await delay(60);\n    expect(setTimeout).toHaveBeenCalledTimes(2);\n    expect(setTimeout).toHaveBeenLastCalledWith(expect.any(Function), 60);\n  });\n\n  it(&#x27;should be return a join of paths&#x27;, async () =&gt; {\n    const filePath = pathJoin(__dirname, &#x27;join&#x27;);\n    expect(filePath).toBe(path.join(__dirname, &#x27;join&#x27;));\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;750ac110-e6b2-456d-94ec-bfd55167ba35&quot;,&quot;parentUUID&quot;:&quot;955034f6-e2ee-42f4-a3df-bd65c23b6c64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;utilities &gt; should be return delay custom time&quot;,&quot;title&quot;:&quot;utilities &gt; should be return delay custom time&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:60,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { delay, pathJoin } from &#x27;../utilities&#x27;;\nimport path from &#x27;path&#x27;;\n\ndescribe(&#x27;utilities&#x27;, () =&gt; {\n  it(&#x27;should be return delay default time&#x27;, async () =&gt; {\n    jest.spyOn(global, &#x27;setTimeout&#x27;);\n    await delay();\n    expect(setTimeout).toHaveBeenCalledTimes(1);\n    expect(setTimeout).toHaveBeenLastCalledWith(expect.any(Function), 10000);\n  });\n\n  it(&#x27;should be return delay custom time&#x27;, async () =&gt; {\n    jest.spyOn(global, &#x27;setTimeout&#x27;);\n    await delay(60);\n    expect(setTimeout).toHaveBeenCalledTimes(2);\n    expect(setTimeout).toHaveBeenLastCalledWith(expect.any(Function), 60);\n  });\n\n  it(&#x27;should be return a join of paths&#x27;, async () =&gt; {\n    const filePath = pathJoin(__dirname, &#x27;join&#x27;);\n    expect(filePath).toBe(path.join(__dirname, &#x27;join&#x27;));\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b820906b-35b3-49e6-b65d-65c472e3aaa9&quot;,&quot;parentUUID&quot;:&quot;955034f6-e2ee-42f4-a3df-bd65c23b6c64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;utilities &gt; should be return a join of paths&quot;,&quot;title&quot;:&quot;utilities &gt; should be return a join of paths&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { delay, pathJoin } from &#x27;../utilities&#x27;;\nimport path from &#x27;path&#x27;;\n\ndescribe(&#x27;utilities&#x27;, () =&gt; {\n  it(&#x27;should be return delay default time&#x27;, async () =&gt; {\n    jest.spyOn(global, &#x27;setTimeout&#x27;);\n    await delay();\n    expect(setTimeout).toHaveBeenCalledTimes(1);\n    expect(setTimeout).toHaveBeenLastCalledWith(expect.any(Function), 10000);\n  });\n\n  it(&#x27;should be return delay custom time&#x27;, async () =&gt; {\n    jest.spyOn(global, &#x27;setTimeout&#x27;);\n    await delay(60);\n    expect(setTimeout).toHaveBeenCalledTimes(2);\n    expect(setTimeout).toHaveBeenLastCalledWith(expect.any(Function), 60);\n  });\n\n  it(&#x27;should be return a join of paths&#x27;, async () =&gt; {\n    const filePath = pathJoin(__dirname, &#x27;join&#x27;);\n    expect(filePath).toBe(path.join(__dirname, &#x27;join&#x27;));\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;881bc5d8-5298-40e0-be1b-107511a857ba&quot;,&quot;parentUUID&quot;:&quot;955034f6-e2ee-42f4-a3df-bd65c23b6c64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Config &gt; baseConfig &gt; should be return config&quot;,&quot;title&quot;:&quot;Config &gt; baseConfig &gt; should be return config&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { config, dynamicConfig } from &#x27;../config/index&#x27;;\nimport { appConfigBase } from &#x27;../fixtures&#x27;;\n\ndescribe(&#x27;Config&#x27;, () =&gt; {\n  describe(&#x27;baseConfig&#x27;, () =&gt; {\n    it(&#x27;should be return config&#x27;, async () =&gt; {\n      expect(config()).toBeDefined();\n      expect(config()).not.toBe(null);\n      expect(typeof config()).toBe(&#x27;object&#x27;);\n      expect(config()).toEqual(appConfigBase);\n    });\n  });\n\n  describe(&#x27;dynamicConfig&#x27;, () =&gt; {\n    it(&#x27;should be return config with args&#x27;, async () =&gt; {\n      const args = {\n        httOptions: {\n          timeout: 5000,\n          maxRedirects: 5,\n        },\n      };\n\n      expect(dynamicConfig(args)()).toBeDefined();\n      expect(dynamicConfig(args)()).not.toBe(null);\n      expect(typeof dynamicConfig(args)()).toBe(&#x27;object&#x27;);\n      expect(dynamicConfig(args)()).toEqual({ ...appConfigBase, ...args });\n    });\n\n    it(&#x27;should be return config without args&#x27;, async () =&gt; {\n      expect(dynamicConfig()()).toBeDefined();\n      expect(dynamicConfig()()).not.toBe(null);\n      expect(typeof dynamicConfig()()).toBe(&#x27;object&#x27;);\n      expect(dynamicConfig()()).toEqual(appConfigBase);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2f165336-0fca-4038-8ec7-a7ed9fb95acc&quot;,&quot;parentUUID&quot;:&quot;955034f6-e2ee-42f4-a3df-bd65c23b6c64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Config &gt; dynamicConfig &gt; should be return config with args&quot;,&quot;title&quot;:&quot;Config &gt; dynamicConfig &gt; should be return config with args&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { config, dynamicConfig } from &#x27;../config/index&#x27;;\nimport { appConfigBase } from &#x27;../fixtures&#x27;;\n\ndescribe(&#x27;Config&#x27;, () =&gt; {\n  describe(&#x27;baseConfig&#x27;, () =&gt; {\n    it(&#x27;should be return config&#x27;, async () =&gt; {\n      expect(config()).toBeDefined();\n      expect(config()).not.toBe(null);\n      expect(typeof config()).toBe(&#x27;object&#x27;);\n      expect(config()).toEqual(appConfigBase);\n    });\n  });\n\n  describe(&#x27;dynamicConfig&#x27;, () =&gt; {\n    it(&#x27;should be return config with args&#x27;, async () =&gt; {\n      const args = {\n        httOptions: {\n          timeout: 5000,\n          maxRedirects: 5,\n        },\n      };\n\n      expect(dynamicConfig(args)()).toBeDefined();\n      expect(dynamicConfig(args)()).not.toBe(null);\n      expect(typeof dynamicConfig(args)()).toBe(&#x27;object&#x27;);\n      expect(dynamicConfig(args)()).toEqual({ ...appConfigBase, ...args });\n    });\n\n    it(&#x27;should be return config without args&#x27;, async () =&gt; {\n      expect(dynamicConfig()()).toBeDefined();\n      expect(dynamicConfig()()).not.toBe(null);\n      expect(typeof dynamicConfig()()).toBe(&#x27;object&#x27;);\n      expect(dynamicConfig()()).toEqual(appConfigBase);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e05cf343-4254-4bb0-89a5-95f5df1dac6b&quot;,&quot;parentUUID&quot;:&quot;955034f6-e2ee-42f4-a3df-bd65c23b6c64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Config &gt; dynamicConfig &gt; should be return config without args&quot;,&quot;title&quot;:&quot;Config &gt; dynamicConfig &gt; should be return config without args&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { config, dynamicConfig } from &#x27;../config/index&#x27;;\nimport { appConfigBase } from &#x27;../fixtures&#x27;;\n\ndescribe(&#x27;Config&#x27;, () =&gt; {\n  describe(&#x27;baseConfig&#x27;, () =&gt; {\n    it(&#x27;should be return config&#x27;, async () =&gt; {\n      expect(config()).toBeDefined();\n      expect(config()).not.toBe(null);\n      expect(typeof config()).toBe(&#x27;object&#x27;);\n      expect(config()).toEqual(appConfigBase);\n    });\n  });\n\n  describe(&#x27;dynamicConfig&#x27;, () =&gt; {\n    it(&#x27;should be return config with args&#x27;, async () =&gt; {\n      const args = {\n        httOptions: {\n          timeout: 5000,\n          maxRedirects: 5,\n        },\n      };\n\n      expect(dynamicConfig(args)()).toBeDefined();\n      expect(dynamicConfig(args)()).not.toBe(null);\n      expect(typeof dynamicConfig(args)()).toBe(&#x27;object&#x27;);\n      expect(dynamicConfig(args)()).toEqual({ ...appConfigBase, ...args });\n    });\n\n    it(&#x27;should be return config without args&#x27;, async () =&gt; {\n      expect(dynamicConfig()()).toBeDefined();\n      expect(dynamicConfig()()).not.toBe(null);\n      expect(typeof dynamicConfig()()).toBe(&#x27;object&#x27;);\n      expect(dynamicConfig()()).toEqual(appConfigBase);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b4e54be0-036e-4935-a84f-9e2e0e8ee420&quot;,&quot;parentUUID&quot;:&quot;955034f6-e2ee-42f4-a3df-bd65c23b6c64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Fixtures &gt; appConfigBase &gt; should be return appBaseConfig&quot;,&quot;title&quot;:&quot;Fixtures &gt; appConfigBase &gt; should be return appBaseConfig&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import {\n  appConfigBase,\n  manifest,\n  TCRedisOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n  TCDynamoDBOptions,\n} from &#x27;../fixtures&#x27;;\n\nconst containerName_prefix = &#x27;tresdoce-test-container&#x27;;\ndescribe(&#x27;Fixtures&#x27;, () =&gt; {\n  describe(&#x27;appConfigBase&#x27;, () =&gt; {\n    it(&#x27;should be return appBaseConfig&#x27;, async () =&gt; {\n      expect(appConfigBase).toBeDefined();\n      expect(appConfigBase).not.toBe(null);\n      expect(typeof appConfigBase).toBe(&#x27;object&#x27;);\n    });\n  });\n\n  describe(&#x27;manifest&#x27;, () =&gt; {\n    it(&#x27;should be return appBaseConfig&#x27;, async () =&gt; {\n      expect(manifest).toBeDefined();\n      expect(manifest).not.toBe(null);\n      expect(typeof manifest).toBe(&#x27;object&#x27;);\n    });\n  });\n\n  describe(&#x27;TestContainers options&#x27;, () =&gt; {\n    it(&#x27;should be define Redis options&#x27;, async () =&gt; {\n      expect(TCRedisOptions).toBeDefined();\n      expect(TCRedisOptions).not.toBe(null);\n      expect(typeof TCRedisOptions).toBe(&#x27;object&#x27;);\n      expect(TCRedisOptions.containerName).toEqual(`${containerName_prefix}-redis`);\n      expect(TCRedisOptions.ports).toEqual([\n        {\n          container: 6379,\n          host: 6379,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define DynamoDB options&#x27;, async () =&gt; {\n      expect(TCDynamoDBOptions).toBeDefined();\n      expect(TCDynamoDBOptions).not.toBe(null);\n      expect(typeof TCDynamoDBOptions).toBe(&#x27;object&#x27;);\n      expect(TCDynamoDBOptions.containerName).toEqual(`${containerName_prefix}-dynamodb`);\n      expect(TCDynamoDBOptions.ports).toEqual([\n        {\n          container: 8000,\n          host: 8000,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define MongoDB options&#x27;, async () =&gt; {\n      expect(TCMongoOptions).toBeDefined();\n      expect(TCMongoOptions).not.toBe(null);\n      expect(typeof TCMongoOptions).toBe(&#x27;object&#x27;);\n      expect(TCMongoOptions.containerName).toEqual(`${containerName_prefix}-mongo`);\n      expect(TCMongoOptions.ports).toEqual([\n        {\n          container: 27017,\n          host: 27017,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define MySql options&#x27;, async () =&gt; {\n      expect(TCMySqlOptions).toBeDefined();\n      expect(TCMySqlOptions).not.toBe(null);\n      expect(typeof TCMySqlOptions).toBe(&#x27;object&#x27;);\n      expect(TCMySqlOptions.containerName).toEqual(`${containerName_prefix}-mysql`);\n      expect(TCMySqlOptions.ports).toEqual([\n        {\n          container: 3306,\n          host: 3306,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define Postgres options&#x27;, async () =&gt; {\n      expect(TCPostgresOptions).toBeDefined();\n      expect(TCPostgresOptions).not.toBe(null);\n      expect(typeof TCPostgresOptions).toBe(&#x27;object&#x27;);\n      expect(TCPostgresOptions.containerName).toEqual(`${containerName_prefix}-postgres`);\n      expect(TCPostgresOptions.ports).toEqual([\n        {\n          container: 5432,\n          host: 5432,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define ElasticSearch options&#x27;, async () =&gt; {\n      expect(TCElasticSearchOptions).toBeDefined();\n      expect(TCElasticSearchOptions).not.toBe(null);\n      expect(typeof TCElasticSearchOptions).toBe(&#x27;object&#x27;);\n      expect(TCElasticSearchOptions.containerName).toEqual(`${containerName_prefix}-elasticsearch`);\n      expect(TCElasticSearchOptions.ports).toEqual([\n        {\n          container: 9200,\n          host: 9200,\n        },\n      ]);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a2565c7d-23fa-4dca-8e2b-f057ee059c17&quot;,&quot;parentUUID&quot;:&quot;955034f6-e2ee-42f4-a3df-bd65c23b6c64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Fixtures &gt; manifest &gt; should be return appBaseConfig&quot;,&quot;title&quot;:&quot;Fixtures &gt; manifest &gt; should be return appBaseConfig&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:0,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import {\n  appConfigBase,\n  manifest,\n  TCRedisOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n  TCDynamoDBOptions,\n} from &#x27;../fixtures&#x27;;\n\nconst containerName_prefix = &#x27;tresdoce-test-container&#x27;;\ndescribe(&#x27;Fixtures&#x27;, () =&gt; {\n  describe(&#x27;appConfigBase&#x27;, () =&gt; {\n    it(&#x27;should be return appBaseConfig&#x27;, async () =&gt; {\n      expect(appConfigBase).toBeDefined();\n      expect(appConfigBase).not.toBe(null);\n      expect(typeof appConfigBase).toBe(&#x27;object&#x27;);\n    });\n  });\n\n  describe(&#x27;manifest&#x27;, () =&gt; {\n    it(&#x27;should be return appBaseConfig&#x27;, async () =&gt; {\n      expect(manifest).toBeDefined();\n      expect(manifest).not.toBe(null);\n      expect(typeof manifest).toBe(&#x27;object&#x27;);\n    });\n  });\n\n  describe(&#x27;TestContainers options&#x27;, () =&gt; {\n    it(&#x27;should be define Redis options&#x27;, async () =&gt; {\n      expect(TCRedisOptions).toBeDefined();\n      expect(TCRedisOptions).not.toBe(null);\n      expect(typeof TCRedisOptions).toBe(&#x27;object&#x27;);\n      expect(TCRedisOptions.containerName).toEqual(`${containerName_prefix}-redis`);\n      expect(TCRedisOptions.ports).toEqual([\n        {\n          container: 6379,\n          host: 6379,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define DynamoDB options&#x27;, async () =&gt; {\n      expect(TCDynamoDBOptions).toBeDefined();\n      expect(TCDynamoDBOptions).not.toBe(null);\n      expect(typeof TCDynamoDBOptions).toBe(&#x27;object&#x27;);\n      expect(TCDynamoDBOptions.containerName).toEqual(`${containerName_prefix}-dynamodb`);\n      expect(TCDynamoDBOptions.ports).toEqual([\n        {\n          container: 8000,\n          host: 8000,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define MongoDB options&#x27;, async () =&gt; {\n      expect(TCMongoOptions).toBeDefined();\n      expect(TCMongoOptions).not.toBe(null);\n      expect(typeof TCMongoOptions).toBe(&#x27;object&#x27;);\n      expect(TCMongoOptions.containerName).toEqual(`${containerName_prefix}-mongo`);\n      expect(TCMongoOptions.ports).toEqual([\n        {\n          container: 27017,\n          host: 27017,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define MySql options&#x27;, async () =&gt; {\n      expect(TCMySqlOptions).toBeDefined();\n      expect(TCMySqlOptions).not.toBe(null);\n      expect(typeof TCMySqlOptions).toBe(&#x27;object&#x27;);\n      expect(TCMySqlOptions.containerName).toEqual(`${containerName_prefix}-mysql`);\n      expect(TCMySqlOptions.ports).toEqual([\n        {\n          container: 3306,\n          host: 3306,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define Postgres options&#x27;, async () =&gt; {\n      expect(TCPostgresOptions).toBeDefined();\n      expect(TCPostgresOptions).not.toBe(null);\n      expect(typeof TCPostgresOptions).toBe(&#x27;object&#x27;);\n      expect(TCPostgresOptions.containerName).toEqual(`${containerName_prefix}-postgres`);\n      expect(TCPostgresOptions.ports).toEqual([\n        {\n          container: 5432,\n          host: 5432,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define ElasticSearch options&#x27;, async () =&gt; {\n      expect(TCElasticSearchOptions).toBeDefined();\n      expect(TCElasticSearchOptions).not.toBe(null);\n      expect(typeof TCElasticSearchOptions).toBe(&#x27;object&#x27;);\n      expect(TCElasticSearchOptions.containerName).toEqual(`${containerName_prefix}-elasticsearch`);\n      expect(TCElasticSearchOptions.ports).toEqual([\n        {\n          container: 9200,\n          host: 9200,\n        },\n      ]);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;eabb8185-e7af-4500-9654-9652c8fa1ba5&quot;,&quot;parentUUID&quot;:&quot;955034f6-e2ee-42f4-a3df-bd65c23b6c64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Fixtures &gt; TestContainers options &gt; should be define Redis options&quot;,&quot;title&quot;:&quot;Fixtures &gt; TestContainers options &gt; should be define Redis options&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import {\n  appConfigBase,\n  manifest,\n  TCRedisOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n  TCDynamoDBOptions,\n} from &#x27;../fixtures&#x27;;\n\nconst containerName_prefix = &#x27;tresdoce-test-container&#x27;;\ndescribe(&#x27;Fixtures&#x27;, () =&gt; {\n  describe(&#x27;appConfigBase&#x27;, () =&gt; {\n    it(&#x27;should be return appBaseConfig&#x27;, async () =&gt; {\n      expect(appConfigBase).toBeDefined();\n      expect(appConfigBase).not.toBe(null);\n      expect(typeof appConfigBase).toBe(&#x27;object&#x27;);\n    });\n  });\n\n  describe(&#x27;manifest&#x27;, () =&gt; {\n    it(&#x27;should be return appBaseConfig&#x27;, async () =&gt; {\n      expect(manifest).toBeDefined();\n      expect(manifest).not.toBe(null);\n      expect(typeof manifest).toBe(&#x27;object&#x27;);\n    });\n  });\n\n  describe(&#x27;TestContainers options&#x27;, () =&gt; {\n    it(&#x27;should be define Redis options&#x27;, async () =&gt; {\n      expect(TCRedisOptions).toBeDefined();\n      expect(TCRedisOptions).not.toBe(null);\n      expect(typeof TCRedisOptions).toBe(&#x27;object&#x27;);\n      expect(TCRedisOptions.containerName).toEqual(`${containerName_prefix}-redis`);\n      expect(TCRedisOptions.ports).toEqual([\n        {\n          container: 6379,\n          host: 6379,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define DynamoDB options&#x27;, async () =&gt; {\n      expect(TCDynamoDBOptions).toBeDefined();\n      expect(TCDynamoDBOptions).not.toBe(null);\n      expect(typeof TCDynamoDBOptions).toBe(&#x27;object&#x27;);\n      expect(TCDynamoDBOptions.containerName).toEqual(`${containerName_prefix}-dynamodb`);\n      expect(TCDynamoDBOptions.ports).toEqual([\n        {\n          container: 8000,\n          host: 8000,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define MongoDB options&#x27;, async () =&gt; {\n      expect(TCMongoOptions).toBeDefined();\n      expect(TCMongoOptions).not.toBe(null);\n      expect(typeof TCMongoOptions).toBe(&#x27;object&#x27;);\n      expect(TCMongoOptions.containerName).toEqual(`${containerName_prefix}-mongo`);\n      expect(TCMongoOptions.ports).toEqual([\n        {\n          container: 27017,\n          host: 27017,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define MySql options&#x27;, async () =&gt; {\n      expect(TCMySqlOptions).toBeDefined();\n      expect(TCMySqlOptions).not.toBe(null);\n      expect(typeof TCMySqlOptions).toBe(&#x27;object&#x27;);\n      expect(TCMySqlOptions.containerName).toEqual(`${containerName_prefix}-mysql`);\n      expect(TCMySqlOptions.ports).toEqual([\n        {\n          container: 3306,\n          host: 3306,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define Postgres options&#x27;, async () =&gt; {\n      expect(TCPostgresOptions).toBeDefined();\n      expect(TCPostgresOptions).not.toBe(null);\n      expect(typeof TCPostgresOptions).toBe(&#x27;object&#x27;);\n      expect(TCPostgresOptions.containerName).toEqual(`${containerName_prefix}-postgres`);\n      expect(TCPostgresOptions.ports).toEqual([\n        {\n          container: 5432,\n          host: 5432,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define ElasticSearch options&#x27;, async () =&gt; {\n      expect(TCElasticSearchOptions).toBeDefined();\n      expect(TCElasticSearchOptions).not.toBe(null);\n      expect(typeof TCElasticSearchOptions).toBe(&#x27;object&#x27;);\n      expect(TCElasticSearchOptions.containerName).toEqual(`${containerName_prefix}-elasticsearch`);\n      expect(TCElasticSearchOptions.ports).toEqual([\n        {\n          container: 9200,\n          host: 9200,\n        },\n      ]);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;216617f3-97a9-4d89-8b54-622765a250e3&quot;,&quot;parentUUID&quot;:&quot;955034f6-e2ee-42f4-a3df-bd65c23b6c64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Fixtures &gt; TestContainers options &gt; should be define DynamoDB options&quot;,&quot;title&quot;:&quot;Fixtures &gt; TestContainers options &gt; should be define DynamoDB options&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import {\n  appConfigBase,\n  manifest,\n  TCRedisOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n  TCDynamoDBOptions,\n} from &#x27;../fixtures&#x27;;\n\nconst containerName_prefix = &#x27;tresdoce-test-container&#x27;;\ndescribe(&#x27;Fixtures&#x27;, () =&gt; {\n  describe(&#x27;appConfigBase&#x27;, () =&gt; {\n    it(&#x27;should be return appBaseConfig&#x27;, async () =&gt; {\n      expect(appConfigBase).toBeDefined();\n      expect(appConfigBase).not.toBe(null);\n      expect(typeof appConfigBase).toBe(&#x27;object&#x27;);\n    });\n  });\n\n  describe(&#x27;manifest&#x27;, () =&gt; {\n    it(&#x27;should be return appBaseConfig&#x27;, async () =&gt; {\n      expect(manifest).toBeDefined();\n      expect(manifest).not.toBe(null);\n      expect(typeof manifest).toBe(&#x27;object&#x27;);\n    });\n  });\n\n  describe(&#x27;TestContainers options&#x27;, () =&gt; {\n    it(&#x27;should be define Redis options&#x27;, async () =&gt; {\n      expect(TCRedisOptions).toBeDefined();\n      expect(TCRedisOptions).not.toBe(null);\n      expect(typeof TCRedisOptions).toBe(&#x27;object&#x27;);\n      expect(TCRedisOptions.containerName).toEqual(`${containerName_prefix}-redis`);\n      expect(TCRedisOptions.ports).toEqual([\n        {\n          container: 6379,\n          host: 6379,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define DynamoDB options&#x27;, async () =&gt; {\n      expect(TCDynamoDBOptions).toBeDefined();\n      expect(TCDynamoDBOptions).not.toBe(null);\n      expect(typeof TCDynamoDBOptions).toBe(&#x27;object&#x27;);\n      expect(TCDynamoDBOptions.containerName).toEqual(`${containerName_prefix}-dynamodb`);\n      expect(TCDynamoDBOptions.ports).toEqual([\n        {\n          container: 8000,\n          host: 8000,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define MongoDB options&#x27;, async () =&gt; {\n      expect(TCMongoOptions).toBeDefined();\n      expect(TCMongoOptions).not.toBe(null);\n      expect(typeof TCMongoOptions).toBe(&#x27;object&#x27;);\n      expect(TCMongoOptions.containerName).toEqual(`${containerName_prefix}-mongo`);\n      expect(TCMongoOptions.ports).toEqual([\n        {\n          container: 27017,\n          host: 27017,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define MySql options&#x27;, async () =&gt; {\n      expect(TCMySqlOptions).toBeDefined();\n      expect(TCMySqlOptions).not.toBe(null);\n      expect(typeof TCMySqlOptions).toBe(&#x27;object&#x27;);\n      expect(TCMySqlOptions.containerName).toEqual(`${containerName_prefix}-mysql`);\n      expect(TCMySqlOptions.ports).toEqual([\n        {\n          container: 3306,\n          host: 3306,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define Postgres options&#x27;, async () =&gt; {\n      expect(TCPostgresOptions).toBeDefined();\n      expect(TCPostgresOptions).not.toBe(null);\n      expect(typeof TCPostgresOptions).toBe(&#x27;object&#x27;);\n      expect(TCPostgresOptions.containerName).toEqual(`${containerName_prefix}-postgres`);\n      expect(TCPostgresOptions.ports).toEqual([\n        {\n          container: 5432,\n          host: 5432,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define ElasticSearch options&#x27;, async () =&gt; {\n      expect(TCElasticSearchOptions).toBeDefined();\n      expect(TCElasticSearchOptions).not.toBe(null);\n      expect(typeof TCElasticSearchOptions).toBe(&#x27;object&#x27;);\n      expect(TCElasticSearchOptions.containerName).toEqual(`${containerName_prefix}-elasticsearch`);\n      expect(TCElasticSearchOptions.ports).toEqual([\n        {\n          container: 9200,\n          host: 9200,\n        },\n      ]);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;72ea864d-703e-43d2-b42a-089dd8208cda&quot;,&quot;parentUUID&quot;:&quot;955034f6-e2ee-42f4-a3df-bd65c23b6c64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Fixtures &gt; TestContainers options &gt; should be define MongoDB options&quot;,&quot;title&quot;:&quot;Fixtures &gt; TestContainers options &gt; should be define MongoDB options&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import {\n  appConfigBase,\n  manifest,\n  TCRedisOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n  TCDynamoDBOptions,\n} from &#x27;../fixtures&#x27;;\n\nconst containerName_prefix = &#x27;tresdoce-test-container&#x27;;\ndescribe(&#x27;Fixtures&#x27;, () =&gt; {\n  describe(&#x27;appConfigBase&#x27;, () =&gt; {\n    it(&#x27;should be return appBaseConfig&#x27;, async () =&gt; {\n      expect(appConfigBase).toBeDefined();\n      expect(appConfigBase).not.toBe(null);\n      expect(typeof appConfigBase).toBe(&#x27;object&#x27;);\n    });\n  });\n\n  describe(&#x27;manifest&#x27;, () =&gt; {\n    it(&#x27;should be return appBaseConfig&#x27;, async () =&gt; {\n      expect(manifest).toBeDefined();\n      expect(manifest).not.toBe(null);\n      expect(typeof manifest).toBe(&#x27;object&#x27;);\n    });\n  });\n\n  describe(&#x27;TestContainers options&#x27;, () =&gt; {\n    it(&#x27;should be define Redis options&#x27;, async () =&gt; {\n      expect(TCRedisOptions).toBeDefined();\n      expect(TCRedisOptions).not.toBe(null);\n      expect(typeof TCRedisOptions).toBe(&#x27;object&#x27;);\n      expect(TCRedisOptions.containerName).toEqual(`${containerName_prefix}-redis`);\n      expect(TCRedisOptions.ports).toEqual([\n        {\n          container: 6379,\n          host: 6379,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define DynamoDB options&#x27;, async () =&gt; {\n      expect(TCDynamoDBOptions).toBeDefined();\n      expect(TCDynamoDBOptions).not.toBe(null);\n      expect(typeof TCDynamoDBOptions).toBe(&#x27;object&#x27;);\n      expect(TCDynamoDBOptions.containerName).toEqual(`${containerName_prefix}-dynamodb`);\n      expect(TCDynamoDBOptions.ports).toEqual([\n        {\n          container: 8000,\n          host: 8000,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define MongoDB options&#x27;, async () =&gt; {\n      expect(TCMongoOptions).toBeDefined();\n      expect(TCMongoOptions).not.toBe(null);\n      expect(typeof TCMongoOptions).toBe(&#x27;object&#x27;);\n      expect(TCMongoOptions.containerName).toEqual(`${containerName_prefix}-mongo`);\n      expect(TCMongoOptions.ports).toEqual([\n        {\n          container: 27017,\n          host: 27017,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define MySql options&#x27;, async () =&gt; {\n      expect(TCMySqlOptions).toBeDefined();\n      expect(TCMySqlOptions).not.toBe(null);\n      expect(typeof TCMySqlOptions).toBe(&#x27;object&#x27;);\n      expect(TCMySqlOptions.containerName).toEqual(`${containerName_prefix}-mysql`);\n      expect(TCMySqlOptions.ports).toEqual([\n        {\n          container: 3306,\n          host: 3306,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define Postgres options&#x27;, async () =&gt; {\n      expect(TCPostgresOptions).toBeDefined();\n      expect(TCPostgresOptions).not.toBe(null);\n      expect(typeof TCPostgresOptions).toBe(&#x27;object&#x27;);\n      expect(TCPostgresOptions.containerName).toEqual(`${containerName_prefix}-postgres`);\n      expect(TCPostgresOptions.ports).toEqual([\n        {\n          container: 5432,\n          host: 5432,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define ElasticSearch options&#x27;, async () =&gt; {\n      expect(TCElasticSearchOptions).toBeDefined();\n      expect(TCElasticSearchOptions).not.toBe(null);\n      expect(typeof TCElasticSearchOptions).toBe(&#x27;object&#x27;);\n      expect(TCElasticSearchOptions.containerName).toEqual(`${containerName_prefix}-elasticsearch`);\n      expect(TCElasticSearchOptions.ports).toEqual([\n        {\n          container: 9200,\n          host: 9200,\n        },\n      ]);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4736204e-c0f9-46d7-898e-65699fe20309&quot;,&quot;parentUUID&quot;:&quot;955034f6-e2ee-42f4-a3df-bd65c23b6c64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Fixtures &gt; TestContainers options &gt; should be define MySql options&quot;,&quot;title&quot;:&quot;Fixtures &gt; TestContainers options &gt; should be define MySql options&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import {\n  appConfigBase,\n  manifest,\n  TCRedisOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n  TCDynamoDBOptions,\n} from &#x27;../fixtures&#x27;;\n\nconst containerName_prefix = &#x27;tresdoce-test-container&#x27;;\ndescribe(&#x27;Fixtures&#x27;, () =&gt; {\n  describe(&#x27;appConfigBase&#x27;, () =&gt; {\n    it(&#x27;should be return appBaseConfig&#x27;, async () =&gt; {\n      expect(appConfigBase).toBeDefined();\n      expect(appConfigBase).not.toBe(null);\n      expect(typeof appConfigBase).toBe(&#x27;object&#x27;);\n    });\n  });\n\n  describe(&#x27;manifest&#x27;, () =&gt; {\n    it(&#x27;should be return appBaseConfig&#x27;, async () =&gt; {\n      expect(manifest).toBeDefined();\n      expect(manifest).not.toBe(null);\n      expect(typeof manifest).toBe(&#x27;object&#x27;);\n    });\n  });\n\n  describe(&#x27;TestContainers options&#x27;, () =&gt; {\n    it(&#x27;should be define Redis options&#x27;, async () =&gt; {\n      expect(TCRedisOptions).toBeDefined();\n      expect(TCRedisOptions).not.toBe(null);\n      expect(typeof TCRedisOptions).toBe(&#x27;object&#x27;);\n      expect(TCRedisOptions.containerName).toEqual(`${containerName_prefix}-redis`);\n      expect(TCRedisOptions.ports).toEqual([\n        {\n          container: 6379,\n          host: 6379,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define DynamoDB options&#x27;, async () =&gt; {\n      expect(TCDynamoDBOptions).toBeDefined();\n      expect(TCDynamoDBOptions).not.toBe(null);\n      expect(typeof TCDynamoDBOptions).toBe(&#x27;object&#x27;);\n      expect(TCDynamoDBOptions.containerName).toEqual(`${containerName_prefix}-dynamodb`);\n      expect(TCDynamoDBOptions.ports).toEqual([\n        {\n          container: 8000,\n          host: 8000,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define MongoDB options&#x27;, async () =&gt; {\n      expect(TCMongoOptions).toBeDefined();\n      expect(TCMongoOptions).not.toBe(null);\n      expect(typeof TCMongoOptions).toBe(&#x27;object&#x27;);\n      expect(TCMongoOptions.containerName).toEqual(`${containerName_prefix}-mongo`);\n      expect(TCMongoOptions.ports).toEqual([\n        {\n          container: 27017,\n          host: 27017,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define MySql options&#x27;, async () =&gt; {\n      expect(TCMySqlOptions).toBeDefined();\n      expect(TCMySqlOptions).not.toBe(null);\n      expect(typeof TCMySqlOptions).toBe(&#x27;object&#x27;);\n      expect(TCMySqlOptions.containerName).toEqual(`${containerName_prefix}-mysql`);\n      expect(TCMySqlOptions.ports).toEqual([\n        {\n          container: 3306,\n          host: 3306,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define Postgres options&#x27;, async () =&gt; {\n      expect(TCPostgresOptions).toBeDefined();\n      expect(TCPostgresOptions).not.toBe(null);\n      expect(typeof TCPostgresOptions).toBe(&#x27;object&#x27;);\n      expect(TCPostgresOptions.containerName).toEqual(`${containerName_prefix}-postgres`);\n      expect(TCPostgresOptions.ports).toEqual([\n        {\n          container: 5432,\n          host: 5432,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define ElasticSearch options&#x27;, async () =&gt; {\n      expect(TCElasticSearchOptions).toBeDefined();\n      expect(TCElasticSearchOptions).not.toBe(null);\n      expect(typeof TCElasticSearchOptions).toBe(&#x27;object&#x27;);\n      expect(TCElasticSearchOptions.containerName).toEqual(`${containerName_prefix}-elasticsearch`);\n      expect(TCElasticSearchOptions.ports).toEqual([\n        {\n          container: 9200,\n          host: 9200,\n        },\n      ]);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2d441cb7-a513-49e6-8a11-32575d63b2b8&quot;,&quot;parentUUID&quot;:&quot;955034f6-e2ee-42f4-a3df-bd65c23b6c64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Fixtures &gt; TestContainers options &gt; should be define Postgres options&quot;,&quot;title&quot;:&quot;Fixtures &gt; TestContainers options &gt; should be define Postgres options&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import {\n  appConfigBase,\n  manifest,\n  TCRedisOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n  TCDynamoDBOptions,\n} from &#x27;../fixtures&#x27;;\n\nconst containerName_prefix = &#x27;tresdoce-test-container&#x27;;\ndescribe(&#x27;Fixtures&#x27;, () =&gt; {\n  describe(&#x27;appConfigBase&#x27;, () =&gt; {\n    it(&#x27;should be return appBaseConfig&#x27;, async () =&gt; {\n      expect(appConfigBase).toBeDefined();\n      expect(appConfigBase).not.toBe(null);\n      expect(typeof appConfigBase).toBe(&#x27;object&#x27;);\n    });\n  });\n\n  describe(&#x27;manifest&#x27;, () =&gt; {\n    it(&#x27;should be return appBaseConfig&#x27;, async () =&gt; {\n      expect(manifest).toBeDefined();\n      expect(manifest).not.toBe(null);\n      expect(typeof manifest).toBe(&#x27;object&#x27;);\n    });\n  });\n\n  describe(&#x27;TestContainers options&#x27;, () =&gt; {\n    it(&#x27;should be define Redis options&#x27;, async () =&gt; {\n      expect(TCRedisOptions).toBeDefined();\n      expect(TCRedisOptions).not.toBe(null);\n      expect(typeof TCRedisOptions).toBe(&#x27;object&#x27;);\n      expect(TCRedisOptions.containerName).toEqual(`${containerName_prefix}-redis`);\n      expect(TCRedisOptions.ports).toEqual([\n        {\n          container: 6379,\n          host: 6379,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define DynamoDB options&#x27;, async () =&gt; {\n      expect(TCDynamoDBOptions).toBeDefined();\n      expect(TCDynamoDBOptions).not.toBe(null);\n      expect(typeof TCDynamoDBOptions).toBe(&#x27;object&#x27;);\n      expect(TCDynamoDBOptions.containerName).toEqual(`${containerName_prefix}-dynamodb`);\n      expect(TCDynamoDBOptions.ports).toEqual([\n        {\n          container: 8000,\n          host: 8000,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define MongoDB options&#x27;, async () =&gt; {\n      expect(TCMongoOptions).toBeDefined();\n      expect(TCMongoOptions).not.toBe(null);\n      expect(typeof TCMongoOptions).toBe(&#x27;object&#x27;);\n      expect(TCMongoOptions.containerName).toEqual(`${containerName_prefix}-mongo`);\n      expect(TCMongoOptions.ports).toEqual([\n        {\n          container: 27017,\n          host: 27017,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define MySql options&#x27;, async () =&gt; {\n      expect(TCMySqlOptions).toBeDefined();\n      expect(TCMySqlOptions).not.toBe(null);\n      expect(typeof TCMySqlOptions).toBe(&#x27;object&#x27;);\n      expect(TCMySqlOptions.containerName).toEqual(`${containerName_prefix}-mysql`);\n      expect(TCMySqlOptions.ports).toEqual([\n        {\n          container: 3306,\n          host: 3306,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define Postgres options&#x27;, async () =&gt; {\n      expect(TCPostgresOptions).toBeDefined();\n      expect(TCPostgresOptions).not.toBe(null);\n      expect(typeof TCPostgresOptions).toBe(&#x27;object&#x27;);\n      expect(TCPostgresOptions.containerName).toEqual(`${containerName_prefix}-postgres`);\n      expect(TCPostgresOptions.ports).toEqual([\n        {\n          container: 5432,\n          host: 5432,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define ElasticSearch options&#x27;, async () =&gt; {\n      expect(TCElasticSearchOptions).toBeDefined();\n      expect(TCElasticSearchOptions).not.toBe(null);\n      expect(typeof TCElasticSearchOptions).toBe(&#x27;object&#x27;);\n      expect(TCElasticSearchOptions.containerName).toEqual(`${containerName_prefix}-elasticsearch`);\n      expect(TCElasticSearchOptions.ports).toEqual([\n        {\n          container: 9200,\n          host: 9200,\n        },\n      ]);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;aeb02e1a-d350-4359-ba3b-7b94954bb635&quot;,&quot;parentUUID&quot;:&quot;955034f6-e2ee-42f4-a3df-bd65c23b6c64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Fixtures &gt; TestContainers options &gt; should be define ElasticSearch options&quot;,&quot;title&quot;:&quot;Fixtures &gt; TestContainers options &gt; should be define ElasticSearch options&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import {\n  appConfigBase,\n  manifest,\n  TCRedisOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n  TCDynamoDBOptions,\n} from &#x27;../fixtures&#x27;;\n\nconst containerName_prefix = &#x27;tresdoce-test-container&#x27;;\ndescribe(&#x27;Fixtures&#x27;, () =&gt; {\n  describe(&#x27;appConfigBase&#x27;, () =&gt; {\n    it(&#x27;should be return appBaseConfig&#x27;, async () =&gt; {\n      expect(appConfigBase).toBeDefined();\n      expect(appConfigBase).not.toBe(null);\n      expect(typeof appConfigBase).toBe(&#x27;object&#x27;);\n    });\n  });\n\n  describe(&#x27;manifest&#x27;, () =&gt; {\n    it(&#x27;should be return appBaseConfig&#x27;, async () =&gt; {\n      expect(manifest).toBeDefined();\n      expect(manifest).not.toBe(null);\n      expect(typeof manifest).toBe(&#x27;object&#x27;);\n    });\n  });\n\n  describe(&#x27;TestContainers options&#x27;, () =&gt; {\n    it(&#x27;should be define Redis options&#x27;, async () =&gt; {\n      expect(TCRedisOptions).toBeDefined();\n      expect(TCRedisOptions).not.toBe(null);\n      expect(typeof TCRedisOptions).toBe(&#x27;object&#x27;);\n      expect(TCRedisOptions.containerName).toEqual(`${containerName_prefix}-redis`);\n      expect(TCRedisOptions.ports).toEqual([\n        {\n          container: 6379,\n          host: 6379,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define DynamoDB options&#x27;, async () =&gt; {\n      expect(TCDynamoDBOptions).toBeDefined();\n      expect(TCDynamoDBOptions).not.toBe(null);\n      expect(typeof TCDynamoDBOptions).toBe(&#x27;object&#x27;);\n      expect(TCDynamoDBOptions.containerName).toEqual(`${containerName_prefix}-dynamodb`);\n      expect(TCDynamoDBOptions.ports).toEqual([\n        {\n          container: 8000,\n          host: 8000,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define MongoDB options&#x27;, async () =&gt; {\n      expect(TCMongoOptions).toBeDefined();\n      expect(TCMongoOptions).not.toBe(null);\n      expect(typeof TCMongoOptions).toBe(&#x27;object&#x27;);\n      expect(TCMongoOptions.containerName).toEqual(`${containerName_prefix}-mongo`);\n      expect(TCMongoOptions.ports).toEqual([\n        {\n          container: 27017,\n          host: 27017,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define MySql options&#x27;, async () =&gt; {\n      expect(TCMySqlOptions).toBeDefined();\n      expect(TCMySqlOptions).not.toBe(null);\n      expect(typeof TCMySqlOptions).toBe(&#x27;object&#x27;);\n      expect(TCMySqlOptions.containerName).toEqual(`${containerName_prefix}-mysql`);\n      expect(TCMySqlOptions.ports).toEqual([\n        {\n          container: 3306,\n          host: 3306,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define Postgres options&#x27;, async () =&gt; {\n      expect(TCPostgresOptions).toBeDefined();\n      expect(TCPostgresOptions).not.toBe(null);\n      expect(typeof TCPostgresOptions).toBe(&#x27;object&#x27;);\n      expect(TCPostgresOptions.containerName).toEqual(`${containerName_prefix}-postgres`);\n      expect(TCPostgresOptions.ports).toEqual([\n        {\n          container: 5432,\n          host: 5432,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define ElasticSearch options&#x27;, async () =&gt; {\n      expect(TCElasticSearchOptions).toBeDefined();\n      expect(TCElasticSearchOptions).not.toBe(null);\n      expect(typeof TCElasticSearchOptions).toBe(&#x27;object&#x27;);\n      expect(TCElasticSearchOptions.containerName).toEqual(`${containerName_prefix}-elasticsearch`);\n      expect(TCElasticSearchOptions.ports).toEqual([\n        {\n          container: 9200,\n          host: 9200,\n        },\n      ]);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d69a2560-68bf-4039-b0fc-fbe9a7df5d2d&quot;,&quot;parentUUID&quot;:&quot;955034f6-e2ee-42f4-a3df-bd65c23b6c64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;1bb3bed5-4684-4710-ba85-a4b285791c0c&quot;,&quot;176e46ee-fd85-43f1-bc1e-209c013df4ba&quot;,&quot;b935cc87-5a41-4248-87c3-891cc7c2dac4&quot;,&quot;2fda0ca2-8b42-4094-9428-a9c26cbfcd0f&quot;,&quot;68b721a3-fcdb-4c12-bd58-f9d71e7be663&quot;,&quot;039a5bd4-04bf-4a64-9b03-644a327641a6&quot;,&quot;8c3ed895-4920-47ad-95f4-b353d26a7803&quot;,&quot;a3a99614-5a4b-43af-8613-121187178d7b&quot;,&quot;c4fce2eb-9ae7-43b6-8fa1-1427971d8a08&quot;,&quot;e115d45e-9ecc-4d1d-81bc-6b9025a9591b&quot;,&quot;70c4dd82-7d65-4f16-a22f-f580e5d4dba4&quot;,&quot;75a38f7d-1937-46fb-ac3f-0374bbba8400&quot;,&quot;fe98144c-a2c2-4d0b-b8b6-dd69a79a411a&quot;,&quot;3c5e2304-b489-4c39-a7f5-393171606680&quot;,&quot;4429cadf-41bb-438e-8288-86110415b4e6&quot;,&quot;86a24f69-e77f-4682-9b05-350c9eeb0da6&quot;,&quot;750ac110-e6b2-456d-94ec-bfd55167ba35&quot;,&quot;b820906b-35b3-49e6-b65d-65c472e3aaa9&quot;,&quot;881bc5d8-5298-40e0-be1b-107511a857ba&quot;,&quot;2f165336-0fca-4038-8ec7-a7ed9fb95acc&quot;,&quot;e05cf343-4254-4bb0-89a5-95f5df1dac6b&quot;,&quot;b4e54be0-036e-4935-a84f-9e2e0e8ee420&quot;,&quot;a2565c7d-23fa-4dca-8e2b-f057ee059c17&quot;,&quot;eabb8185-e7af-4500-9654-9652c8fa1ba5&quot;,&quot;216617f3-97a9-4d89-8b54-622765a250e3&quot;,&quot;72ea864d-703e-43d2-b42a-089dd8208cda&quot;,&quot;4736204e-c0f9-46d7-898e-65699fe20309&quot;,&quot;2d441cb7-a513-49e6-8a11-32575d63b2b8&quot;,&quot;aeb02e1a-d350-4359-ba3b-7b94954bb635&quot;,&quot;d69a2560-68bf-4039-b0fc-fbe9a7df5d2d&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:50098,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:5000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:5000},{&quot;uuid&quot;:&quot;3da091d5-88ce-4d66-91bf-e501cb9b2e12&quot;,&quot;title&quot;:&quot;&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;3da091d5-88ce-4d66-91bf-e501cb9b2e61&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/typeorm&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;3da091d5-88ce-4d66-91bf-e501cb9b2e62&quot;,&quot;title&quot;:&quot;TypeOrm&quot;,&quot;fullFile&quot;:&quot;/Users/maximilianodelgado/Projects/Mex/tresdoce-nestjs-toolkit/packages/typeorm/src/__test__/typeorm.module.spec.ts&quot;,&quot;file&quot;:&quot;typeorm.module.spec.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;188bb0af-be76-427f-9c0b-9dd4f76cbc4a&quot;,&quot;title&quot;:&quot;Postgres&quot;,&quot;fullFile&quot;:&quot;/Users/maximilianodelgado/Projects/Mex/tresdoce-nestjs-toolkit/packages/typeorm/src/__test__/typeorm.module.spec.ts&quot;,&quot;file&quot;:&quot;typeorm.module.spec.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;fullTitle&quot;:&quot;TypeOrm &gt; Postgres &gt; should be defined&quot;,&quot;title&quot;:&quot;should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:353,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport {\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  tcName,\n  testContainers,\n  fixturePostResponse,\n  fixtureUserArrayResponse,\n} from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { Repository } from &#x27;typeorm&#x27;;\n\nimport { TypeOrmClientModule } from &#x27;../typeorm/typeorm.module&#x27;;\nimport { Post } from &#x27;./utils/post.entity&#x27;;\nimport { User } from &#x27;./utils/user.entity&#x27;;\n\nimport { configPostgres, configMySql, configMongo } from &#x27;./utils&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TypeOrm&#x27;, () =&gt; {\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository&lt;Post&gt;;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, {\n        ...TCPostgresOptions,\n        containerName: `${tcName}-typeorm-postgres`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configPostgres],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([Post]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get(&#x27;PostRepository&#x27;);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it(&#x27;should be return an array of post&#x27;, async () =&gt; {\n      await repository.save([fixturePostResponse]);\n\n      const query = await repository.find();\n      expect(query).toEqual([fixturePostResponse]);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository&lt;Post&gt;;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        containerName: `${tcName}-typeorm-mysql`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configMySql],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([Post]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get(&#x27;PostRepository&#x27;);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it(&#x27;should be return an array of post&#x27;, async () =&gt; {\n      await repository.save([fixturePostResponse]);\n\n      const query = await repository.find();\n      expect(query).toEqual([fixturePostResponse]);\n    });\n  });\n\n  describe(&#x27;Mongo&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository&lt;User&gt;;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        containerName: `${tcName}-typeorm-mongo`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configMongo],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([User]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get(&#x27;UserRepository&#x27;);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it(&#x27;should be return an array of user&#x27;, async () =&gt; {\n      await repository.save(fixtureUserArrayResponse);\n\n      const query: User[] = await repository.find();\n      expect(query).toEqual(expect.any(Array));\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;23ed9ff5-ea5d-4b82-89f5-73f5b27da913&quot;,&quot;parentUUID&quot;:&quot;188bb0af-be76-427f-9c0b-9dd4f76cbc4a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;TypeOrm &gt; Postgres &gt; should be return an array of post&quot;,&quot;title&quot;:&quot;should be return an array of post&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:80,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport {\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  tcName,\n  testContainers,\n  fixturePostResponse,\n  fixtureUserArrayResponse,\n} from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { Repository } from &#x27;typeorm&#x27;;\n\nimport { TypeOrmClientModule } from &#x27;../typeorm/typeorm.module&#x27;;\nimport { Post } from &#x27;./utils/post.entity&#x27;;\nimport { User } from &#x27;./utils/user.entity&#x27;;\n\nimport { configPostgres, configMySql, configMongo } from &#x27;./utils&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TypeOrm&#x27;, () =&gt; {\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository&lt;Post&gt;;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, {\n        ...TCPostgresOptions,\n        containerName: `${tcName}-typeorm-postgres`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configPostgres],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([Post]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get(&#x27;PostRepository&#x27;);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it(&#x27;should be return an array of post&#x27;, async () =&gt; {\n      await repository.save([fixturePostResponse]);\n\n      const query = await repository.find();\n      expect(query).toEqual([fixturePostResponse]);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository&lt;Post&gt;;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        containerName: `${tcName}-typeorm-mysql`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configMySql],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([Post]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get(&#x27;PostRepository&#x27;);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it(&#x27;should be return an array of post&#x27;, async () =&gt; {\n      await repository.save([fixturePostResponse]);\n\n      const query = await repository.find();\n      expect(query).toEqual([fixturePostResponse]);\n    });\n  });\n\n  describe(&#x27;Mongo&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository&lt;User&gt;;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        containerName: `${tcName}-typeorm-mongo`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configMongo],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([User]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get(&#x27;UserRepository&#x27;);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it(&#x27;should be return an array of user&#x27;, async () =&gt; {\n      await repository.save(fixtureUserArrayResponse);\n\n      const query: User[] = await repository.find();\n      expect(query).toEqual(expect.any(Array));\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;961f6707-73bb-445b-b0a5-054de8be1001&quot;,&quot;parentUUID&quot;:&quot;188bb0af-be76-427f-9c0b-9dd4f76cbc4a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;23ed9ff5-ea5d-4b82-89f5-73f5b27da913&quot;,&quot;961f6707-73bb-445b-b0a5-054de8be1001&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:5000},{&quot;uuid&quot;:&quot;188bb0af-be76-427f-9c0b-9dd4f76cbc4a&quot;,&quot;title&quot;:&quot;MySql&quot;,&quot;fullFile&quot;:&quot;/Users/maximilianodelgado/Projects/Mex/tresdoce-nestjs-toolkit/packages/typeorm/src/__test__/typeorm.module.spec.ts&quot;,&quot;file&quot;:&quot;typeorm.module.spec.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;fullTitle&quot;:&quot;TypeOrm &gt; MySql &gt; should be defined&quot;,&quot;title&quot;:&quot;should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:127,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport {\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  tcName,\n  testContainers,\n  fixturePostResponse,\n  fixtureUserArrayResponse,\n} from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { Repository } from &#x27;typeorm&#x27;;\n\nimport { TypeOrmClientModule } from &#x27;../typeorm/typeorm.module&#x27;;\nimport { Post } from &#x27;./utils/post.entity&#x27;;\nimport { User } from &#x27;./utils/user.entity&#x27;;\n\nimport { configPostgres, configMySql, configMongo } from &#x27;./utils&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TypeOrm&#x27;, () =&gt; {\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository&lt;Post&gt;;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, {\n        ...TCPostgresOptions,\n        containerName: `${tcName}-typeorm-postgres`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configPostgres],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([Post]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get(&#x27;PostRepository&#x27;);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it(&#x27;should be return an array of post&#x27;, async () =&gt; {\n      await repository.save([fixturePostResponse]);\n\n      const query = await repository.find();\n      expect(query).toEqual([fixturePostResponse]);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository&lt;Post&gt;;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        containerName: `${tcName}-typeorm-mysql`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configMySql],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([Post]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get(&#x27;PostRepository&#x27;);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it(&#x27;should be return an array of post&#x27;, async () =&gt; {\n      await repository.save([fixturePostResponse]);\n\n      const query = await repository.find();\n      expect(query).toEqual([fixturePostResponse]);\n    });\n  });\n\n  describe(&#x27;Mongo&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository&lt;User&gt;;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        containerName: `${tcName}-typeorm-mongo`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configMongo],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([User]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get(&#x27;UserRepository&#x27;);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it(&#x27;should be return an array of user&#x27;, async () =&gt; {\n      await repository.save(fixtureUserArrayResponse);\n\n      const query: User[] = await repository.find();\n      expect(query).toEqual(expect.any(Array));\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;080d95da-bf51-45a0-ba18-00d8601761d4&quot;,&quot;parentUUID&quot;:&quot;188bb0af-be76-427f-9c0b-9dd4f76cbc4a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;TypeOrm &gt; MySql &gt; should be return an array of post&quot;,&quot;title&quot;:&quot;should be return an array of post&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:58,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport {\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  tcName,\n  testContainers,\n  fixturePostResponse,\n  fixtureUserArrayResponse,\n} from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { Repository } from &#x27;typeorm&#x27;;\n\nimport { TypeOrmClientModule } from &#x27;../typeorm/typeorm.module&#x27;;\nimport { Post } from &#x27;./utils/post.entity&#x27;;\nimport { User } from &#x27;./utils/user.entity&#x27;;\n\nimport { configPostgres, configMySql, configMongo } from &#x27;./utils&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TypeOrm&#x27;, () =&gt; {\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository&lt;Post&gt;;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, {\n        ...TCPostgresOptions,\n        containerName: `${tcName}-typeorm-postgres`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configPostgres],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([Post]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get(&#x27;PostRepository&#x27;);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it(&#x27;should be return an array of post&#x27;, async () =&gt; {\n      await repository.save([fixturePostResponse]);\n\n      const query = await repository.find();\n      expect(query).toEqual([fixturePostResponse]);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository&lt;Post&gt;;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        containerName: `${tcName}-typeorm-mysql`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configMySql],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([Post]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get(&#x27;PostRepository&#x27;);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it(&#x27;should be return an array of post&#x27;, async () =&gt; {\n      await repository.save([fixturePostResponse]);\n\n      const query = await repository.find();\n      expect(query).toEqual([fixturePostResponse]);\n    });\n  });\n\n  describe(&#x27;Mongo&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository&lt;User&gt;;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        containerName: `${tcName}-typeorm-mongo`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configMongo],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([User]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get(&#x27;UserRepository&#x27;);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it(&#x27;should be return an array of user&#x27;, async () =&gt; {\n      await repository.save(fixtureUserArrayResponse);\n\n      const query: User[] = await repository.find();\n      expect(query).toEqual(expect.any(Array));\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e906611d-eeab-4e62-84aa-34d55de483cc&quot;,&quot;parentUUID&quot;:&quot;188bb0af-be76-427f-9c0b-9dd4f76cbc4a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;080d95da-bf51-45a0-ba18-00d8601761d4&quot;,&quot;e906611d-eeab-4e62-84aa-34d55de483cc&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:5000},{&quot;uuid&quot;:&quot;188bb0af-be76-427f-9c0b-9dd4f76cbc4a&quot;,&quot;title&quot;:&quot;Mongo&quot;,&quot;fullFile&quot;:&quot;/Users/maximilianodelgado/Projects/Mex/tresdoce-nestjs-toolkit/packages/typeorm/src/__test__/typeorm.module.spec.ts&quot;,&quot;file&quot;:&quot;typeorm.module.spec.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;fullTitle&quot;:&quot;TypeOrm &gt; Mongo &gt; should be defined&quot;,&quot;title&quot;:&quot;should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2294,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport {\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  tcName,\n  testContainers,\n  fixturePostResponse,\n  fixtureUserArrayResponse,\n} from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { Repository } from &#x27;typeorm&#x27;;\n\nimport { TypeOrmClientModule } from &#x27;../typeorm/typeorm.module&#x27;;\nimport { Post } from &#x27;./utils/post.entity&#x27;;\nimport { User } from &#x27;./utils/user.entity&#x27;;\n\nimport { configPostgres, configMySql, configMongo } from &#x27;./utils&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TypeOrm&#x27;, () =&gt; {\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository&lt;Post&gt;;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, {\n        ...TCPostgresOptions,\n        containerName: `${tcName}-typeorm-postgres`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configPostgres],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([Post]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get(&#x27;PostRepository&#x27;);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it(&#x27;should be return an array of post&#x27;, async () =&gt; {\n      await repository.save([fixturePostResponse]);\n\n      const query = await repository.find();\n      expect(query).toEqual([fixturePostResponse]);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository&lt;Post&gt;;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        containerName: `${tcName}-typeorm-mysql`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configMySql],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([Post]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get(&#x27;PostRepository&#x27;);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it(&#x27;should be return an array of post&#x27;, async () =&gt; {\n      await repository.save([fixturePostResponse]);\n\n      const query = await repository.find();\n      expect(query).toEqual([fixturePostResponse]);\n    });\n  });\n\n  describe(&#x27;Mongo&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository&lt;User&gt;;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        containerName: `${tcName}-typeorm-mongo`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configMongo],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([User]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get(&#x27;UserRepository&#x27;);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it(&#x27;should be return an array of user&#x27;, async () =&gt; {\n      await repository.save(fixtureUserArrayResponse);\n\n      const query: User[] = await repository.find();\n      expect(query).toEqual(expect.any(Array));\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a3a99e24-e583-46a0-84cd-36b469e14223&quot;,&quot;parentUUID&quot;:&quot;188bb0af-be76-427f-9c0b-9dd4f76cbc4a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;TypeOrm &gt; Mongo &gt; should be return an array of user&quot;,&quot;title&quot;:&quot;should be return an array of user&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:47,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport {\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  tcName,\n  testContainers,\n  fixturePostResponse,\n  fixtureUserArrayResponse,\n} from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { Repository } from &#x27;typeorm&#x27;;\n\nimport { TypeOrmClientModule } from &#x27;../typeorm/typeorm.module&#x27;;\nimport { Post } from &#x27;./utils/post.entity&#x27;;\nimport { User } from &#x27;./utils/user.entity&#x27;;\n\nimport { configPostgres, configMySql, configMongo } from &#x27;./utils&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TypeOrm&#x27;, () =&gt; {\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository&lt;Post&gt;;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, {\n        ...TCPostgresOptions,\n        containerName: `${tcName}-typeorm-postgres`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configPostgres],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([Post]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get(&#x27;PostRepository&#x27;);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it(&#x27;should be return an array of post&#x27;, async () =&gt; {\n      await repository.save([fixturePostResponse]);\n\n      const query = await repository.find();\n      expect(query).toEqual([fixturePostResponse]);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository&lt;Post&gt;;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        containerName: `${tcName}-typeorm-mysql`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configMySql],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([Post]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get(&#x27;PostRepository&#x27;);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it(&#x27;should be return an array of post&#x27;, async () =&gt; {\n      await repository.save([fixturePostResponse]);\n\n      const query = await repository.find();\n      expect(query).toEqual([fixturePostResponse]);\n    });\n  });\n\n  describe(&#x27;Mongo&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository&lt;User&gt;;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        containerName: `${tcName}-typeorm-mongo`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configMongo],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([User]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get(&#x27;UserRepository&#x27;);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it(&#x27;should be return an array of user&#x27;, async () =&gt; {\n      await repository.save(fixtureUserArrayResponse);\n\n      const query: User[] = await repository.find();\n      expect(query).toEqual(expect.any(Array));\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a90c78ef-1708-45d0-9adc-010a93dade7b&quot;,&quot;parentUUID&quot;:&quot;188bb0af-be76-427f-9c0b-9dd4f76cbc4a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;a3a99e24-e583-46a0-84cd-36b469e14223&quot;,&quot;a90c78ef-1708-45d0-9adc-010a93dade7b&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:5000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:5000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:5000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:5000}]}" data-config="{&quot;reportFilename&quot;:&quot;index&quot;,&quot;reportDir&quot;:&quot;mochawesome-report&quot;,&quot;reportTitle&quot;:&quot;Tresdoce NestJS Toolkit&quot;,&quot;reportPageTitle&quot;:&quot;Tresdoce NestJS Toolkit - Test Reports&quot;,&quot;inline&quot;:false,&quot;inlineAssets&quot;:false,&quot;assetsDir&quot;:&quot;mochawesome-report/assets&quot;,&quot;cdn&quot;:false,&quot;charts&quot;:true,&quot;enableCharts&quot;:true,&quot;code&quot;:true,&quot;enableCode&quot;:true,&quot;autoOpen&quot;:false,&quot;overwrite&quot;:true,&quot;timestamp&quot;:false,&quot;ts&quot;:false,&quot;showPassed&quot;:true,&quot;showFailed&quot;:true,&quot;showPending&quot;:true,&quot;showSkipped&quot;:false,&quot;showHooks&quot;:&quot;failed&quot;,&quot;saveJson&quot;:true,&quot;saveHtml&quot;:true,&quot;dev&quot;:false,&quot;jsonFile&quot;:&quot;/Users/maximilianodelgado/Projects/Mex/tresdoce-nestjs-toolkit/mochawesome-report/index.json&quot;,&quot;htmlFile&quot;:&quot;/Users/maximilianodelgado/Projects/Mex/tresdoce-nestjs-toolkit/mochawesome-report/index.html&quot;}"><div id="report"></div><script src="assets/app.js"></script></body></html>