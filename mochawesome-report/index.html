<!doctype html>
<html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Tresdoce NestJS Toolkit - Test Reports</title><link rel="stylesheet" href="assets/app.css"/></head><body data-raw="{&quot;stats&quot;:{&quot;suites&quot;:13,&quot;tests&quot;:155,&quot;passes&quot;:155,&quot;pending&quot;:0,&quot;failures&quot;:0,&quot;testsRegistered&quot;:155,&quot;passPercent&quot;:100,&quot;pendingPercent&quot;:0,&quot;other&quot;:0,&quot;hasOther&quot;:false,&quot;skipped&quot;:0,&quot;hasSkipped&quot;:false,&quot;start&quot;:&quot;2023-05-03T01:32:37.767Z&quot;,&quot;end&quot;:&quot;2023-05-03T01:35:52.163Z&quot;,&quot;duration&quot;:194396},&quot;results&quot;:[{&quot;uuid&quot;:&quot;a7ae22a6-4874-403a-91c1-d116952cc071&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/archetype&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;013d5e97-b018-44c6-ae1f-09ef4d3d98f8&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/archetype&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;fullTitle&quot;:&quot;Constants &gt; should be return exclude to prefix global&quot;,&quot;title&quot;:&quot;Constants &gt; should be return exclude to prefix global&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { RequestMethod } from &#x27;@nestjs/common&#x27;;\nimport { manifestControllerExcludes } from &#x27;../archetype/constants/archetype.constants&#x27;;\n\ndescribe(&#x27;Constants&#x27;, () =&gt; {\n  it(&#x27;should be return exclude to prefix global&#x27;, async () =&gt; {\n    expect(manifestControllerExcludes).toEqual(expect.any(Array));\n    expect(manifestControllerExcludes).toMatchObject([\n      {\n        path: &#x27;/info&#x27;,\n        method: RequestMethod.GET,\n      },\n    ]);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a60c6b32-3cf2-4fc6-9de6-1587012ee689&quot;,&quot;parentUUID&quot;:&quot;013d5e97-b018-44c6-ae1f-09ef4d3d98f8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;ArchetypeService &gt; should be defined&quot;,&quot;title&quot;:&quot;ArchetypeService &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:14,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\n\nimport { config, manifest } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\n\nimport { ArchetypeModule } from &#x27;../archetype/archetype.module&#x27;;\nimport { ArchetypeService } from &#x27;../archetype/services/archetype.service&#x27;;\n\ndescribe(&#x27;ArchetypeService&#x27;, () =&gt; {\n  let service: ArchetypeService;\n  /*const archetypeService = {\n      readFile: jest.fn(() =&gt; manifest),\n      getArchetypeVersion: jest.fn(() =&gt; ({ archetypeVersion: manifest.archetypeVersion })),\n      getApplicationInfo: jest.fn(() =&gt; ({\n        name: manifest.name,\n        version: manifest.version,\n        description: manifest.description,\n        author: manifest.author,\n        repository: manifest.repository,\n        homepage: manifest.homepage,\n        dependencies: manifest.dependencies,\n        devDependencies: manifest.devDependencies,\n      })),\n      generateManifest: jest.fn(() =&gt; manifest),\n    };*/\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        ArchetypeModule,\n      ],\n      providers: [ArchetypeService],\n    }).compile();\n\n    service = module.get&lt;ArchetypeService&gt;(ArchetypeService);\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(service).toBeDefined();\n  });\n\n  it(&#x27;should be read package file&#x27;, async () =&gt; {\n    const packageFile = await service.readFile(__dirname, &#x27;../../package.json&#x27;);\n    expect(packageFile).toBeDefined();\n    expect(packageFile).toEqual(expect.any(Object));\n  });\n\n  it(&#x27;should be return archetype version&#x27;, async () =&gt; {\n    service.readFile = jest.fn().mockImplementation(() =&gt; ({ version: manifest.archetypeVersion }));\n\n    expect(await service.getArchetypeVersion()).toEqual({\n      archetypeVersion: manifest.archetypeVersion,\n    });\n  });\n\n  it(&#x27;should be return application info&#x27;, async () =&gt; {\n    service.readFile = jest.fn().mockImplementation(() =&gt; ({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: manifest.dependencies,\n      devDependencies: manifest.devDependencies,\n    }));\n\n    expect(await service.getApplicationInfo()).toEqual({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: {\n        &#x27;@tresdoce-nestjs-toolkit/archetype&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@tresdoce-nestjs-toolkit/health&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@tresdoce-nestjs-toolkit/http-client&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@nestjs/class-transformer&#x27;: &#x27;^0.4.0&#x27;,\n        &#x27;@nestjs/class-validator&#x27;: &#x27;^0.13.3&#x27;,\n        &#x27;@nestjs/common&#x27;: &#x27;^9.2.1&#x27;,\n        &#x27;@nestjs/config&#x27;: &#x27;^2.2.0&#x27;,\n        &#x27;@nestjs/core&#x27;: &#x27;^8.2.5&#x27;,\n        &#x27;@nestjs/platform-express&#x27;: &#x27;^8.2.5&#x27;,\n        &#x27;@nestjs/swagger&#x27;: &#x27;^5.1.5&#x27;,\n      },\n      devDependencies: {\n        &#x27;@tresdoce-nestjs-toolkit/commons&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@nestjs/cli&#x27;: &#x27;^9.1.8&#x27;,\n        &#x27;@nestjs/schematics&#x27;: &#x27;^9.1.0&#x27;,\n        &#x27;@nestjs/testing&#x27;: &#x27;^9.4.0&#x27;,\n      },\n    });\n  });\n\n  it(&#x27;should be return manifest&#x27;, async () =&gt; {\n    service.getArchetypeVersion = jest.fn().mockImplementation(() =&gt; ({\n      archetypeVersion: manifest.archetypeVersion,\n    }));\n\n    service.getApplicationInfo = jest.fn().mockImplementation(() =&gt; ({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: manifest.dependencies,\n      devDependencies: manifest.devDependencies,\n    }));\n\n    expect(await service.generateManifest()).toEqual({ ...manifest });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;8879d387-8daa-40f8-8338-f811c0eada6b&quot;,&quot;parentUUID&quot;:&quot;013d5e97-b018-44c6-ae1f-09ef4d3d98f8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;ArchetypeService &gt; should be read package file&quot;,&quot;title&quot;:&quot;ArchetypeService &gt; should be read package file&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\n\nimport { config, manifest } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\n\nimport { ArchetypeModule } from &#x27;../archetype/archetype.module&#x27;;\nimport { ArchetypeService } from &#x27;../archetype/services/archetype.service&#x27;;\n\ndescribe(&#x27;ArchetypeService&#x27;, () =&gt; {\n  let service: ArchetypeService;\n  /*const archetypeService = {\n      readFile: jest.fn(() =&gt; manifest),\n      getArchetypeVersion: jest.fn(() =&gt; ({ archetypeVersion: manifest.archetypeVersion })),\n      getApplicationInfo: jest.fn(() =&gt; ({\n        name: manifest.name,\n        version: manifest.version,\n        description: manifest.description,\n        author: manifest.author,\n        repository: manifest.repository,\n        homepage: manifest.homepage,\n        dependencies: manifest.dependencies,\n        devDependencies: manifest.devDependencies,\n      })),\n      generateManifest: jest.fn(() =&gt; manifest),\n    };*/\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        ArchetypeModule,\n      ],\n      providers: [ArchetypeService],\n    }).compile();\n\n    service = module.get&lt;ArchetypeService&gt;(ArchetypeService);\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(service).toBeDefined();\n  });\n\n  it(&#x27;should be read package file&#x27;, async () =&gt; {\n    const packageFile = await service.readFile(__dirname, &#x27;../../package.json&#x27;);\n    expect(packageFile).toBeDefined();\n    expect(packageFile).toEqual(expect.any(Object));\n  });\n\n  it(&#x27;should be return archetype version&#x27;, async () =&gt; {\n    service.readFile = jest.fn().mockImplementation(() =&gt; ({ version: manifest.archetypeVersion }));\n\n    expect(await service.getArchetypeVersion()).toEqual({\n      archetypeVersion: manifest.archetypeVersion,\n    });\n  });\n\n  it(&#x27;should be return application info&#x27;, async () =&gt; {\n    service.readFile = jest.fn().mockImplementation(() =&gt; ({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: manifest.dependencies,\n      devDependencies: manifest.devDependencies,\n    }));\n\n    expect(await service.getApplicationInfo()).toEqual({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: {\n        &#x27;@tresdoce-nestjs-toolkit/archetype&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@tresdoce-nestjs-toolkit/health&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@tresdoce-nestjs-toolkit/http-client&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@nestjs/class-transformer&#x27;: &#x27;^0.4.0&#x27;,\n        &#x27;@nestjs/class-validator&#x27;: &#x27;^0.13.3&#x27;,\n        &#x27;@nestjs/common&#x27;: &#x27;^9.2.1&#x27;,\n        &#x27;@nestjs/config&#x27;: &#x27;^2.2.0&#x27;,\n        &#x27;@nestjs/core&#x27;: &#x27;^8.2.5&#x27;,\n        &#x27;@nestjs/platform-express&#x27;: &#x27;^8.2.5&#x27;,\n        &#x27;@nestjs/swagger&#x27;: &#x27;^5.1.5&#x27;,\n      },\n      devDependencies: {\n        &#x27;@tresdoce-nestjs-toolkit/commons&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@nestjs/cli&#x27;: &#x27;^9.1.8&#x27;,\n        &#x27;@nestjs/schematics&#x27;: &#x27;^9.1.0&#x27;,\n        &#x27;@nestjs/testing&#x27;: &#x27;^9.4.0&#x27;,\n      },\n    });\n  });\n\n  it(&#x27;should be return manifest&#x27;, async () =&gt; {\n    service.getArchetypeVersion = jest.fn().mockImplementation(() =&gt; ({\n      archetypeVersion: manifest.archetypeVersion,\n    }));\n\n    service.getApplicationInfo = jest.fn().mockImplementation(() =&gt; ({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: manifest.dependencies,\n      devDependencies: manifest.devDependencies,\n    }));\n\n    expect(await service.generateManifest()).toEqual({ ...manifest });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;83756f85-cadf-4414-927c-f3fc09b0d28c&quot;,&quot;parentUUID&quot;:&quot;013d5e97-b018-44c6-ae1f-09ef4d3d98f8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;ArchetypeService &gt; should be return archetype version&quot;,&quot;title&quot;:&quot;ArchetypeService &gt; should be return archetype version&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\n\nimport { config, manifest } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\n\nimport { ArchetypeModule } from &#x27;../archetype/archetype.module&#x27;;\nimport { ArchetypeService } from &#x27;../archetype/services/archetype.service&#x27;;\n\ndescribe(&#x27;ArchetypeService&#x27;, () =&gt; {\n  let service: ArchetypeService;\n  /*const archetypeService = {\n      readFile: jest.fn(() =&gt; manifest),\n      getArchetypeVersion: jest.fn(() =&gt; ({ archetypeVersion: manifest.archetypeVersion })),\n      getApplicationInfo: jest.fn(() =&gt; ({\n        name: manifest.name,\n        version: manifest.version,\n        description: manifest.description,\n        author: manifest.author,\n        repository: manifest.repository,\n        homepage: manifest.homepage,\n        dependencies: manifest.dependencies,\n        devDependencies: manifest.devDependencies,\n      })),\n      generateManifest: jest.fn(() =&gt; manifest),\n    };*/\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        ArchetypeModule,\n      ],\n      providers: [ArchetypeService],\n    }).compile();\n\n    service = module.get&lt;ArchetypeService&gt;(ArchetypeService);\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(service).toBeDefined();\n  });\n\n  it(&#x27;should be read package file&#x27;, async () =&gt; {\n    const packageFile = await service.readFile(__dirname, &#x27;../../package.json&#x27;);\n    expect(packageFile).toBeDefined();\n    expect(packageFile).toEqual(expect.any(Object));\n  });\n\n  it(&#x27;should be return archetype version&#x27;, async () =&gt; {\n    service.readFile = jest.fn().mockImplementation(() =&gt; ({ version: manifest.archetypeVersion }));\n\n    expect(await service.getArchetypeVersion()).toEqual({\n      archetypeVersion: manifest.archetypeVersion,\n    });\n  });\n\n  it(&#x27;should be return application info&#x27;, async () =&gt; {\n    service.readFile = jest.fn().mockImplementation(() =&gt; ({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: manifest.dependencies,\n      devDependencies: manifest.devDependencies,\n    }));\n\n    expect(await service.getApplicationInfo()).toEqual({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: {\n        &#x27;@tresdoce-nestjs-toolkit/archetype&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@tresdoce-nestjs-toolkit/health&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@tresdoce-nestjs-toolkit/http-client&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@nestjs/class-transformer&#x27;: &#x27;^0.4.0&#x27;,\n        &#x27;@nestjs/class-validator&#x27;: &#x27;^0.13.3&#x27;,\n        &#x27;@nestjs/common&#x27;: &#x27;^9.2.1&#x27;,\n        &#x27;@nestjs/config&#x27;: &#x27;^2.2.0&#x27;,\n        &#x27;@nestjs/core&#x27;: &#x27;^8.2.5&#x27;,\n        &#x27;@nestjs/platform-express&#x27;: &#x27;^8.2.5&#x27;,\n        &#x27;@nestjs/swagger&#x27;: &#x27;^5.1.5&#x27;,\n      },\n      devDependencies: {\n        &#x27;@tresdoce-nestjs-toolkit/commons&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@nestjs/cli&#x27;: &#x27;^9.1.8&#x27;,\n        &#x27;@nestjs/schematics&#x27;: &#x27;^9.1.0&#x27;,\n        &#x27;@nestjs/testing&#x27;: &#x27;^9.4.0&#x27;,\n      },\n    });\n  });\n\n  it(&#x27;should be return manifest&#x27;, async () =&gt; {\n    service.getArchetypeVersion = jest.fn().mockImplementation(() =&gt; ({\n      archetypeVersion: manifest.archetypeVersion,\n    }));\n\n    service.getApplicationInfo = jest.fn().mockImplementation(() =&gt; ({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: manifest.dependencies,\n      devDependencies: manifest.devDependencies,\n    }));\n\n    expect(await service.generateManifest()).toEqual({ ...manifest });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ef6eba1f-9126-4bf6-a8f2-d4d6f610c84e&quot;,&quot;parentUUID&quot;:&quot;013d5e97-b018-44c6-ae1f-09ef4d3d98f8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;ArchetypeService &gt; should be return application info&quot;,&quot;title&quot;:&quot;ArchetypeService &gt; should be return application info&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\n\nimport { config, manifest } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\n\nimport { ArchetypeModule } from &#x27;../archetype/archetype.module&#x27;;\nimport { ArchetypeService } from &#x27;../archetype/services/archetype.service&#x27;;\n\ndescribe(&#x27;ArchetypeService&#x27;, () =&gt; {\n  let service: ArchetypeService;\n  /*const archetypeService = {\n      readFile: jest.fn(() =&gt; manifest),\n      getArchetypeVersion: jest.fn(() =&gt; ({ archetypeVersion: manifest.archetypeVersion })),\n      getApplicationInfo: jest.fn(() =&gt; ({\n        name: manifest.name,\n        version: manifest.version,\n        description: manifest.description,\n        author: manifest.author,\n        repository: manifest.repository,\n        homepage: manifest.homepage,\n        dependencies: manifest.dependencies,\n        devDependencies: manifest.devDependencies,\n      })),\n      generateManifest: jest.fn(() =&gt; manifest),\n    };*/\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        ArchetypeModule,\n      ],\n      providers: [ArchetypeService],\n    }).compile();\n\n    service = module.get&lt;ArchetypeService&gt;(ArchetypeService);\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(service).toBeDefined();\n  });\n\n  it(&#x27;should be read package file&#x27;, async () =&gt; {\n    const packageFile = await service.readFile(__dirname, &#x27;../../package.json&#x27;);\n    expect(packageFile).toBeDefined();\n    expect(packageFile).toEqual(expect.any(Object));\n  });\n\n  it(&#x27;should be return archetype version&#x27;, async () =&gt; {\n    service.readFile = jest.fn().mockImplementation(() =&gt; ({ version: manifest.archetypeVersion }));\n\n    expect(await service.getArchetypeVersion()).toEqual({\n      archetypeVersion: manifest.archetypeVersion,\n    });\n  });\n\n  it(&#x27;should be return application info&#x27;, async () =&gt; {\n    service.readFile = jest.fn().mockImplementation(() =&gt; ({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: manifest.dependencies,\n      devDependencies: manifest.devDependencies,\n    }));\n\n    expect(await service.getApplicationInfo()).toEqual({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: {\n        &#x27;@tresdoce-nestjs-toolkit/archetype&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@tresdoce-nestjs-toolkit/health&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@tresdoce-nestjs-toolkit/http-client&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@nestjs/class-transformer&#x27;: &#x27;^0.4.0&#x27;,\n        &#x27;@nestjs/class-validator&#x27;: &#x27;^0.13.3&#x27;,\n        &#x27;@nestjs/common&#x27;: &#x27;^9.2.1&#x27;,\n        &#x27;@nestjs/config&#x27;: &#x27;^2.2.0&#x27;,\n        &#x27;@nestjs/core&#x27;: &#x27;^8.2.5&#x27;,\n        &#x27;@nestjs/platform-express&#x27;: &#x27;^8.2.5&#x27;,\n        &#x27;@nestjs/swagger&#x27;: &#x27;^5.1.5&#x27;,\n      },\n      devDependencies: {\n        &#x27;@tresdoce-nestjs-toolkit/commons&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@nestjs/cli&#x27;: &#x27;^9.1.8&#x27;,\n        &#x27;@nestjs/schematics&#x27;: &#x27;^9.1.0&#x27;,\n        &#x27;@nestjs/testing&#x27;: &#x27;^9.4.0&#x27;,\n      },\n    });\n  });\n\n  it(&#x27;should be return manifest&#x27;, async () =&gt; {\n    service.getArchetypeVersion = jest.fn().mockImplementation(() =&gt; ({\n      archetypeVersion: manifest.archetypeVersion,\n    }));\n\n    service.getApplicationInfo = jest.fn().mockImplementation(() =&gt; ({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: manifest.dependencies,\n      devDependencies: manifest.devDependencies,\n    }));\n\n    expect(await service.generateManifest()).toEqual({ ...manifest });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;bdecd73e-a2f6-4e35-9c18-cdeac71b33c1&quot;,&quot;parentUUID&quot;:&quot;013d5e97-b018-44c6-ae1f-09ef4d3d98f8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;ArchetypeService &gt; should be return manifest&quot;,&quot;title&quot;:&quot;ArchetypeService &gt; should be return manifest&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\n\nimport { config, manifest } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\n\nimport { ArchetypeModule } from &#x27;../archetype/archetype.module&#x27;;\nimport { ArchetypeService } from &#x27;../archetype/services/archetype.service&#x27;;\n\ndescribe(&#x27;ArchetypeService&#x27;, () =&gt; {\n  let service: ArchetypeService;\n  /*const archetypeService = {\n      readFile: jest.fn(() =&gt; manifest),\n      getArchetypeVersion: jest.fn(() =&gt; ({ archetypeVersion: manifest.archetypeVersion })),\n      getApplicationInfo: jest.fn(() =&gt; ({\n        name: manifest.name,\n        version: manifest.version,\n        description: manifest.description,\n        author: manifest.author,\n        repository: manifest.repository,\n        homepage: manifest.homepage,\n        dependencies: manifest.dependencies,\n        devDependencies: manifest.devDependencies,\n      })),\n      generateManifest: jest.fn(() =&gt; manifest),\n    };*/\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        ArchetypeModule,\n      ],\n      providers: [ArchetypeService],\n    }).compile();\n\n    service = module.get&lt;ArchetypeService&gt;(ArchetypeService);\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(service).toBeDefined();\n  });\n\n  it(&#x27;should be read package file&#x27;, async () =&gt; {\n    const packageFile = await service.readFile(__dirname, &#x27;../../package.json&#x27;);\n    expect(packageFile).toBeDefined();\n    expect(packageFile).toEqual(expect.any(Object));\n  });\n\n  it(&#x27;should be return archetype version&#x27;, async () =&gt; {\n    service.readFile = jest.fn().mockImplementation(() =&gt; ({ version: manifest.archetypeVersion }));\n\n    expect(await service.getArchetypeVersion()).toEqual({\n      archetypeVersion: manifest.archetypeVersion,\n    });\n  });\n\n  it(&#x27;should be return application info&#x27;, async () =&gt; {\n    service.readFile = jest.fn().mockImplementation(() =&gt; ({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: manifest.dependencies,\n      devDependencies: manifest.devDependencies,\n    }));\n\n    expect(await service.getApplicationInfo()).toEqual({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: {\n        &#x27;@tresdoce-nestjs-toolkit/archetype&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@tresdoce-nestjs-toolkit/health&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@tresdoce-nestjs-toolkit/http-client&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@nestjs/class-transformer&#x27;: &#x27;^0.4.0&#x27;,\n        &#x27;@nestjs/class-validator&#x27;: &#x27;^0.13.3&#x27;,\n        &#x27;@nestjs/common&#x27;: &#x27;^9.2.1&#x27;,\n        &#x27;@nestjs/config&#x27;: &#x27;^2.2.0&#x27;,\n        &#x27;@nestjs/core&#x27;: &#x27;^8.2.5&#x27;,\n        &#x27;@nestjs/platform-express&#x27;: &#x27;^8.2.5&#x27;,\n        &#x27;@nestjs/swagger&#x27;: &#x27;^5.1.5&#x27;,\n      },\n      devDependencies: {\n        &#x27;@tresdoce-nestjs-toolkit/commons&#x27;: &#x27;0.0.1&#x27;,\n        &#x27;@nestjs/cli&#x27;: &#x27;^9.1.8&#x27;,\n        &#x27;@nestjs/schematics&#x27;: &#x27;^9.1.0&#x27;,\n        &#x27;@nestjs/testing&#x27;: &#x27;^9.4.0&#x27;,\n      },\n    });\n  });\n\n  it(&#x27;should be return manifest&#x27;, async () =&gt; {\n    service.getArchetypeVersion = jest.fn().mockImplementation(() =&gt; ({\n      archetypeVersion: manifest.archetypeVersion,\n    }));\n\n    service.getApplicationInfo = jest.fn().mockImplementation(() =&gt; ({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: manifest.dependencies,\n      devDependencies: manifest.devDependencies,\n    }));\n\n    expect(await service.generateManifest()).toEqual({ ...manifest });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2a3d0148-b2de-45a1-a3ce-ff742d9e2aef&quot;,&quot;parentUUID&quot;:&quot;013d5e97-b018-44c6-ae1f-09ef4d3d98f8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;ArchetypeModule &gt; should be define&quot;,&quot;title&quot;:&quot;ArchetypeModule &gt; should be define&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:360,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { config } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\n\nimport { ArchetypeModule } from &#x27;../archetype/archetype.module&#x27;;\n\ndescribe(&#x27;ArchetypeModule&#x27;, () =&gt; {\n  let app: INestApplication;\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        ArchetypeModule,\n      ],\n    }).compile();\n\n    app = module.createNestApplication();\n    await app.init();\n  });\n\n  it(&#x27;should be define&#x27;, async () =&gt; {\n    expect(app).toBeDefined();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d412e161-cb15-4a73-b9a0-6febd4e10aa2&quot;,&quot;parentUUID&quot;:&quot;013d5e97-b018-44c6-ae1f-09ef4d3d98f8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;ArchetypeController &gt; should be defined&quot;,&quot;title&quot;:&quot;ArchetypeController &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:16,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\n\nimport { config, manifest } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\n\nimport { ArchetypeModule } from &#x27;../archetype/archetype.module&#x27;;\nimport { ArchetypeController } from &#x27;../archetype/controllers/archetype.controller&#x27;;\nimport { ArchetypeService } from &#x27;../archetype/services/archetype.service&#x27;;\n\ndescribe(&#x27;ArchetypeController&#x27;, () =&gt; {\n  let controller: ArchetypeController;\n  const archetypeService = {\n    generateManifest: () =&gt; manifest,\n  };\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        ArchetypeModule,\n      ],\n      controllers: [ArchetypeController],\n      providers: [ArchetypeService],\n    })\n      .overrideProvider(ArchetypeService)\n      .useValue(archetypeService)\n      .compile();\n\n    controller = module.get&lt;ArchetypeController&gt;(ArchetypeController);\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(controller).toBeDefined();\n  });\n\n  it(&#x27;should be return manifest json&#x27;, async () =&gt; {\n    expect(await controller.getArchetypeInfo()).toBeDefined();\n    expect(await controller.getArchetypeInfo()).toEqual(manifest);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d6e6e897-d0d2-4bcf-97ac-90082bf3f014&quot;,&quot;parentUUID&quot;:&quot;013d5e97-b018-44c6-ae1f-09ef4d3d98f8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;ArchetypeController &gt; should be return manifest json&quot;,&quot;title&quot;:&quot;ArchetypeController &gt; should be return manifest json&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:12,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\n\nimport { config, manifest } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\n\nimport { ArchetypeModule } from &#x27;../archetype/archetype.module&#x27;;\nimport { ArchetypeController } from &#x27;../archetype/controllers/archetype.controller&#x27;;\nimport { ArchetypeService } from &#x27;../archetype/services/archetype.service&#x27;;\n\ndescribe(&#x27;ArchetypeController&#x27;, () =&gt; {\n  let controller: ArchetypeController;\n  const archetypeService = {\n    generateManifest: () =&gt; manifest,\n  };\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        ArchetypeModule,\n      ],\n      controllers: [ArchetypeController],\n      providers: [ArchetypeService],\n    })\n      .overrideProvider(ArchetypeService)\n      .useValue(archetypeService)\n      .compile();\n\n    controller = module.get&lt;ArchetypeController&gt;(ArchetypeController);\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(controller).toBeDefined();\n  });\n\n  it(&#x27;should be return manifest json&#x27;, async () =&gt; {\n    expect(await controller.getArchetypeInfo()).toBeDefined();\n    expect(await controller.getArchetypeInfo()).toEqual(manifest);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e496ef71-bc1f-4382-9ebf-db9f90492e4e&quot;,&quot;parentUUID&quot;:&quot;013d5e97-b018-44c6-ae1f-09ef4d3d98f8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;a60c6b32-3cf2-4fc6-9de6-1587012ee689&quot;,&quot;8879d387-8daa-40f8-8338-f811c0eada6b&quot;,&quot;83756f85-cadf-4414-927c-f3fc09b0d28c&quot;,&quot;ef6eba1f-9126-4bf6-a8f2-d4d6f610c84e&quot;,&quot;bdecd73e-a2f6-4e35-9c18-cdeac71b33c1&quot;,&quot;2a3d0148-b2de-45a1-a3ce-ff742d9e2aef&quot;,&quot;d412e161-cb15-4a73-b9a0-6febd4e10aa2&quot;,&quot;d6e6e897-d0d2-4bcf-97ac-90082bf3f014&quot;,&quot;e496ef71-bc1f-4382-9ebf-db9f90492e4e&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:420,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:5000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:5000},{&quot;uuid&quot;:&quot;33fb5b1d-74c3-472c-9103-c6cf3c09ee17&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/camunda&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;8820c353-00b1-474d-b5f0-83d8322354f9&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/camunda&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;fullTitle&quot;:&quot;CamundaModule &gt; should be defined&quot;,&quot;title&quot;:&quot;CamundaModule &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:193,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport { CamundaModule } from &#x27;../camunda/camunda.module&#x27;;\nimport { dynamicConfig, tcName, testContainers } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { Subscription } from &#x27;../camunda/decorators/camunda.decorator&#x27;;\nimport { CamundaTaskConnector } from &#x27;../camunda/providers/camunda.provider&#x27;;\n\ndescribe(&#x27;CamundaModule&#x27;, () =&gt; {\n  let app: INestApplication;\n  let container: testContainers;\n\n  beforeAll(async () =&gt; {\n    container = await new testContainers(&#x27;camunda/camunda-bpm-platform:7.17.0&#x27;, {\n      ports: [\n        {\n          container: 8080,\n          host: 8080,\n        },\n      ],\n      containerName: `${tcName}-camunda-bpm`,\n      reuse: true,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              camunda: {\n                baseUrl: &#x27;http://localhost:8080/engine-rest&#x27;,\n              },\n            }),\n          ],\n        }),\n        CamundaModule,\n      ],\n    }).compile();\n\n    app = moduleFixture.createNestApplication();\n    app.connectMicroservice({\n      strategy: app.get(CamundaTaskConnector),\n    });\n    await app.startAllMicroservices();\n    await app.init();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(app).toBeDefined();\n  });\n\n  it(&#x27;should be Subscription decorator is defined with options&#x27;, async () =&gt; {\n    const decorator = Subscription(&#x27;test-topic&#x27;, { lockDuration: 500 });\n    console.log(decorator);\n    expect(decorator).toBeDefined();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;8c4d2ae0-eb44-4b3f-8073-f2e5fe148997&quot;,&quot;parentUUID&quot;:&quot;8820c353-00b1-474d-b5f0-83d8322354f9&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;CamundaModule &gt; should be Subscription decorator is defined with options&quot;,&quot;title&quot;:&quot;CamundaModule &gt; should be Subscription decorator is defined with options&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport { CamundaModule } from &#x27;../camunda/camunda.module&#x27;;\nimport { dynamicConfig, tcName, testContainers } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { Subscription } from &#x27;../camunda/decorators/camunda.decorator&#x27;;\nimport { CamundaTaskConnector } from &#x27;../camunda/providers/camunda.provider&#x27;;\n\ndescribe(&#x27;CamundaModule&#x27;, () =&gt; {\n  let app: INestApplication;\n  let container: testContainers;\n\n  beforeAll(async () =&gt; {\n    container = await new testContainers(&#x27;camunda/camunda-bpm-platform:7.17.0&#x27;, {\n      ports: [\n        {\n          container: 8080,\n          host: 8080,\n        },\n      ],\n      containerName: `${tcName}-camunda-bpm`,\n      reuse: true,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              camunda: {\n                baseUrl: &#x27;http://localhost:8080/engine-rest&#x27;,\n              },\n            }),\n          ],\n        }),\n        CamundaModule,\n      ],\n    }).compile();\n\n    app = moduleFixture.createNestApplication();\n    app.connectMicroservice({\n      strategy: app.get(CamundaTaskConnector),\n    });\n    await app.startAllMicroservices();\n    await app.init();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(app).toBeDefined();\n  });\n\n  it(&#x27;should be Subscription decorator is defined with options&#x27;, async () =&gt; {\n    const decorator = Subscription(&#x27;test-topic&#x27;, { lockDuration: 500 });\n    console.log(decorator);\n    expect(decorator).toBeDefined();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6dcb0566-39ef-417a-8520-532051a1fcf4&quot;,&quot;parentUUID&quot;:&quot;8820c353-00b1-474d-b5f0-83d8322354f9&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;8c4d2ae0-eb44-4b3f-8073-f2e5fe148997&quot;,&quot;6dcb0566-39ef-417a-8520-532051a1fcf4&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:201,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:5000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:5000},{&quot;uuid&quot;:&quot;46cacaac-0e4b-4b6c-a255-d21b37f9bbbd&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/commons&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;a71b4b5b-1565-453d-a9f8-91cb07199a0d&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/commons&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;fullTitle&quot;:&quot;build-config &gt; should be return jest config is build&quot;,&quot;title&quot;:&quot;build-config &gt; should be return jest config is build&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { buildConfig } from &#x27;../index&#x27;;\ndescribe(&#x27;build-config&#x27;, () =&gt; {\n  const INIT_ENVS = process.env;\n\n  beforeEach(() =&gt; {\n    jest.resetModules();\n    process.env = { ...INIT_ENVS };\n  });\n\n  afterAll(() =&gt; {\n    process.env = INIT_ENVS;\n  });\n\n  it(&#x27;should be return jest config is build&#x27;, () =&gt; {\n    process.env.NODE_ENV = &#x27;build&#x27;;\n    const config = buildConfig({ output: {}, optimization: {} });\n    expect(config).not.toBe(null);\n    expect(typeof config).toBe(&#x27;object&#x27;);\n    expect(config).toBeDefined();\n    expect(config.mode).toEqual(&#x27;production&#x27;);\n  });\n\n  it(&#x27;should be return jest config not is build&#x27;, () =&gt; {\n    process.env.NODE_ENV = &#x27;dev&#x27;;\n    const config = buildConfig({ output: {}, optimization: {} });\n    expect(config).not.toBe(null);\n    expect(typeof config).toBe(&#x27;object&#x27;);\n    expect(config).toBeDefined();\n    expect(config.mode).toEqual(&#x27;none&#x27;);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e14d11a8-5bbb-4fe7-a59c-da007da535c0&quot;,&quot;parentUUID&quot;:&quot;a71b4b5b-1565-453d-a9f8-91cb07199a0d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;build-config &gt; should be return jest config not is build&quot;,&quot;title&quot;:&quot;build-config &gt; should be return jest config not is build&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { buildConfig } from &#x27;../index&#x27;;\ndescribe(&#x27;build-config&#x27;, () =&gt; {\n  const INIT_ENVS = process.env;\n\n  beforeEach(() =&gt; {\n    jest.resetModules();\n    process.env = { ...INIT_ENVS };\n  });\n\n  afterAll(() =&gt; {\n    process.env = INIT_ENVS;\n  });\n\n  it(&#x27;should be return jest config is build&#x27;, () =&gt; {\n    process.env.NODE_ENV = &#x27;build&#x27;;\n    const config = buildConfig({ output: {}, optimization: {} });\n    expect(config).not.toBe(null);\n    expect(typeof config).toBe(&#x27;object&#x27;);\n    expect(config).toBeDefined();\n    expect(config.mode).toEqual(&#x27;production&#x27;);\n  });\n\n  it(&#x27;should be return jest config not is build&#x27;, () =&gt; {\n    process.env.NODE_ENV = &#x27;dev&#x27;;\n    const config = buildConfig({ output: {}, optimization: {} });\n    expect(config).not.toBe(null);\n    expect(typeof config).toBe(&#x27;object&#x27;);\n    expect(config).toBeDefined();\n    expect(config.mode).toEqual(&#x27;none&#x27;);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;488adaa2-db35-4175-be80-4f67ae20f8c7&quot;,&quot;parentUUID&quot;:&quot;a71b4b5b-1565-453d-a9f8-91cb07199a0d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;eslint-config &gt; should be return jest config&quot;,&quot;title&quot;:&quot;eslint-config &gt; should be return jest config&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { eslintConfig } from &#x27;../index&#x27;;\ndescribe(&#x27;eslint-config&#x27;, () =&gt; {\n  it(&#x27;should be return jest config&#x27;, () =&gt; {\n    const config = eslintConfig();\n    expect(config).not.toBe(null);\n    expect(typeof config).toBe(&#x27;object&#x27;);\n    expect(config).toBeDefined();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c7725958-ebf2-4e8d-af30-4585f3e66309&quot;,&quot;parentUUID&quot;:&quot;a71b4b5b-1565-453d-a9f8-91cb07199a0d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;testing-library &gt; should be return jest config&quot;,&quot;title&quot;:&quot;testing-library &gt; should be return jest config&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { jestConfig } from &#x27;../index&#x27;;\n\ndescribe(&#x27;testing-library&#x27;, () =&gt; {\n  it(&#x27;should be return jest config&#x27;, () =&gt; {\n    const config = jestConfig();\n    expect(config).not.toBe(null);\n    expect(typeof config).toBe(&#x27;object&#x27;);\n    expect(config).toBeDefined();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7d5535c9-fb04-4354-b94f-4283bb79995b&quot;,&quot;parentUUID&quot;:&quot;a71b4b5b-1565-453d-a9f8-91cb07199a0d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;e14d11a8-5bbb-4fe7-a59c-da007da535c0&quot;,&quot;488adaa2-db35-4175-be80-4f67ae20f8c7&quot;,&quot;c7725958-ebf2-4e8d-af30-4585f3e66309&quot;,&quot;7d5535c9-fb04-4354-b94f-4283bb79995b&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:9,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:5000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:5000},{&quot;uuid&quot;:&quot;1414fb54-1e49-41e0-9f74-41d379efb0e8&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/core&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;be6c7edf-8827-41c7-a695-f63ec9bad729&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/core&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;fullTitle&quot;:&quot;commons &gt; with env context &gt; should be return commons exclude paths with context&quot;,&quot;title&quot;:&quot;commons &gt; with env context &gt; should be return commons exclude paths with context&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { corePathsExcludes, excludePaths } from &#x27;../index&#x27;;\nimport { RequestMethod } from &#x27;@nestjs/common&#x27;;\n\ndescribe(&#x27;commons&#x27;, () =&gt; {\n  describe(&#x27;with env context&#x27;, () =&gt; {\n    beforeEach(() =&gt; {\n      process.env.CONTEXT = &#x27;v1/api-test&#x27;;\n    });\n\n    it(&#x27;should be return commons exclude paths with context&#x27;, () =&gt; {\n      expect(corePathsExcludes()).not.toBe(null);\n      expect(corePathsExcludes()).toBeDefined();\n      expect(corePathsExcludes()).toBeInstanceOf(Array);\n\n      expect(corePathsExcludes()).toContainObject({\n        path: `/v1/api-test/health/liveness`,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: `/v1/api-test/health/readiness`,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: `/v1/api-test/info`,\n        method: RequestMethod.GET,\n      });\n    });\n\n    it(&#x27;should be return array of exclude paths with context&#x27;, () =&gt; {\n      expect(excludePaths()).not.toBe(null);\n      expect(excludePaths()).toBeDefined();\n      expect(excludePaths()).toBeInstanceOf(Array);\n      expect(excludePaths()).toEqual([\n        `/v1/api-test/health/liveness`,\n        `/v1/api-test/health/readiness`,\n        `/v1/api-test/info`,\n      ]);\n    });\n  });\n\n  describe(&#x27;without env context&#x27;, () =&gt; {\n    beforeEach(() =&gt; {\n      process.env.CONTEXT = &#x27;&#x27;;\n    });\n\n    it(&#x27;should be return commons exclude paths without context&#x27;, () =&gt; {\n      expect(corePathsExcludes()).not.toBe(null);\n      expect(corePathsExcludes()).toBeDefined();\n      expect(corePathsExcludes()).toBeInstanceOf(Array);\n\n      expect(corePathsExcludes()).toContainObject({\n        path: &#x27;/health/liveness&#x27;,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: &#x27;/health/readiness&#x27;,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: &#x27;/info&#x27;,\n        method: RequestMethod.GET,\n      });\n    });\n\n    it(&#x27;should be return array of exclude paths without context&#x27;, () =&gt; {\n      expect(excludePaths()).not.toBe(null);\n      expect(excludePaths()).toBeDefined();\n      expect(excludePaths()).toBeInstanceOf(Array);\n      expect(excludePaths()).toEqual([&#x27;/health/liveness&#x27;, &#x27;/health/readiness&#x27;, &#x27;/info&#x27;]);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7895e288-5853-47fb-bd1f-f532c7c2eb5c&quot;,&quot;parentUUID&quot;:&quot;be6c7edf-8827-41c7-a695-f63ec9bad729&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;commons &gt; with env context &gt; should be return array of exclude paths with context&quot;,&quot;title&quot;:&quot;commons &gt; with env context &gt; should be return array of exclude paths with context&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { corePathsExcludes, excludePaths } from &#x27;../index&#x27;;\nimport { RequestMethod } from &#x27;@nestjs/common&#x27;;\n\ndescribe(&#x27;commons&#x27;, () =&gt; {\n  describe(&#x27;with env context&#x27;, () =&gt; {\n    beforeEach(() =&gt; {\n      process.env.CONTEXT = &#x27;v1/api-test&#x27;;\n    });\n\n    it(&#x27;should be return commons exclude paths with context&#x27;, () =&gt; {\n      expect(corePathsExcludes()).not.toBe(null);\n      expect(corePathsExcludes()).toBeDefined();\n      expect(corePathsExcludes()).toBeInstanceOf(Array);\n\n      expect(corePathsExcludes()).toContainObject({\n        path: `/v1/api-test/health/liveness`,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: `/v1/api-test/health/readiness`,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: `/v1/api-test/info`,\n        method: RequestMethod.GET,\n      });\n    });\n\n    it(&#x27;should be return array of exclude paths with context&#x27;, () =&gt; {\n      expect(excludePaths()).not.toBe(null);\n      expect(excludePaths()).toBeDefined();\n      expect(excludePaths()).toBeInstanceOf(Array);\n      expect(excludePaths()).toEqual([\n        `/v1/api-test/health/liveness`,\n        `/v1/api-test/health/readiness`,\n        `/v1/api-test/info`,\n      ]);\n    });\n  });\n\n  describe(&#x27;without env context&#x27;, () =&gt; {\n    beforeEach(() =&gt; {\n      process.env.CONTEXT = &#x27;&#x27;;\n    });\n\n    it(&#x27;should be return commons exclude paths without context&#x27;, () =&gt; {\n      expect(corePathsExcludes()).not.toBe(null);\n      expect(corePathsExcludes()).toBeDefined();\n      expect(corePathsExcludes()).toBeInstanceOf(Array);\n\n      expect(corePathsExcludes()).toContainObject({\n        path: &#x27;/health/liveness&#x27;,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: &#x27;/health/readiness&#x27;,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: &#x27;/info&#x27;,\n        method: RequestMethod.GET,\n      });\n    });\n\n    it(&#x27;should be return array of exclude paths without context&#x27;, () =&gt; {\n      expect(excludePaths()).not.toBe(null);\n      expect(excludePaths()).toBeDefined();\n      expect(excludePaths()).toBeInstanceOf(Array);\n      expect(excludePaths()).toEqual([&#x27;/health/liveness&#x27;, &#x27;/health/readiness&#x27;, &#x27;/info&#x27;]);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;52e8bc23-55a6-4117-b9b4-66776d2ec3ab&quot;,&quot;parentUUID&quot;:&quot;be6c7edf-8827-41c7-a695-f63ec9bad729&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;commons &gt; without env context &gt; should be return commons exclude paths without context&quot;,&quot;title&quot;:&quot;commons &gt; without env context &gt; should be return commons exclude paths without context&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { corePathsExcludes, excludePaths } from &#x27;../index&#x27;;\nimport { RequestMethod } from &#x27;@nestjs/common&#x27;;\n\ndescribe(&#x27;commons&#x27;, () =&gt; {\n  describe(&#x27;with env context&#x27;, () =&gt; {\n    beforeEach(() =&gt; {\n      process.env.CONTEXT = &#x27;v1/api-test&#x27;;\n    });\n\n    it(&#x27;should be return commons exclude paths with context&#x27;, () =&gt; {\n      expect(corePathsExcludes()).not.toBe(null);\n      expect(corePathsExcludes()).toBeDefined();\n      expect(corePathsExcludes()).toBeInstanceOf(Array);\n\n      expect(corePathsExcludes()).toContainObject({\n        path: `/v1/api-test/health/liveness`,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: `/v1/api-test/health/readiness`,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: `/v1/api-test/info`,\n        method: RequestMethod.GET,\n      });\n    });\n\n    it(&#x27;should be return array of exclude paths with context&#x27;, () =&gt; {\n      expect(excludePaths()).not.toBe(null);\n      expect(excludePaths()).toBeDefined();\n      expect(excludePaths()).toBeInstanceOf(Array);\n      expect(excludePaths()).toEqual([\n        `/v1/api-test/health/liveness`,\n        `/v1/api-test/health/readiness`,\n        `/v1/api-test/info`,\n      ]);\n    });\n  });\n\n  describe(&#x27;without env context&#x27;, () =&gt; {\n    beforeEach(() =&gt; {\n      process.env.CONTEXT = &#x27;&#x27;;\n    });\n\n    it(&#x27;should be return commons exclude paths without context&#x27;, () =&gt; {\n      expect(corePathsExcludes()).not.toBe(null);\n      expect(corePathsExcludes()).toBeDefined();\n      expect(corePathsExcludes()).toBeInstanceOf(Array);\n\n      expect(corePathsExcludes()).toContainObject({\n        path: &#x27;/health/liveness&#x27;,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: &#x27;/health/readiness&#x27;,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: &#x27;/info&#x27;,\n        method: RequestMethod.GET,\n      });\n    });\n\n    it(&#x27;should be return array of exclude paths without context&#x27;, () =&gt; {\n      expect(excludePaths()).not.toBe(null);\n      expect(excludePaths()).toBeDefined();\n      expect(excludePaths()).toBeInstanceOf(Array);\n      expect(excludePaths()).toEqual([&#x27;/health/liveness&#x27;, &#x27;/health/readiness&#x27;, &#x27;/info&#x27;]);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;218aae05-9516-482d-aace-685fce265f9b&quot;,&quot;parentUUID&quot;:&quot;be6c7edf-8827-41c7-a695-f63ec9bad729&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;commons &gt; without env context &gt; should be return array of exclude paths without context&quot;,&quot;title&quot;:&quot;commons &gt; without env context &gt; should be return array of exclude paths without context&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { corePathsExcludes, excludePaths } from &#x27;../index&#x27;;\nimport { RequestMethod } from &#x27;@nestjs/common&#x27;;\n\ndescribe(&#x27;commons&#x27;, () =&gt; {\n  describe(&#x27;with env context&#x27;, () =&gt; {\n    beforeEach(() =&gt; {\n      process.env.CONTEXT = &#x27;v1/api-test&#x27;;\n    });\n\n    it(&#x27;should be return commons exclude paths with context&#x27;, () =&gt; {\n      expect(corePathsExcludes()).not.toBe(null);\n      expect(corePathsExcludes()).toBeDefined();\n      expect(corePathsExcludes()).toBeInstanceOf(Array);\n\n      expect(corePathsExcludes()).toContainObject({\n        path: `/v1/api-test/health/liveness`,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: `/v1/api-test/health/readiness`,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: `/v1/api-test/info`,\n        method: RequestMethod.GET,\n      });\n    });\n\n    it(&#x27;should be return array of exclude paths with context&#x27;, () =&gt; {\n      expect(excludePaths()).not.toBe(null);\n      expect(excludePaths()).toBeDefined();\n      expect(excludePaths()).toBeInstanceOf(Array);\n      expect(excludePaths()).toEqual([\n        `/v1/api-test/health/liveness`,\n        `/v1/api-test/health/readiness`,\n        `/v1/api-test/info`,\n      ]);\n    });\n  });\n\n  describe(&#x27;without env context&#x27;, () =&gt; {\n    beforeEach(() =&gt; {\n      process.env.CONTEXT = &#x27;&#x27;;\n    });\n\n    it(&#x27;should be return commons exclude paths without context&#x27;, () =&gt; {\n      expect(corePathsExcludes()).not.toBe(null);\n      expect(corePathsExcludes()).toBeDefined();\n      expect(corePathsExcludes()).toBeInstanceOf(Array);\n\n      expect(corePathsExcludes()).toContainObject({\n        path: &#x27;/health/liveness&#x27;,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: &#x27;/health/readiness&#x27;,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: &#x27;/info&#x27;,\n        method: RequestMethod.GET,\n      });\n    });\n\n    it(&#x27;should be return array of exclude paths without context&#x27;, () =&gt; {\n      expect(excludePaths()).not.toBe(null);\n      expect(excludePaths()).toBeDefined();\n      expect(excludePaths()).toBeInstanceOf(Array);\n      expect(excludePaths()).toEqual([&#x27;/health/liveness&#x27;, &#x27;/health/readiness&#x27;, &#x27;/info&#x27;]);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;81235d0e-2066-401c-affa-1e30090bc97d&quot;,&quot;parentUUID&quot;:&quot;be6c7edf-8827-41c7-a695-f63ec9bad729&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Public decorator &gt; should be defined&quot;,&quot;title&quot;:&quot;Public decorator &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Public, IS_PUBLIC_KEY } from &#x27;../index&#x27;;\n\ndescribe(&#x27;Public decorator&#x27;, () =&gt; {\n  it(&#x27;should be defined&#x27;, async () =&gt; {\n    expect(Public()).toBeDefined();\n  });\n\n  it(&#x27;should be return key&#x27;, async () =&gt; {\n    expect(IS_PUBLIC_KEY).toBe(&#x27;isPublic&#x27;);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ae538a3b-4926-414a-824f-3647d493e6bf&quot;,&quot;parentUUID&quot;:&quot;be6c7edf-8827-41c7-a695-f63ec9bad729&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Public decorator &gt; should be return key&quot;,&quot;title&quot;:&quot;Public decorator &gt; should be return key&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:0,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Public, IS_PUBLIC_KEY } from &#x27;../index&#x27;;\n\ndescribe(&#x27;Public decorator&#x27;, () =&gt; {\n  it(&#x27;should be defined&#x27;, async () =&gt; {\n    expect(Public()).toBeDefined();\n  });\n\n  it(&#x27;should be return key&#x27;, async () =&gt; {\n    expect(IS_PUBLIC_KEY).toBe(&#x27;isPublic&#x27;);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b460a211-6c25-493c-9d53-823eea547d46&quot;,&quot;parentUUID&quot;:&quot;be6c7edf-8827-41c7-a695-f63ec9bad729&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;https-certificate &gt; should be return https certificate config&quot;,&quot;title&quot;:&quot;https-certificate &gt; should be return https certificate config&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { setHttpsOptions } from &#x27;../index&#x27;;\nimport * as path from &#x27;path&#x27;;\ndescribe(&#x27;https-certificate&#x27;, () =&gt; {\n  it(&#x27;should be return https certificate config&#x27;, () =&gt; {\n    const crtPath = path.resolve(__dirname, &#x27;./utils/localhost.crt&#x27;);\n    const keyPath = path.resolve(__dirname, &#x27;./utils/localhost.key&#x27;);\n\n    const config = setHttpsOptions(crtPath, keyPath);\n    expect(typeof config).toBe(&#x27;object&#x27;);\n    expect(config).toBeDefined();\n    expect(config.cert).not.toEqual(&#x27;&#x27;);\n    expect(config.key).not.toEqual(&#x27;&#x27;);\n  });\n\n  it(&#x27;should be return https certificate config empty&#x27;, () =&gt; {\n    const crtPath = path.resolve(__dirname, &#x27;./utils/my-localhost.crt&#x27;);\n    const keyPath = path.resolve(__dirname, &#x27;./utils/my-localhost.key&#x27;);\n\n    const config = setHttpsOptions(crtPath, keyPath);\n    expect(typeof config).toBe(&#x27;object&#x27;);\n    expect(config).toBeDefined();\n    expect(config.cert).toEqual(&#x27;&#x27;);\n    expect(config.key).toEqual(&#x27;&#x27;);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4889ea4a-c493-4e70-908e-089eb87b7a74&quot;,&quot;parentUUID&quot;:&quot;be6c7edf-8827-41c7-a695-f63ec9bad729&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;https-certificate &gt; should be return https certificate config empty&quot;,&quot;title&quot;:&quot;https-certificate &gt; should be return https certificate config empty&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { setHttpsOptions } from &#x27;../index&#x27;;\nimport * as path from &#x27;path&#x27;;\ndescribe(&#x27;https-certificate&#x27;, () =&gt; {\n  it(&#x27;should be return https certificate config&#x27;, () =&gt; {\n    const crtPath = path.resolve(__dirname, &#x27;./utils/localhost.crt&#x27;);\n    const keyPath = path.resolve(__dirname, &#x27;./utils/localhost.key&#x27;);\n\n    const config = setHttpsOptions(crtPath, keyPath);\n    expect(typeof config).toBe(&#x27;object&#x27;);\n    expect(config).toBeDefined();\n    expect(config.cert).not.toEqual(&#x27;&#x27;);\n    expect(config.key).not.toEqual(&#x27;&#x27;);\n  });\n\n  it(&#x27;should be return https certificate config empty&#x27;, () =&gt; {\n    const crtPath = path.resolve(__dirname, &#x27;./utils/my-localhost.crt&#x27;);\n    const keyPath = path.resolve(__dirname, &#x27;./utils/my-localhost.key&#x27;);\n\n    const config = setHttpsOptions(crtPath, keyPath);\n    expect(typeof config).toBe(&#x27;object&#x27;);\n    expect(config).toBeDefined();\n    expect(config.cert).toEqual(&#x27;&#x27;);\n    expect(config.key).toEqual(&#x27;&#x27;);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6bda48c5-5d44-4e37-90da-c30fd162ec48&quot;,&quot;parentUUID&quot;:&quot;be6c7edf-8827-41c7-a695-f63ec9bad729&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Public decorator &gt; should be defined&quot;,&quot;title&quot;:&quot;Public decorator &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Roles, ROLES_KEY } from &#x27;../index&#x27;;\n\ndescribe(&#x27;Public decorator&#x27;, () =&gt; {\n  it(&#x27;should be defined&#x27;, async () =&gt; {\n    expect(Roles(&#x27;admin&#x27;)).toBeDefined();\n    expect(Roles(&#x27;admin&#x27;, &#x27;user&#x27;)).toBeDefined();\n  });\n\n  it(&#x27;should be return key&#x27;, async () =&gt; {\n    expect(ROLES_KEY).toBe(&#x27;roles&#x27;);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;bc14e93f-d450-467a-b56f-b22e8b453de9&quot;,&quot;parentUUID&quot;:&quot;be6c7edf-8827-41c7-a695-f63ec9bad729&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Public decorator &gt; should be return key&quot;,&quot;title&quot;:&quot;Public decorator &gt; should be return key&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:0,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Roles, ROLES_KEY } from &#x27;../index&#x27;;\n\ndescribe(&#x27;Public decorator&#x27;, () =&gt; {\n  it(&#x27;should be defined&#x27;, async () =&gt; {\n    expect(Roles(&#x27;admin&#x27;)).toBeDefined();\n    expect(Roles(&#x27;admin&#x27;, &#x27;user&#x27;)).toBeDefined();\n  });\n\n  it(&#x27;should be return key&#x27;, async () =&gt; {\n    expect(ROLES_KEY).toBe(&#x27;roles&#x27;);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;63ac17a2-3369-40dd-82d6-0acdb0a25821&quot;,&quot;parentUUID&quot;:&quot;be6c7edf-8827-41c7-a695-f63ec9bad729&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;7895e288-5853-47fb-bd1f-f532c7c2eb5c&quot;,&quot;52e8bc23-55a6-4117-b9b4-66776d2ec3ab&quot;,&quot;218aae05-9516-482d-aace-685fce265f9b&quot;,&quot;81235d0e-2066-401c-affa-1e30090bc97d&quot;,&quot;ae538a3b-4926-414a-824f-3647d493e6bf&quot;,&quot;b460a211-6c25-493c-9d53-823eea547d46&quot;,&quot;4889ea4a-c493-4e70-908e-089eb87b7a74&quot;,&quot;6bda48c5-5d44-4e37-90da-c30fd162ec48&quot;,&quot;bc14e93f-d450-467a-b56f-b22e8b453de9&quot;,&quot;63ac17a2-3369-40dd-82d6-0acdb0a25821&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:13,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:5000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:5000},{&quot;uuid&quot;:&quot;a0bb1a68-fdb1-4d9c-bbc5-bfd23389ff7f&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/elk&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;0f6532ad-4f13-49f8-9445-e7f262aa0f9c&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/elk&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;fullTitle&quot;:&quot;ElkModule &gt; should be defined&quot;,&quot;title&quot;:&quot;ElkModule &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1287,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { HttpException, INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport {\n  dynamicConfig,\n  fixtureUserResponse,\n  TCElasticSearchOptions,\n  tcName,\n  testContainers,\n} from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { Observable, of, throwError } from &#x27;rxjs&#x27;;\nimport { HttpConnection } from &#x27;@elastic/elasticsearch&#x27;;\nimport { URL } from &#x27;url&#x27;;\n\nimport { ElkModule } from &#x27;../elk/elk.module&#x27;;\nimport { ElkInterceptor } from &#x27;../elk/interceptors/elk.interceptor&#x27;;\nimport { ElkService } from &#x27;../elk/services/elk.service&#x27;;\n\nlet executionContext: any = {\n  switchToHttp: jest.fn(() =&gt; ({\n    getRequest: () =&gt; ({\n      path: &#x27;/test&#x27;,\n      method: &#x27;GET&#x27;,\n      params: {},\n      query: {},\n      body: {},\n      headers: {\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        apiKey: &#x27;abcdefg12345&#x27;,\n      },\n    }),\n    getResponse: () =&gt; ({\n      getHeaders: jest.fn().mockReturnValue({\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        my_header: &#x27;test-header&#x27;,\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() =&gt; &#x27;http&#x27;),\n  getClass: jest.fn(() =&gt; &#x27;testController&#x27;),\n  getHandler: jest.fn(() =&gt; &#x27;handlerElk&#x27;),\n};\n\nlet executionContextParams: any = {\n  switchToHttp: jest.fn(() =&gt; ({\n    getRequest: () =&gt; ({\n      path: &#x27;/test&#x27;,\n      method: &#x27;GET&#x27;,\n      params: { name: &#x27;juan&#x27; },\n      query: { name: &#x27;juan&#x27; },\n      body: { name: &#x27;juan&#x27; },\n      headers: {\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        apiKey: &#x27;abcdefg12345&#x27;,\n      },\n    }),\n    getResponse: () =&gt; ({\n      getHeaders: jest.fn().mockReturnValue({\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        my_header: &#x27;test-header&#x27;,\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() =&gt; &#x27;http&#x27;),\n  getClass: jest.fn(() =&gt; &#x27;testController&#x27;),\n  getHandler: jest.fn(() =&gt; &#x27;handlerElk&#x27;),\n};\n\n/*const callHandler: any = {\n  handle: jest.fn(() =&gt; ({\n    pipe: jest.fn(() =&gt; ({\n      tap: jest.fn(() =&gt; ({\n        next: jest.fn(),\n        error: jest.fn(),\n      })),\n    })),\n  })),\n};*/\n\njest.setTimeout(70000);\ndescribe(&#x27;ElkModule&#x27;, () =&gt; {\n  let app: INestApplication;\n  let elkService: ElkService;\n  let interceptor: ElkInterceptor&lt;any&gt;;\n  let container: testContainers;\n\n  beforeAll(async () =&gt; {\n    //&#x27;elasticsearch:8.3.3&#x27;\n    //docker.elastic.co/elasticsearch/elasticsearch:8.3.3\n\n    container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n      ...TCElasticSearchOptions,\n      containerName: `${tcName}-elasticsearch-interceptor`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              elasticsearch: {\n                name: &#x27;test-elk-index&#x27;,\n                node: {\n                  url: new URL(`http://${container.getHost()}:9200`),\n                },\n                maxRetries: 10,\n                requestTimeout: 60000,\n                sniffOnStart: true,\n                Connection: HttpConnection,\n              },\n            }),\n          ],\n        }),\n        ElkModule,\n      ],\n    }).compile();\n    app = moduleFixture.createNestApplication();\n    interceptor = new ElkInterceptor(app.get&lt;ElkService&gt;(ElkService));\n    app.useGlobalInterceptors(interceptor);\n    elkService = moduleFixture.get&lt;ElkService&gt;(ElkService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(app).toBeDefined();\n  });\n\n  describe(&#x27;ElkInterceptor&#x27;, () =&gt; {\n    it(&#x27;should be an ElkInterceptor instance to be defined&#x27;, async () =&gt; {\n      expect(new ElkInterceptor(elkService)).toBeDefined();\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success string&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of(&#x27;this is a test&#x27;)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success object&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of([fixtureUserResponse])),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success with parameters&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of([fixtureUserResponse])),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContextParams, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return exception&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const error = new Error(`User #$1 not found`);\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; throwError(error)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () =&gt; {},\n        error: (error) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return exception http&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const error = new HttpException(&#x27;not found&#x27;, 404);\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; throwError(error)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () =&gt; {},\n        error: (error) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n  });\n\n  describe(&#x27;ElkModule - Register&#x27;, () =&gt; {\n    let app: INestApplication;\n    let elkService: ElkService;\n    let interceptor: ElkInterceptor&lt;any&gt;;\n\n    beforeEach(async () =&gt; {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ElkModule.register({\n            name: &#x27;test-elk-index&#x27;,\n            node: {\n              url: new URL(`http://${container.getHost()}:9200`),\n            },\n            maxRetries: 10,\n            requestTimeout: 60000,\n            sniffOnStart: true,\n            Connection: HttpConnection,\n          }),\n        ],\n      }).compile();\n      app = moduleFixture.createNestApplication();\n      interceptor = new ElkInterceptor(app.get&lt;ElkService&gt;(ElkService));\n      app.useGlobalInterceptors(interceptor);\n      elkService = moduleFixture.get&lt;ElkService&gt;(ElkService);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3a57bd6d-82a0-4047-b5d2-aa2b38dbe358&quot;,&quot;parentUUID&quot;:&quot;0f6532ad-4f13-49f8-9445-e7f262aa0f9c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;ElkModule &gt; ElkInterceptor &gt; should be an ElkInterceptor instance to be defined&quot;,&quot;title&quot;:&quot;ElkModule &gt; ElkInterceptor &gt; should be an ElkInterceptor instance to be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1011,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { HttpException, INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport {\n  dynamicConfig,\n  fixtureUserResponse,\n  TCElasticSearchOptions,\n  tcName,\n  testContainers,\n} from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { Observable, of, throwError } from &#x27;rxjs&#x27;;\nimport { HttpConnection } from &#x27;@elastic/elasticsearch&#x27;;\nimport { URL } from &#x27;url&#x27;;\n\nimport { ElkModule } from &#x27;../elk/elk.module&#x27;;\nimport { ElkInterceptor } from &#x27;../elk/interceptors/elk.interceptor&#x27;;\nimport { ElkService } from &#x27;../elk/services/elk.service&#x27;;\n\nlet executionContext: any = {\n  switchToHttp: jest.fn(() =&gt; ({\n    getRequest: () =&gt; ({\n      path: &#x27;/test&#x27;,\n      method: &#x27;GET&#x27;,\n      params: {},\n      query: {},\n      body: {},\n      headers: {\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        apiKey: &#x27;abcdefg12345&#x27;,\n      },\n    }),\n    getResponse: () =&gt; ({\n      getHeaders: jest.fn().mockReturnValue({\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        my_header: &#x27;test-header&#x27;,\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() =&gt; &#x27;http&#x27;),\n  getClass: jest.fn(() =&gt; &#x27;testController&#x27;),\n  getHandler: jest.fn(() =&gt; &#x27;handlerElk&#x27;),\n};\n\nlet executionContextParams: any = {\n  switchToHttp: jest.fn(() =&gt; ({\n    getRequest: () =&gt; ({\n      path: &#x27;/test&#x27;,\n      method: &#x27;GET&#x27;,\n      params: { name: &#x27;juan&#x27; },\n      query: { name: &#x27;juan&#x27; },\n      body: { name: &#x27;juan&#x27; },\n      headers: {\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        apiKey: &#x27;abcdefg12345&#x27;,\n      },\n    }),\n    getResponse: () =&gt; ({\n      getHeaders: jest.fn().mockReturnValue({\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        my_header: &#x27;test-header&#x27;,\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() =&gt; &#x27;http&#x27;),\n  getClass: jest.fn(() =&gt; &#x27;testController&#x27;),\n  getHandler: jest.fn(() =&gt; &#x27;handlerElk&#x27;),\n};\n\n/*const callHandler: any = {\n  handle: jest.fn(() =&gt; ({\n    pipe: jest.fn(() =&gt; ({\n      tap: jest.fn(() =&gt; ({\n        next: jest.fn(),\n        error: jest.fn(),\n      })),\n    })),\n  })),\n};*/\n\njest.setTimeout(70000);\ndescribe(&#x27;ElkModule&#x27;, () =&gt; {\n  let app: INestApplication;\n  let elkService: ElkService;\n  let interceptor: ElkInterceptor&lt;any&gt;;\n  let container: testContainers;\n\n  beforeAll(async () =&gt; {\n    //&#x27;elasticsearch:8.3.3&#x27;\n    //docker.elastic.co/elasticsearch/elasticsearch:8.3.3\n\n    container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n      ...TCElasticSearchOptions,\n      containerName: `${tcName}-elasticsearch-interceptor`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              elasticsearch: {\n                name: &#x27;test-elk-index&#x27;,\n                node: {\n                  url: new URL(`http://${container.getHost()}:9200`),\n                },\n                maxRetries: 10,\n                requestTimeout: 60000,\n                sniffOnStart: true,\n                Connection: HttpConnection,\n              },\n            }),\n          ],\n        }),\n        ElkModule,\n      ],\n    }).compile();\n    app = moduleFixture.createNestApplication();\n    interceptor = new ElkInterceptor(app.get&lt;ElkService&gt;(ElkService));\n    app.useGlobalInterceptors(interceptor);\n    elkService = moduleFixture.get&lt;ElkService&gt;(ElkService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(app).toBeDefined();\n  });\n\n  describe(&#x27;ElkInterceptor&#x27;, () =&gt; {\n    it(&#x27;should be an ElkInterceptor instance to be defined&#x27;, async () =&gt; {\n      expect(new ElkInterceptor(elkService)).toBeDefined();\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success string&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of(&#x27;this is a test&#x27;)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success object&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of([fixtureUserResponse])),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success with parameters&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of([fixtureUserResponse])),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContextParams, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return exception&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const error = new Error(`User #$1 not found`);\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; throwError(error)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () =&gt; {},\n        error: (error) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return exception http&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const error = new HttpException(&#x27;not found&#x27;, 404);\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; throwError(error)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () =&gt; {},\n        error: (error) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n  });\n\n  describe(&#x27;ElkModule - Register&#x27;, () =&gt; {\n    let app: INestApplication;\n    let elkService: ElkService;\n    let interceptor: ElkInterceptor&lt;any&gt;;\n\n    beforeEach(async () =&gt; {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ElkModule.register({\n            name: &#x27;test-elk-index&#x27;,\n            node: {\n              url: new URL(`http://${container.getHost()}:9200`),\n            },\n            maxRetries: 10,\n            requestTimeout: 60000,\n            sniffOnStart: true,\n            Connection: HttpConnection,\n          }),\n        ],\n      }).compile();\n      app = moduleFixture.createNestApplication();\n      interceptor = new ElkInterceptor(app.get&lt;ElkService&gt;(ElkService));\n      app.useGlobalInterceptors(interceptor);\n      elkService = moduleFixture.get&lt;ElkService&gt;(ElkService);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;17ef29b7-1bf9-4228-b5c6-7df761954c65&quot;,&quot;parentUUID&quot;:&quot;0f6532ad-4f13-49f8-9445-e7f262aa0f9c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;ElkModule &gt; ElkInterceptor &gt; should be create document in elasticsearch when return success string&quot;,&quot;title&quot;:&quot;ElkModule &gt; ElkInterceptor &gt; should be create document in elasticsearch when return success string&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1012,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { HttpException, INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport {\n  dynamicConfig,\n  fixtureUserResponse,\n  TCElasticSearchOptions,\n  tcName,\n  testContainers,\n} from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { Observable, of, throwError } from &#x27;rxjs&#x27;;\nimport { HttpConnection } from &#x27;@elastic/elasticsearch&#x27;;\nimport { URL } from &#x27;url&#x27;;\n\nimport { ElkModule } from &#x27;../elk/elk.module&#x27;;\nimport { ElkInterceptor } from &#x27;../elk/interceptors/elk.interceptor&#x27;;\nimport { ElkService } from &#x27;../elk/services/elk.service&#x27;;\n\nlet executionContext: any = {\n  switchToHttp: jest.fn(() =&gt; ({\n    getRequest: () =&gt; ({\n      path: &#x27;/test&#x27;,\n      method: &#x27;GET&#x27;,\n      params: {},\n      query: {},\n      body: {},\n      headers: {\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        apiKey: &#x27;abcdefg12345&#x27;,\n      },\n    }),\n    getResponse: () =&gt; ({\n      getHeaders: jest.fn().mockReturnValue({\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        my_header: &#x27;test-header&#x27;,\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() =&gt; &#x27;http&#x27;),\n  getClass: jest.fn(() =&gt; &#x27;testController&#x27;),\n  getHandler: jest.fn(() =&gt; &#x27;handlerElk&#x27;),\n};\n\nlet executionContextParams: any = {\n  switchToHttp: jest.fn(() =&gt; ({\n    getRequest: () =&gt; ({\n      path: &#x27;/test&#x27;,\n      method: &#x27;GET&#x27;,\n      params: { name: &#x27;juan&#x27; },\n      query: { name: &#x27;juan&#x27; },\n      body: { name: &#x27;juan&#x27; },\n      headers: {\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        apiKey: &#x27;abcdefg12345&#x27;,\n      },\n    }),\n    getResponse: () =&gt; ({\n      getHeaders: jest.fn().mockReturnValue({\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        my_header: &#x27;test-header&#x27;,\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() =&gt; &#x27;http&#x27;),\n  getClass: jest.fn(() =&gt; &#x27;testController&#x27;),\n  getHandler: jest.fn(() =&gt; &#x27;handlerElk&#x27;),\n};\n\n/*const callHandler: any = {\n  handle: jest.fn(() =&gt; ({\n    pipe: jest.fn(() =&gt; ({\n      tap: jest.fn(() =&gt; ({\n        next: jest.fn(),\n        error: jest.fn(),\n      })),\n    })),\n  })),\n};*/\n\njest.setTimeout(70000);\ndescribe(&#x27;ElkModule&#x27;, () =&gt; {\n  let app: INestApplication;\n  let elkService: ElkService;\n  let interceptor: ElkInterceptor&lt;any&gt;;\n  let container: testContainers;\n\n  beforeAll(async () =&gt; {\n    //&#x27;elasticsearch:8.3.3&#x27;\n    //docker.elastic.co/elasticsearch/elasticsearch:8.3.3\n\n    container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n      ...TCElasticSearchOptions,\n      containerName: `${tcName}-elasticsearch-interceptor`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              elasticsearch: {\n                name: &#x27;test-elk-index&#x27;,\n                node: {\n                  url: new URL(`http://${container.getHost()}:9200`),\n                },\n                maxRetries: 10,\n                requestTimeout: 60000,\n                sniffOnStart: true,\n                Connection: HttpConnection,\n              },\n            }),\n          ],\n        }),\n        ElkModule,\n      ],\n    }).compile();\n    app = moduleFixture.createNestApplication();\n    interceptor = new ElkInterceptor(app.get&lt;ElkService&gt;(ElkService));\n    app.useGlobalInterceptors(interceptor);\n    elkService = moduleFixture.get&lt;ElkService&gt;(ElkService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(app).toBeDefined();\n  });\n\n  describe(&#x27;ElkInterceptor&#x27;, () =&gt; {\n    it(&#x27;should be an ElkInterceptor instance to be defined&#x27;, async () =&gt; {\n      expect(new ElkInterceptor(elkService)).toBeDefined();\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success string&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of(&#x27;this is a test&#x27;)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success object&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of([fixtureUserResponse])),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success with parameters&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of([fixtureUserResponse])),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContextParams, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return exception&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const error = new Error(`User #$1 not found`);\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; throwError(error)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () =&gt; {},\n        error: (error) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return exception http&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const error = new HttpException(&#x27;not found&#x27;, 404);\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; throwError(error)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () =&gt; {},\n        error: (error) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n  });\n\n  describe(&#x27;ElkModule - Register&#x27;, () =&gt; {\n    let app: INestApplication;\n    let elkService: ElkService;\n    let interceptor: ElkInterceptor&lt;any&gt;;\n\n    beforeEach(async () =&gt; {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ElkModule.register({\n            name: &#x27;test-elk-index&#x27;,\n            node: {\n              url: new URL(`http://${container.getHost()}:9200`),\n            },\n            maxRetries: 10,\n            requestTimeout: 60000,\n            sniffOnStart: true,\n            Connection: HttpConnection,\n          }),\n        ],\n      }).compile();\n      app = moduleFixture.createNestApplication();\n      interceptor = new ElkInterceptor(app.get&lt;ElkService&gt;(ElkService));\n      app.useGlobalInterceptors(interceptor);\n      elkService = moduleFixture.get&lt;ElkService&gt;(ElkService);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4565f054-dd49-4d71-92ab-2b28c8c890e0&quot;,&quot;parentUUID&quot;:&quot;0f6532ad-4f13-49f8-9445-e7f262aa0f9c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;ElkModule &gt; ElkInterceptor &gt; should be create document in elasticsearch when return success object&quot;,&quot;title&quot;:&quot;ElkModule &gt; ElkInterceptor &gt; should be create document in elasticsearch when return success object&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1010,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { HttpException, INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport {\n  dynamicConfig,\n  fixtureUserResponse,\n  TCElasticSearchOptions,\n  tcName,\n  testContainers,\n} from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { Observable, of, throwError } from &#x27;rxjs&#x27;;\nimport { HttpConnection } from &#x27;@elastic/elasticsearch&#x27;;\nimport { URL } from &#x27;url&#x27;;\n\nimport { ElkModule } from &#x27;../elk/elk.module&#x27;;\nimport { ElkInterceptor } from &#x27;../elk/interceptors/elk.interceptor&#x27;;\nimport { ElkService } from &#x27;../elk/services/elk.service&#x27;;\n\nlet executionContext: any = {\n  switchToHttp: jest.fn(() =&gt; ({\n    getRequest: () =&gt; ({\n      path: &#x27;/test&#x27;,\n      method: &#x27;GET&#x27;,\n      params: {},\n      query: {},\n      body: {},\n      headers: {\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        apiKey: &#x27;abcdefg12345&#x27;,\n      },\n    }),\n    getResponse: () =&gt; ({\n      getHeaders: jest.fn().mockReturnValue({\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        my_header: &#x27;test-header&#x27;,\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() =&gt; &#x27;http&#x27;),\n  getClass: jest.fn(() =&gt; &#x27;testController&#x27;),\n  getHandler: jest.fn(() =&gt; &#x27;handlerElk&#x27;),\n};\n\nlet executionContextParams: any = {\n  switchToHttp: jest.fn(() =&gt; ({\n    getRequest: () =&gt; ({\n      path: &#x27;/test&#x27;,\n      method: &#x27;GET&#x27;,\n      params: { name: &#x27;juan&#x27; },\n      query: { name: &#x27;juan&#x27; },\n      body: { name: &#x27;juan&#x27; },\n      headers: {\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        apiKey: &#x27;abcdefg12345&#x27;,\n      },\n    }),\n    getResponse: () =&gt; ({\n      getHeaders: jest.fn().mockReturnValue({\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        my_header: &#x27;test-header&#x27;,\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() =&gt; &#x27;http&#x27;),\n  getClass: jest.fn(() =&gt; &#x27;testController&#x27;),\n  getHandler: jest.fn(() =&gt; &#x27;handlerElk&#x27;),\n};\n\n/*const callHandler: any = {\n  handle: jest.fn(() =&gt; ({\n    pipe: jest.fn(() =&gt; ({\n      tap: jest.fn(() =&gt; ({\n        next: jest.fn(),\n        error: jest.fn(),\n      })),\n    })),\n  })),\n};*/\n\njest.setTimeout(70000);\ndescribe(&#x27;ElkModule&#x27;, () =&gt; {\n  let app: INestApplication;\n  let elkService: ElkService;\n  let interceptor: ElkInterceptor&lt;any&gt;;\n  let container: testContainers;\n\n  beforeAll(async () =&gt; {\n    //&#x27;elasticsearch:8.3.3&#x27;\n    //docker.elastic.co/elasticsearch/elasticsearch:8.3.3\n\n    container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n      ...TCElasticSearchOptions,\n      containerName: `${tcName}-elasticsearch-interceptor`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              elasticsearch: {\n                name: &#x27;test-elk-index&#x27;,\n                node: {\n                  url: new URL(`http://${container.getHost()}:9200`),\n                },\n                maxRetries: 10,\n                requestTimeout: 60000,\n                sniffOnStart: true,\n                Connection: HttpConnection,\n              },\n            }),\n          ],\n        }),\n        ElkModule,\n      ],\n    }).compile();\n    app = moduleFixture.createNestApplication();\n    interceptor = new ElkInterceptor(app.get&lt;ElkService&gt;(ElkService));\n    app.useGlobalInterceptors(interceptor);\n    elkService = moduleFixture.get&lt;ElkService&gt;(ElkService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(app).toBeDefined();\n  });\n\n  describe(&#x27;ElkInterceptor&#x27;, () =&gt; {\n    it(&#x27;should be an ElkInterceptor instance to be defined&#x27;, async () =&gt; {\n      expect(new ElkInterceptor(elkService)).toBeDefined();\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success string&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of(&#x27;this is a test&#x27;)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success object&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of([fixtureUserResponse])),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success with parameters&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of([fixtureUserResponse])),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContextParams, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return exception&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const error = new Error(`User #$1 not found`);\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; throwError(error)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () =&gt; {},\n        error: (error) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return exception http&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const error = new HttpException(&#x27;not found&#x27;, 404);\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; throwError(error)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () =&gt; {},\n        error: (error) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n  });\n\n  describe(&#x27;ElkModule - Register&#x27;, () =&gt; {\n    let app: INestApplication;\n    let elkService: ElkService;\n    let interceptor: ElkInterceptor&lt;any&gt;;\n\n    beforeEach(async () =&gt; {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ElkModule.register({\n            name: &#x27;test-elk-index&#x27;,\n            node: {\n              url: new URL(`http://${container.getHost()}:9200`),\n            },\n            maxRetries: 10,\n            requestTimeout: 60000,\n            sniffOnStart: true,\n            Connection: HttpConnection,\n          }),\n        ],\n      }).compile();\n      app = moduleFixture.createNestApplication();\n      interceptor = new ElkInterceptor(app.get&lt;ElkService&gt;(ElkService));\n      app.useGlobalInterceptors(interceptor);\n      elkService = moduleFixture.get&lt;ElkService&gt;(ElkService);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;5ee1c8c9-b122-4058-8d13-5025988dd81d&quot;,&quot;parentUUID&quot;:&quot;0f6532ad-4f13-49f8-9445-e7f262aa0f9c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;ElkModule &gt; ElkInterceptor &gt; should be create document in elasticsearch when return success with parameters&quot;,&quot;title&quot;:&quot;ElkModule &gt; ElkInterceptor &gt; should be create document in elasticsearch when return success with parameters&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1014,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { HttpException, INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport {\n  dynamicConfig,\n  fixtureUserResponse,\n  TCElasticSearchOptions,\n  tcName,\n  testContainers,\n} from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { Observable, of, throwError } from &#x27;rxjs&#x27;;\nimport { HttpConnection } from &#x27;@elastic/elasticsearch&#x27;;\nimport { URL } from &#x27;url&#x27;;\n\nimport { ElkModule } from &#x27;../elk/elk.module&#x27;;\nimport { ElkInterceptor } from &#x27;../elk/interceptors/elk.interceptor&#x27;;\nimport { ElkService } from &#x27;../elk/services/elk.service&#x27;;\n\nlet executionContext: any = {\n  switchToHttp: jest.fn(() =&gt; ({\n    getRequest: () =&gt; ({\n      path: &#x27;/test&#x27;,\n      method: &#x27;GET&#x27;,\n      params: {},\n      query: {},\n      body: {},\n      headers: {\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        apiKey: &#x27;abcdefg12345&#x27;,\n      },\n    }),\n    getResponse: () =&gt; ({\n      getHeaders: jest.fn().mockReturnValue({\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        my_header: &#x27;test-header&#x27;,\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() =&gt; &#x27;http&#x27;),\n  getClass: jest.fn(() =&gt; &#x27;testController&#x27;),\n  getHandler: jest.fn(() =&gt; &#x27;handlerElk&#x27;),\n};\n\nlet executionContextParams: any = {\n  switchToHttp: jest.fn(() =&gt; ({\n    getRequest: () =&gt; ({\n      path: &#x27;/test&#x27;,\n      method: &#x27;GET&#x27;,\n      params: { name: &#x27;juan&#x27; },\n      query: { name: &#x27;juan&#x27; },\n      body: { name: &#x27;juan&#x27; },\n      headers: {\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        apiKey: &#x27;abcdefg12345&#x27;,\n      },\n    }),\n    getResponse: () =&gt; ({\n      getHeaders: jest.fn().mockReturnValue({\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        my_header: &#x27;test-header&#x27;,\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() =&gt; &#x27;http&#x27;),\n  getClass: jest.fn(() =&gt; &#x27;testController&#x27;),\n  getHandler: jest.fn(() =&gt; &#x27;handlerElk&#x27;),\n};\n\n/*const callHandler: any = {\n  handle: jest.fn(() =&gt; ({\n    pipe: jest.fn(() =&gt; ({\n      tap: jest.fn(() =&gt; ({\n        next: jest.fn(),\n        error: jest.fn(),\n      })),\n    })),\n  })),\n};*/\n\njest.setTimeout(70000);\ndescribe(&#x27;ElkModule&#x27;, () =&gt; {\n  let app: INestApplication;\n  let elkService: ElkService;\n  let interceptor: ElkInterceptor&lt;any&gt;;\n  let container: testContainers;\n\n  beforeAll(async () =&gt; {\n    //&#x27;elasticsearch:8.3.3&#x27;\n    //docker.elastic.co/elasticsearch/elasticsearch:8.3.3\n\n    container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n      ...TCElasticSearchOptions,\n      containerName: `${tcName}-elasticsearch-interceptor`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              elasticsearch: {\n                name: &#x27;test-elk-index&#x27;,\n                node: {\n                  url: new URL(`http://${container.getHost()}:9200`),\n                },\n                maxRetries: 10,\n                requestTimeout: 60000,\n                sniffOnStart: true,\n                Connection: HttpConnection,\n              },\n            }),\n          ],\n        }),\n        ElkModule,\n      ],\n    }).compile();\n    app = moduleFixture.createNestApplication();\n    interceptor = new ElkInterceptor(app.get&lt;ElkService&gt;(ElkService));\n    app.useGlobalInterceptors(interceptor);\n    elkService = moduleFixture.get&lt;ElkService&gt;(ElkService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(app).toBeDefined();\n  });\n\n  describe(&#x27;ElkInterceptor&#x27;, () =&gt; {\n    it(&#x27;should be an ElkInterceptor instance to be defined&#x27;, async () =&gt; {\n      expect(new ElkInterceptor(elkService)).toBeDefined();\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success string&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of(&#x27;this is a test&#x27;)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success object&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of([fixtureUserResponse])),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success with parameters&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of([fixtureUserResponse])),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContextParams, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return exception&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const error = new Error(`User #$1 not found`);\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; throwError(error)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () =&gt; {},\n        error: (error) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return exception http&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const error = new HttpException(&#x27;not found&#x27;, 404);\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; throwError(error)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () =&gt; {},\n        error: (error) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n  });\n\n  describe(&#x27;ElkModule - Register&#x27;, () =&gt; {\n    let app: INestApplication;\n    let elkService: ElkService;\n    let interceptor: ElkInterceptor&lt;any&gt;;\n\n    beforeEach(async () =&gt; {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ElkModule.register({\n            name: &#x27;test-elk-index&#x27;,\n            node: {\n              url: new URL(`http://${container.getHost()}:9200`),\n            },\n            maxRetries: 10,\n            requestTimeout: 60000,\n            sniffOnStart: true,\n            Connection: HttpConnection,\n          }),\n        ],\n      }).compile();\n      app = moduleFixture.createNestApplication();\n      interceptor = new ElkInterceptor(app.get&lt;ElkService&gt;(ElkService));\n      app.useGlobalInterceptors(interceptor);\n      elkService = moduleFixture.get&lt;ElkService&gt;(ElkService);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3d4a6584-0bbc-4f77-bff7-3fe93540005d&quot;,&quot;parentUUID&quot;:&quot;0f6532ad-4f13-49f8-9445-e7f262aa0f9c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;ElkModule &gt; ElkInterceptor &gt; should be create document in elasticsearch when return exception&quot;,&quot;title&quot;:&quot;ElkModule &gt; ElkInterceptor &gt; should be create document in elasticsearch when return exception&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1009,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { HttpException, INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport {\n  dynamicConfig,\n  fixtureUserResponse,\n  TCElasticSearchOptions,\n  tcName,\n  testContainers,\n} from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { Observable, of, throwError } from &#x27;rxjs&#x27;;\nimport { HttpConnection } from &#x27;@elastic/elasticsearch&#x27;;\nimport { URL } from &#x27;url&#x27;;\n\nimport { ElkModule } from &#x27;../elk/elk.module&#x27;;\nimport { ElkInterceptor } from &#x27;../elk/interceptors/elk.interceptor&#x27;;\nimport { ElkService } from &#x27;../elk/services/elk.service&#x27;;\n\nlet executionContext: any = {\n  switchToHttp: jest.fn(() =&gt; ({\n    getRequest: () =&gt; ({\n      path: &#x27;/test&#x27;,\n      method: &#x27;GET&#x27;,\n      params: {},\n      query: {},\n      body: {},\n      headers: {\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        apiKey: &#x27;abcdefg12345&#x27;,\n      },\n    }),\n    getResponse: () =&gt; ({\n      getHeaders: jest.fn().mockReturnValue({\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        my_header: &#x27;test-header&#x27;,\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() =&gt; &#x27;http&#x27;),\n  getClass: jest.fn(() =&gt; &#x27;testController&#x27;),\n  getHandler: jest.fn(() =&gt; &#x27;handlerElk&#x27;),\n};\n\nlet executionContextParams: any = {\n  switchToHttp: jest.fn(() =&gt; ({\n    getRequest: () =&gt; ({\n      path: &#x27;/test&#x27;,\n      method: &#x27;GET&#x27;,\n      params: { name: &#x27;juan&#x27; },\n      query: { name: &#x27;juan&#x27; },\n      body: { name: &#x27;juan&#x27; },\n      headers: {\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        apiKey: &#x27;abcdefg12345&#x27;,\n      },\n    }),\n    getResponse: () =&gt; ({\n      getHeaders: jest.fn().mockReturnValue({\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        my_header: &#x27;test-header&#x27;,\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() =&gt; &#x27;http&#x27;),\n  getClass: jest.fn(() =&gt; &#x27;testController&#x27;),\n  getHandler: jest.fn(() =&gt; &#x27;handlerElk&#x27;),\n};\n\n/*const callHandler: any = {\n  handle: jest.fn(() =&gt; ({\n    pipe: jest.fn(() =&gt; ({\n      tap: jest.fn(() =&gt; ({\n        next: jest.fn(),\n        error: jest.fn(),\n      })),\n    })),\n  })),\n};*/\n\njest.setTimeout(70000);\ndescribe(&#x27;ElkModule&#x27;, () =&gt; {\n  let app: INestApplication;\n  let elkService: ElkService;\n  let interceptor: ElkInterceptor&lt;any&gt;;\n  let container: testContainers;\n\n  beforeAll(async () =&gt; {\n    //&#x27;elasticsearch:8.3.3&#x27;\n    //docker.elastic.co/elasticsearch/elasticsearch:8.3.3\n\n    container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n      ...TCElasticSearchOptions,\n      containerName: `${tcName}-elasticsearch-interceptor`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              elasticsearch: {\n                name: &#x27;test-elk-index&#x27;,\n                node: {\n                  url: new URL(`http://${container.getHost()}:9200`),\n                },\n                maxRetries: 10,\n                requestTimeout: 60000,\n                sniffOnStart: true,\n                Connection: HttpConnection,\n              },\n            }),\n          ],\n        }),\n        ElkModule,\n      ],\n    }).compile();\n    app = moduleFixture.createNestApplication();\n    interceptor = new ElkInterceptor(app.get&lt;ElkService&gt;(ElkService));\n    app.useGlobalInterceptors(interceptor);\n    elkService = moduleFixture.get&lt;ElkService&gt;(ElkService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(app).toBeDefined();\n  });\n\n  describe(&#x27;ElkInterceptor&#x27;, () =&gt; {\n    it(&#x27;should be an ElkInterceptor instance to be defined&#x27;, async () =&gt; {\n      expect(new ElkInterceptor(elkService)).toBeDefined();\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success string&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of(&#x27;this is a test&#x27;)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success object&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of([fixtureUserResponse])),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success with parameters&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of([fixtureUserResponse])),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContextParams, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return exception&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const error = new Error(`User #$1 not found`);\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; throwError(error)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () =&gt; {},\n        error: (error) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return exception http&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const error = new HttpException(&#x27;not found&#x27;, 404);\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; throwError(error)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () =&gt; {},\n        error: (error) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n  });\n\n  describe(&#x27;ElkModule - Register&#x27;, () =&gt; {\n    let app: INestApplication;\n    let elkService: ElkService;\n    let interceptor: ElkInterceptor&lt;any&gt;;\n\n    beforeEach(async () =&gt; {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ElkModule.register({\n            name: &#x27;test-elk-index&#x27;,\n            node: {\n              url: new URL(`http://${container.getHost()}:9200`),\n            },\n            maxRetries: 10,\n            requestTimeout: 60000,\n            sniffOnStart: true,\n            Connection: HttpConnection,\n          }),\n        ],\n      }).compile();\n      app = moduleFixture.createNestApplication();\n      interceptor = new ElkInterceptor(app.get&lt;ElkService&gt;(ElkService));\n      app.useGlobalInterceptors(interceptor);\n      elkService = moduleFixture.get&lt;ElkService&gt;(ElkService);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b2b83334-5afc-4bdc-a581-1a9d7d612784&quot;,&quot;parentUUID&quot;:&quot;0f6532ad-4f13-49f8-9445-e7f262aa0f9c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;ElkModule &gt; ElkInterceptor &gt; should be create document in elasticsearch when return exception http&quot;,&quot;title&quot;:&quot;ElkModule &gt; ElkInterceptor &gt; should be create document in elasticsearch when return exception http&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1009,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { HttpException, INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport {\n  dynamicConfig,\n  fixtureUserResponse,\n  TCElasticSearchOptions,\n  tcName,\n  testContainers,\n} from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { Observable, of, throwError } from &#x27;rxjs&#x27;;\nimport { HttpConnection } from &#x27;@elastic/elasticsearch&#x27;;\nimport { URL } from &#x27;url&#x27;;\n\nimport { ElkModule } from &#x27;../elk/elk.module&#x27;;\nimport { ElkInterceptor } from &#x27;../elk/interceptors/elk.interceptor&#x27;;\nimport { ElkService } from &#x27;../elk/services/elk.service&#x27;;\n\nlet executionContext: any = {\n  switchToHttp: jest.fn(() =&gt; ({\n    getRequest: () =&gt; ({\n      path: &#x27;/test&#x27;,\n      method: &#x27;GET&#x27;,\n      params: {},\n      query: {},\n      body: {},\n      headers: {\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        apiKey: &#x27;abcdefg12345&#x27;,\n      },\n    }),\n    getResponse: () =&gt; ({\n      getHeaders: jest.fn().mockReturnValue({\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        my_header: &#x27;test-header&#x27;,\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() =&gt; &#x27;http&#x27;),\n  getClass: jest.fn(() =&gt; &#x27;testController&#x27;),\n  getHandler: jest.fn(() =&gt; &#x27;handlerElk&#x27;),\n};\n\nlet executionContextParams: any = {\n  switchToHttp: jest.fn(() =&gt; ({\n    getRequest: () =&gt; ({\n      path: &#x27;/test&#x27;,\n      method: &#x27;GET&#x27;,\n      params: { name: &#x27;juan&#x27; },\n      query: { name: &#x27;juan&#x27; },\n      body: { name: &#x27;juan&#x27; },\n      headers: {\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        apiKey: &#x27;abcdefg12345&#x27;,\n      },\n    }),\n    getResponse: () =&gt; ({\n      getHeaders: jest.fn().mockReturnValue({\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        my_header: &#x27;test-header&#x27;,\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() =&gt; &#x27;http&#x27;),\n  getClass: jest.fn(() =&gt; &#x27;testController&#x27;),\n  getHandler: jest.fn(() =&gt; &#x27;handlerElk&#x27;),\n};\n\n/*const callHandler: any = {\n  handle: jest.fn(() =&gt; ({\n    pipe: jest.fn(() =&gt; ({\n      tap: jest.fn(() =&gt; ({\n        next: jest.fn(),\n        error: jest.fn(),\n      })),\n    })),\n  })),\n};*/\n\njest.setTimeout(70000);\ndescribe(&#x27;ElkModule&#x27;, () =&gt; {\n  let app: INestApplication;\n  let elkService: ElkService;\n  let interceptor: ElkInterceptor&lt;any&gt;;\n  let container: testContainers;\n\n  beforeAll(async () =&gt; {\n    //&#x27;elasticsearch:8.3.3&#x27;\n    //docker.elastic.co/elasticsearch/elasticsearch:8.3.3\n\n    container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n      ...TCElasticSearchOptions,\n      containerName: `${tcName}-elasticsearch-interceptor`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              elasticsearch: {\n                name: &#x27;test-elk-index&#x27;,\n                node: {\n                  url: new URL(`http://${container.getHost()}:9200`),\n                },\n                maxRetries: 10,\n                requestTimeout: 60000,\n                sniffOnStart: true,\n                Connection: HttpConnection,\n              },\n            }),\n          ],\n        }),\n        ElkModule,\n      ],\n    }).compile();\n    app = moduleFixture.createNestApplication();\n    interceptor = new ElkInterceptor(app.get&lt;ElkService&gt;(ElkService));\n    app.useGlobalInterceptors(interceptor);\n    elkService = moduleFixture.get&lt;ElkService&gt;(ElkService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(app).toBeDefined();\n  });\n\n  describe(&#x27;ElkInterceptor&#x27;, () =&gt; {\n    it(&#x27;should be an ElkInterceptor instance to be defined&#x27;, async () =&gt; {\n      expect(new ElkInterceptor(elkService)).toBeDefined();\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success string&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of(&#x27;this is a test&#x27;)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success object&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of([fixtureUserResponse])),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success with parameters&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of([fixtureUserResponse])),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContextParams, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return exception&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const error = new Error(`User #$1 not found`);\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; throwError(error)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () =&gt; {},\n        error: (error) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return exception http&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const error = new HttpException(&#x27;not found&#x27;, 404);\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; throwError(error)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () =&gt; {},\n        error: (error) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n  });\n\n  describe(&#x27;ElkModule - Register&#x27;, () =&gt; {\n    let app: INestApplication;\n    let elkService: ElkService;\n    let interceptor: ElkInterceptor&lt;any&gt;;\n\n    beforeEach(async () =&gt; {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ElkModule.register({\n            name: &#x27;test-elk-index&#x27;,\n            node: {\n              url: new URL(`http://${container.getHost()}:9200`),\n            },\n            maxRetries: 10,\n            requestTimeout: 60000,\n            sniffOnStart: true,\n            Connection: HttpConnection,\n          }),\n        ],\n      }).compile();\n      app = moduleFixture.createNestApplication();\n      interceptor = new ElkInterceptor(app.get&lt;ElkService&gt;(ElkService));\n      app.useGlobalInterceptors(interceptor);\n      elkService = moduleFixture.get&lt;ElkService&gt;(ElkService);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ad7de4a3-496f-41da-9b73-a1cafc3f944d&quot;,&quot;parentUUID&quot;:&quot;0f6532ad-4f13-49f8-9445-e7f262aa0f9c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;ElkModule &gt; ElkModule - Register &gt; should be defined&quot;,&quot;title&quot;:&quot;ElkModule &gt; ElkModule - Register &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1015,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { HttpException, INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport {\n  dynamicConfig,\n  fixtureUserResponse,\n  TCElasticSearchOptions,\n  tcName,\n  testContainers,\n} from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { Observable, of, throwError } from &#x27;rxjs&#x27;;\nimport { HttpConnection } from &#x27;@elastic/elasticsearch&#x27;;\nimport { URL } from &#x27;url&#x27;;\n\nimport { ElkModule } from &#x27;../elk/elk.module&#x27;;\nimport { ElkInterceptor } from &#x27;../elk/interceptors/elk.interceptor&#x27;;\nimport { ElkService } from &#x27;../elk/services/elk.service&#x27;;\n\nlet executionContext: any = {\n  switchToHttp: jest.fn(() =&gt; ({\n    getRequest: () =&gt; ({\n      path: &#x27;/test&#x27;,\n      method: &#x27;GET&#x27;,\n      params: {},\n      query: {},\n      body: {},\n      headers: {\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        apiKey: &#x27;abcdefg12345&#x27;,\n      },\n    }),\n    getResponse: () =&gt; ({\n      getHeaders: jest.fn().mockReturnValue({\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        my_header: &#x27;test-header&#x27;,\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() =&gt; &#x27;http&#x27;),\n  getClass: jest.fn(() =&gt; &#x27;testController&#x27;),\n  getHandler: jest.fn(() =&gt; &#x27;handlerElk&#x27;),\n};\n\nlet executionContextParams: any = {\n  switchToHttp: jest.fn(() =&gt; ({\n    getRequest: () =&gt; ({\n      path: &#x27;/test&#x27;,\n      method: &#x27;GET&#x27;,\n      params: { name: &#x27;juan&#x27; },\n      query: { name: &#x27;juan&#x27; },\n      body: { name: &#x27;juan&#x27; },\n      headers: {\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        apiKey: &#x27;abcdefg12345&#x27;,\n      },\n    }),\n    getResponse: () =&gt; ({\n      getHeaders: jest.fn().mockReturnValue({\n        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\n        my_header: &#x27;test-header&#x27;,\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() =&gt; &#x27;http&#x27;),\n  getClass: jest.fn(() =&gt; &#x27;testController&#x27;),\n  getHandler: jest.fn(() =&gt; &#x27;handlerElk&#x27;),\n};\n\n/*const callHandler: any = {\n  handle: jest.fn(() =&gt; ({\n    pipe: jest.fn(() =&gt; ({\n      tap: jest.fn(() =&gt; ({\n        next: jest.fn(),\n        error: jest.fn(),\n      })),\n    })),\n  })),\n};*/\n\njest.setTimeout(70000);\ndescribe(&#x27;ElkModule&#x27;, () =&gt; {\n  let app: INestApplication;\n  let elkService: ElkService;\n  let interceptor: ElkInterceptor&lt;any&gt;;\n  let container: testContainers;\n\n  beforeAll(async () =&gt; {\n    //&#x27;elasticsearch:8.3.3&#x27;\n    //docker.elastic.co/elasticsearch/elasticsearch:8.3.3\n\n    container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n      ...TCElasticSearchOptions,\n      containerName: `${tcName}-elasticsearch-interceptor`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              elasticsearch: {\n                name: &#x27;test-elk-index&#x27;,\n                node: {\n                  url: new URL(`http://${container.getHost()}:9200`),\n                },\n                maxRetries: 10,\n                requestTimeout: 60000,\n                sniffOnStart: true,\n                Connection: HttpConnection,\n              },\n            }),\n          ],\n        }),\n        ElkModule,\n      ],\n    }).compile();\n    app = moduleFixture.createNestApplication();\n    interceptor = new ElkInterceptor(app.get&lt;ElkService&gt;(ElkService));\n    app.useGlobalInterceptors(interceptor);\n    elkService = moduleFixture.get&lt;ElkService&gt;(ElkService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(app).toBeDefined();\n  });\n\n  describe(&#x27;ElkInterceptor&#x27;, () =&gt; {\n    it(&#x27;should be an ElkInterceptor instance to be defined&#x27;, async () =&gt; {\n      expect(new ElkInterceptor(elkService)).toBeDefined();\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success string&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of(&#x27;this is a test&#x27;)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success object&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of([fixtureUserResponse])),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return success with parameters&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; of([fixtureUserResponse])),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContextParams, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) =&gt; {\n          elkService.serializeResponseInterceptor(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n        },\n        error: () =&gt; {},\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return exception&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const error = new Error(`User #$1 not found`);\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; throwError(error)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () =&gt; {},\n        error: (error) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n\n    it(&#x27;should be create document in elasticsearch when return exception http&#x27;, async () =&gt; {\n      const interceptorServiceSpy = jest.spyOn(elkService, &#x27;serializeResponseInterceptor&#x27;);\n      const timeRequest = Date.now();\n\n      const error = new HttpException(&#x27;not found&#x27;, 404);\n\n      const callHandler: any = {\n        handle: jest.fn(() =&gt; throwError(error)),\n      };\n\n      const obs: Observable&lt;any&gt; = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () =&gt; {},\n        error: (error) =&gt; {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n  });\n\n  describe(&#x27;ElkModule - Register&#x27;, () =&gt; {\n    let app: INestApplication;\n    let elkService: ElkService;\n    let interceptor: ElkInterceptor&lt;any&gt;;\n\n    beforeEach(async () =&gt; {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ElkModule.register({\n            name: &#x27;test-elk-index&#x27;,\n            node: {\n              url: new URL(`http://${container.getHost()}:9200`),\n            },\n            maxRetries: 10,\n            requestTimeout: 60000,\n            sniffOnStart: true,\n            Connection: HttpConnection,\n          }),\n        ],\n      }).compile();\n      app = moduleFixture.createNestApplication();\n      interceptor = new ElkInterceptor(app.get&lt;ElkService&gt;(ElkService));\n      app.useGlobalInterceptors(interceptor);\n      elkService = moduleFixture.get&lt;ElkService&gt;(ElkService);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6fb2dcc4-b990-4de7-a3bc-260e3e6afc04&quot;,&quot;parentUUID&quot;:&quot;0f6532ad-4f13-49f8-9445-e7f262aa0f9c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;3a57bd6d-82a0-4047-b5d2-aa2b38dbe358&quot;,&quot;17ef29b7-1bf9-4228-b5c6-7df761954c65&quot;,&quot;4565f054-dd49-4d71-92ab-2b28c8c890e0&quot;,&quot;5ee1c8c9-b122-4058-8d13-5025988dd81d&quot;,&quot;3d4a6584-0bbc-4f77-bff7-3fe93540005d&quot;,&quot;b2b83334-5afc-4bdc-a581-1a9d7d612784&quot;,&quot;ad7de4a3-496f-41da-9b73-a1cafc3f944d&quot;,&quot;6fb2dcc4-b990-4de7-a3bc-260e3e6afc04&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:8367,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:5000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:5000},{&quot;uuid&quot;:&quot;1726c199-a5e4-46e6-88a3-2bc58d93807b&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/filters&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;3912b6d8-5fd0-4cb4-b666-985d581eda48&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/filters&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;fullTitle&quot;:&quot;filters &gt; code exception &gt; should map a regular code exception&quot;,&quot;title&quot;:&quot;filters &gt; code exception &gt; should map a regular code exception&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from &#x27;@nestjs/common&#x27;;\nimport { config } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from &#x27;../&#x27;;\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() =&gt; ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() =&gt; ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() =&gt; ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() =&gt; ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() =&gt; ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() =&gt; ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe(&#x27;filters&#x27;, () =&gt; {\n  describe(&#x27;code exception&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map a regular code exception&#x27;, () =&gt; {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split(&#x27;&#x27;);\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe(&#x27;default Http exceptions&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details and description&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;passing?&#x27;;\n      const details = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe(&#x27;the generic HttpException&#x27;, () =&gt; {\n      it(&#x27;should map HttpException response when called with a string&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const message = &#x27;Not passing&#x27;;\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;some message&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object with empty message&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an array&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: [&#x27;some message&#x27;, &#x27;some message 2&#x27;],\n          error: &#x27;Bad Request&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n      const errorObject: IErrorDetail = {\n        message: &#x27;some message&#x27;,\n        error: {\n          instance: &#x27;instance&#x27;,\n          type: &#x27;some-problem-detail&#x27;,\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;when used outside a module&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;configuration is defined with values&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it(&#x27;should be return application info&#x27;, async () =&gt; {\n      expect(appConfig.project.apiPrefix).toEqual(&#x27;API-TEST&#x27;);\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe(&#x27;configuration is undefined&#x27;, () =&gt; {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;39dd0c2c-5b87-4a46-bc03-9507c2bcb8a8&quot;,&quot;parentUUID&quot;:&quot;3912b6d8-5fd0-4cb4-b666-985d581eda48&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;filters &gt; default Http exceptions &gt; should map default exception when thrown with not parameters&quot;,&quot;title&quot;:&quot;filters &gt; default Http exceptions &gt; should map default exception when thrown with not parameters&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from &#x27;@nestjs/common&#x27;;\nimport { config } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from &#x27;../&#x27;;\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() =&gt; ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() =&gt; ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() =&gt; ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() =&gt; ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() =&gt; ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() =&gt; ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe(&#x27;filters&#x27;, () =&gt; {\n  describe(&#x27;code exception&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map a regular code exception&#x27;, () =&gt; {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split(&#x27;&#x27;);\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe(&#x27;default Http exceptions&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details and description&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;passing?&#x27;;\n      const details = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe(&#x27;the generic HttpException&#x27;, () =&gt; {\n      it(&#x27;should map HttpException response when called with a string&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const message = &#x27;Not passing&#x27;;\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;some message&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object with empty message&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an array&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: [&#x27;some message&#x27;, &#x27;some message 2&#x27;],\n          error: &#x27;Bad Request&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n      const errorObject: IErrorDetail = {\n        message: &#x27;some message&#x27;,\n        error: {\n          instance: &#x27;instance&#x27;,\n          type: &#x27;some-problem-detail&#x27;,\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;when used outside a module&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;configuration is defined with values&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it(&#x27;should be return application info&#x27;, async () =&gt; {\n      expect(appConfig.project.apiPrefix).toEqual(&#x27;API-TEST&#x27;);\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe(&#x27;configuration is undefined&#x27;, () =&gt; {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d97fb0cc-1bde-4c44-9b22-c701e014395f&quot;,&quot;parentUUID&quot;:&quot;3912b6d8-5fd0-4cb4-b666-985d581eda48&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;filters &gt; default Http exceptions &gt; should map default exception when thrown with error details&quot;,&quot;title&quot;:&quot;filters &gt; default Http exceptions &gt; should map default exception when thrown with error details&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from &#x27;@nestjs/common&#x27;;\nimport { config } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from &#x27;../&#x27;;\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() =&gt; ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() =&gt; ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() =&gt; ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() =&gt; ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() =&gt; ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() =&gt; ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe(&#x27;filters&#x27;, () =&gt; {\n  describe(&#x27;code exception&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map a regular code exception&#x27;, () =&gt; {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split(&#x27;&#x27;);\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe(&#x27;default Http exceptions&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details and description&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;passing?&#x27;;\n      const details = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe(&#x27;the generic HttpException&#x27;, () =&gt; {\n      it(&#x27;should map HttpException response when called with a string&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const message = &#x27;Not passing&#x27;;\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;some message&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object with empty message&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an array&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: [&#x27;some message&#x27;, &#x27;some message 2&#x27;],\n          error: &#x27;Bad Request&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n      const errorObject: IErrorDetail = {\n        message: &#x27;some message&#x27;,\n        error: {\n          instance: &#x27;instance&#x27;,\n          type: &#x27;some-problem-detail&#x27;,\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;when used outside a module&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;configuration is defined with values&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it(&#x27;should be return application info&#x27;, async () =&gt; {\n      expect(appConfig.project.apiPrefix).toEqual(&#x27;API-TEST&#x27;);\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe(&#x27;configuration is undefined&#x27;, () =&gt; {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;03044674-0534-4e58-b7c3-2a2f676fc7f0&quot;,&quot;parentUUID&quot;:&quot;3912b6d8-5fd0-4cb4-b666-985d581eda48&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;filters &gt; default Http exceptions &gt; should map default exception when thrown with error details and description&quot;,&quot;title&quot;:&quot;filters &gt; default Http exceptions &gt; should map default exception when thrown with error details and description&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from &#x27;@nestjs/common&#x27;;\nimport { config } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from &#x27;../&#x27;;\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() =&gt; ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() =&gt; ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() =&gt; ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() =&gt; ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() =&gt; ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() =&gt; ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe(&#x27;filters&#x27;, () =&gt; {\n  describe(&#x27;code exception&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map a regular code exception&#x27;, () =&gt; {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split(&#x27;&#x27;);\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe(&#x27;default Http exceptions&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details and description&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;passing?&#x27;;\n      const details = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe(&#x27;the generic HttpException&#x27;, () =&gt; {\n      it(&#x27;should map HttpException response when called with a string&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const message = &#x27;Not passing&#x27;;\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;some message&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object with empty message&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an array&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: [&#x27;some message&#x27;, &#x27;some message 2&#x27;],\n          error: &#x27;Bad Request&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n      const errorObject: IErrorDetail = {\n        message: &#x27;some message&#x27;,\n        error: {\n          instance: &#x27;instance&#x27;,\n          type: &#x27;some-problem-detail&#x27;,\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;when used outside a module&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;configuration is defined with values&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it(&#x27;should be return application info&#x27;, async () =&gt; {\n      expect(appConfig.project.apiPrefix).toEqual(&#x27;API-TEST&#x27;);\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe(&#x27;configuration is undefined&#x27;, () =&gt; {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6e7fd7fb-fb22-4da1-9b03-b55a24054735&quot;,&quot;parentUUID&quot;:&quot;3912b6d8-5fd0-4cb4-b666-985d581eda48&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;filters &gt; default Http exceptions &gt; the generic HttpException &gt; should map HttpException response when called with a string&quot;,&quot;title&quot;:&quot;filters &gt; default Http exceptions &gt; the generic HttpException &gt; should map HttpException response when called with a string&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from &#x27;@nestjs/common&#x27;;\nimport { config } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from &#x27;../&#x27;;\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() =&gt; ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() =&gt; ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() =&gt; ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() =&gt; ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() =&gt; ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() =&gt; ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe(&#x27;filters&#x27;, () =&gt; {\n  describe(&#x27;code exception&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map a regular code exception&#x27;, () =&gt; {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split(&#x27;&#x27;);\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe(&#x27;default Http exceptions&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details and description&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;passing?&#x27;;\n      const details = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe(&#x27;the generic HttpException&#x27;, () =&gt; {\n      it(&#x27;should map HttpException response when called with a string&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const message = &#x27;Not passing&#x27;;\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;some message&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object with empty message&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an array&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: [&#x27;some message&#x27;, &#x27;some message 2&#x27;],\n          error: &#x27;Bad Request&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n      const errorObject: IErrorDetail = {\n        message: &#x27;some message&#x27;,\n        error: {\n          instance: &#x27;instance&#x27;,\n          type: &#x27;some-problem-detail&#x27;,\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;when used outside a module&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;configuration is defined with values&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it(&#x27;should be return application info&#x27;, async () =&gt; {\n      expect(appConfig.project.apiPrefix).toEqual(&#x27;API-TEST&#x27;);\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe(&#x27;configuration is undefined&#x27;, () =&gt; {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;bcf4942e-e552-448f-9595-40a92920b415&quot;,&quot;parentUUID&quot;:&quot;3912b6d8-5fd0-4cb4-b666-985d581eda48&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;filters &gt; default Http exceptions &gt; the generic HttpException &gt; should map HttpException response when called with an object&quot;,&quot;title&quot;:&quot;filters &gt; default Http exceptions &gt; the generic HttpException &gt; should map HttpException response when called with an object&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from &#x27;@nestjs/common&#x27;;\nimport { config } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from &#x27;../&#x27;;\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() =&gt; ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() =&gt; ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() =&gt; ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() =&gt; ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() =&gt; ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() =&gt; ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe(&#x27;filters&#x27;, () =&gt; {\n  describe(&#x27;code exception&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map a regular code exception&#x27;, () =&gt; {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split(&#x27;&#x27;);\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe(&#x27;default Http exceptions&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details and description&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;passing?&#x27;;\n      const details = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe(&#x27;the generic HttpException&#x27;, () =&gt; {\n      it(&#x27;should map HttpException response when called with a string&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const message = &#x27;Not passing&#x27;;\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;some message&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object with empty message&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an array&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: [&#x27;some message&#x27;, &#x27;some message 2&#x27;],\n          error: &#x27;Bad Request&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n      const errorObject: IErrorDetail = {\n        message: &#x27;some message&#x27;,\n        error: {\n          instance: &#x27;instance&#x27;,\n          type: &#x27;some-problem-detail&#x27;,\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;when used outside a module&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;configuration is defined with values&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it(&#x27;should be return application info&#x27;, async () =&gt; {\n      expect(appConfig.project.apiPrefix).toEqual(&#x27;API-TEST&#x27;);\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe(&#x27;configuration is undefined&#x27;, () =&gt; {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;56adf7d9-1bf1-4638-975f-8ad002748be5&quot;,&quot;parentUUID&quot;:&quot;3912b6d8-5fd0-4cb4-b666-985d581eda48&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;filters &gt; default Http exceptions &gt; the generic HttpException &gt; should map HttpException response when called with an object with empty message&quot;,&quot;title&quot;:&quot;filters &gt; default Http exceptions &gt; the generic HttpException &gt; should map HttpException response when called with an object with empty message&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from &#x27;@nestjs/common&#x27;;\nimport { config } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from &#x27;../&#x27;;\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() =&gt; ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() =&gt; ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() =&gt; ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() =&gt; ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() =&gt; ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() =&gt; ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe(&#x27;filters&#x27;, () =&gt; {\n  describe(&#x27;code exception&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map a regular code exception&#x27;, () =&gt; {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split(&#x27;&#x27;);\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe(&#x27;default Http exceptions&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details and description&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;passing?&#x27;;\n      const details = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe(&#x27;the generic HttpException&#x27;, () =&gt; {\n      it(&#x27;should map HttpException response when called with a string&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const message = &#x27;Not passing&#x27;;\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;some message&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object with empty message&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an array&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: [&#x27;some message&#x27;, &#x27;some message 2&#x27;],\n          error: &#x27;Bad Request&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n      const errorObject: IErrorDetail = {\n        message: &#x27;some message&#x27;,\n        error: {\n          instance: &#x27;instance&#x27;,\n          type: &#x27;some-problem-detail&#x27;,\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;when used outside a module&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;configuration is defined with values&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it(&#x27;should be return application info&#x27;, async () =&gt; {\n      expect(appConfig.project.apiPrefix).toEqual(&#x27;API-TEST&#x27;);\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe(&#x27;configuration is undefined&#x27;, () =&gt; {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;db8c72ba-30a9-49ff-a86f-94d09f9bfc6e&quot;,&quot;parentUUID&quot;:&quot;3912b6d8-5fd0-4cb4-b666-985d581eda48&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;filters &gt; default Http exceptions &gt; the generic HttpException &gt; should map HttpException response when called with an array&quot;,&quot;title&quot;:&quot;filters &gt; default Http exceptions &gt; the generic HttpException &gt; should map HttpException response when called with an array&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from &#x27;@nestjs/common&#x27;;\nimport { config } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from &#x27;../&#x27;;\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() =&gt; ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() =&gt; ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() =&gt; ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() =&gt; ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() =&gt; ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() =&gt; ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe(&#x27;filters&#x27;, () =&gt; {\n  describe(&#x27;code exception&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map a regular code exception&#x27;, () =&gt; {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split(&#x27;&#x27;);\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe(&#x27;default Http exceptions&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details and description&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;passing?&#x27;;\n      const details = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe(&#x27;the generic HttpException&#x27;, () =&gt; {\n      it(&#x27;should map HttpException response when called with a string&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const message = &#x27;Not passing&#x27;;\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;some message&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object with empty message&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an array&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: [&#x27;some message&#x27;, &#x27;some message 2&#x27;],\n          error: &#x27;Bad Request&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n      const errorObject: IErrorDetail = {\n        message: &#x27;some message&#x27;,\n        error: {\n          instance: &#x27;instance&#x27;,\n          type: &#x27;some-problem-detail&#x27;,\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;when used outside a module&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;configuration is defined with values&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it(&#x27;should be return application info&#x27;, async () =&gt; {\n      expect(appConfig.project.apiPrefix).toEqual(&#x27;API-TEST&#x27;);\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe(&#x27;configuration is undefined&#x27;, () =&gt; {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9ab8e9df-92fc-4836-bc33-3072d17b2da5&quot;,&quot;parentUUID&quot;:&quot;3912b6d8-5fd0-4cb4-b666-985d581eda48&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;filters &gt; default Http exceptions &gt; should map HttpException response when called with an object&quot;,&quot;title&quot;:&quot;filters &gt; default Http exceptions &gt; should map HttpException response when called with an object&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:0,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from &#x27;@nestjs/common&#x27;;\nimport { config } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from &#x27;../&#x27;;\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() =&gt; ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() =&gt; ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() =&gt; ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() =&gt; ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() =&gt; ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() =&gt; ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe(&#x27;filters&#x27;, () =&gt; {\n  describe(&#x27;code exception&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map a regular code exception&#x27;, () =&gt; {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split(&#x27;&#x27;);\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe(&#x27;default Http exceptions&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details and description&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;passing?&#x27;;\n      const details = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe(&#x27;the generic HttpException&#x27;, () =&gt; {\n      it(&#x27;should map HttpException response when called with a string&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const message = &#x27;Not passing&#x27;;\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;some message&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object with empty message&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an array&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: [&#x27;some message&#x27;, &#x27;some message 2&#x27;],\n          error: &#x27;Bad Request&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n      const errorObject: IErrorDetail = {\n        message: &#x27;some message&#x27;,\n        error: {\n          instance: &#x27;instance&#x27;,\n          type: &#x27;some-problem-detail&#x27;,\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;when used outside a module&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;configuration is defined with values&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it(&#x27;should be return application info&#x27;, async () =&gt; {\n      expect(appConfig.project.apiPrefix).toEqual(&#x27;API-TEST&#x27;);\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe(&#x27;configuration is undefined&#x27;, () =&gt; {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3b6c17d7-75ef-4556-ba89-20c1ce4c0c87&quot;,&quot;parentUUID&quot;:&quot;3912b6d8-5fd0-4cb4-b666-985d581eda48&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;filters &gt; when used outside a module &gt; should map default exception when thrown with not parameters&quot;,&quot;title&quot;:&quot;filters &gt; when used outside a module &gt; should map default exception when thrown with not parameters&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:0,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from &#x27;@nestjs/common&#x27;;\nimport { config } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from &#x27;../&#x27;;\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() =&gt; ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() =&gt; ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() =&gt; ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() =&gt; ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() =&gt; ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() =&gt; ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe(&#x27;filters&#x27;, () =&gt; {\n  describe(&#x27;code exception&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map a regular code exception&#x27;, () =&gt; {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split(&#x27;&#x27;);\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe(&#x27;default Http exceptions&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details and description&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;passing?&#x27;;\n      const details = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe(&#x27;the generic HttpException&#x27;, () =&gt; {\n      it(&#x27;should map HttpException response when called with a string&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const message = &#x27;Not passing&#x27;;\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;some message&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object with empty message&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an array&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: [&#x27;some message&#x27;, &#x27;some message 2&#x27;],\n          error: &#x27;Bad Request&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n      const errorObject: IErrorDetail = {\n        message: &#x27;some message&#x27;,\n        error: {\n          instance: &#x27;instance&#x27;,\n          type: &#x27;some-problem-detail&#x27;,\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;when used outside a module&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;configuration is defined with values&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it(&#x27;should be return application info&#x27;, async () =&gt; {\n      expect(appConfig.project.apiPrefix).toEqual(&#x27;API-TEST&#x27;);\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe(&#x27;configuration is undefined&#x27;, () =&gt; {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;cf9d0a16-8d2d-46a6-ae65-bcce2735d8d5&quot;,&quot;parentUUID&quot;:&quot;3912b6d8-5fd0-4cb4-b666-985d581eda48&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;filters &gt; configuration is defined with values &gt; should be return application info&quot;,&quot;title&quot;:&quot;filters &gt; configuration is defined with values &gt; should be return application info&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from &#x27;@nestjs/common&#x27;;\nimport { config } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from &#x27;../&#x27;;\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() =&gt; ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() =&gt; ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() =&gt; ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() =&gt; ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() =&gt; ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() =&gt; ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe(&#x27;filters&#x27;, () =&gt; {\n  describe(&#x27;code exception&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map a regular code exception&#x27;, () =&gt; {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split(&#x27;&#x27;);\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe(&#x27;default Http exceptions&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it(&#x27;should map default exception when thrown with error details and description&#x27;, () =&gt; {\n      const status = HttpStatus.FORBIDDEN;\n      const message = &#x27;passing?&#x27;;\n      const details = &#x27;not pass!&#x27;;\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe(&#x27;the generic HttpException&#x27;, () =&gt; {\n      it(&#x27;should map HttpException response when called with a string&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const message = &#x27;Not passing&#x27;;\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;some message&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an object with empty message&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: &#x27;&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it(&#x27;should map HttpException response when called with an array&#x27;, () =&gt; {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: [&#x27;some message&#x27;, &#x27;some message 2&#x27;],\n          error: &#x27;Bad Request&#x27;,\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it(&#x27;should map HttpException response when called with an object&#x27;, () =&gt; {\n      const errorObject: IErrorDetail = {\n        message: &#x27;some message&#x27;,\n        error: {\n          instance: &#x27;instance&#x27;,\n          type: &#x27;some-problem-detail&#x27;,\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;when used outside a module&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it(&#x27;should map default exception when thrown with not parameters&#x27;, () =&gt; {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe(&#x27;configuration is defined with values&#x27;, () =&gt; {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it(&#x27;should be return application info&#x27;, async () =&gt; {\n      expect(appConfig.project.apiPrefix).toEqual(&#x27;API-TEST&#x27;);\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe(&#x27;configuration is undefined&#x27;, () =&gt; {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c40485be-01ef-4036-908e-4e78ac152dd2&quot;,&quot;parentUUID&quot;:&quot;3912b6d8-5fd0-4cb4-b666-985d581eda48&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;error.utils &gt; should be return code in string&quot;,&quot;title&quot;:&quot;error.utils &gt; should be return code in string&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { getCode } from &#x27;../&#x27;;\nimport { HttpStatus } from &#x27;@nestjs/common&#x27;;\n\ndescribe(&#x27;error.utils&#x27;, () =&gt; {\n  it(&#x27;should be return code in string&#x27;, () =&gt; {\n    const code = getCode(HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR]);\n    expect(code).toEqual(&#x27;INTERNAL_SERVER_ERROR&#x27;);\n  });\n\n  it(&#x27;should be return code in string obj&#x27;, () =&gt; {\n    const code = getCode({ error: HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR] });\n    expect(code).toEqual(&#x27;INTERNAL_SERVER_ERROR&#x27;);\n  });\n\n  it(&#x27;should be return code in string&#x27;, () =&gt; {\n    const code = getCode({ error: HttpStatus[&#x27;TEST_ERROR&#x27;] });\n    expect(code).toEqual(&#x27;INTERNAL_SERVER_ERROR&#x27;);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;59196945-9c9c-4dc7-a043-f698503baa0b&quot;,&quot;parentUUID&quot;:&quot;3912b6d8-5fd0-4cb4-b666-985d581eda48&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;error.utils &gt; should be return code in string obj&quot;,&quot;title&quot;:&quot;error.utils &gt; should be return code in string obj&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { getCode } from &#x27;../&#x27;;\nimport { HttpStatus } from &#x27;@nestjs/common&#x27;;\n\ndescribe(&#x27;error.utils&#x27;, () =&gt; {\n  it(&#x27;should be return code in string&#x27;, () =&gt; {\n    const code = getCode(HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR]);\n    expect(code).toEqual(&#x27;INTERNAL_SERVER_ERROR&#x27;);\n  });\n\n  it(&#x27;should be return code in string obj&#x27;, () =&gt; {\n    const code = getCode({ error: HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR] });\n    expect(code).toEqual(&#x27;INTERNAL_SERVER_ERROR&#x27;);\n  });\n\n  it(&#x27;should be return code in string&#x27;, () =&gt; {\n    const code = getCode({ error: HttpStatus[&#x27;TEST_ERROR&#x27;] });\n    expect(code).toEqual(&#x27;INTERNAL_SERVER_ERROR&#x27;);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b1e48704-14cd-4d36-977b-9610427371f1&quot;,&quot;parentUUID&quot;:&quot;3912b6d8-5fd0-4cb4-b666-985d581eda48&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;error.utils &gt; should be return code in string&quot;,&quot;title&quot;:&quot;error.utils &gt; should be return code in string&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:0,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { getCode } from &#x27;../&#x27;;\nimport { HttpStatus } from &#x27;@nestjs/common&#x27;;\n\ndescribe(&#x27;error.utils&#x27;, () =&gt; {\n  it(&#x27;should be return code in string&#x27;, () =&gt; {\n    const code = getCode(HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR]);\n    expect(code).toEqual(&#x27;INTERNAL_SERVER_ERROR&#x27;);\n  });\n\n  it(&#x27;should be return code in string obj&#x27;, () =&gt; {\n    const code = getCode({ error: HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR] });\n    expect(code).toEqual(&#x27;INTERNAL_SERVER_ERROR&#x27;);\n  });\n\n  it(&#x27;should be return code in string&#x27;, () =&gt; {\n    const code = getCode({ error: HttpStatus[&#x27;TEST_ERROR&#x27;] });\n    expect(code).toEqual(&#x27;INTERNAL_SERVER_ERROR&#x27;);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;15e3b010-6f8c-44e6-8276-abc37503661d&quot;,&quot;parentUUID&quot;:&quot;3912b6d8-5fd0-4cb4-b666-985d581eda48&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;39dd0c2c-5b87-4a46-bc03-9507c2bcb8a8&quot;,&quot;d97fb0cc-1bde-4c44-9b22-c701e014395f&quot;,&quot;03044674-0534-4e58-b7c3-2a2f676fc7f0&quot;,&quot;6e7fd7fb-fb22-4da1-9b03-b55a24054735&quot;,&quot;bcf4942e-e552-448f-9595-40a92920b415&quot;,&quot;56adf7d9-1bf1-4638-975f-8ad002748be5&quot;,&quot;db8c72ba-30a9-49ff-a86f-94d09f9bfc6e&quot;,&quot;9ab8e9df-92fc-4836-bc33-3072d17b2da5&quot;,&quot;3b6c17d7-75ef-4556-ba89-20c1ce4c0c87&quot;,&quot;cf9d0a16-8d2d-46a6-ae65-bcce2735d8d5&quot;,&quot;c40485be-01ef-4036-908e-4e78ac152dd2&quot;,&quot;59196945-9c9c-4dc7-a043-f698503baa0b&quot;,&quot;b1e48704-14cd-4d36-977b-9610427371f1&quot;,&quot;15e3b010-6f8c-44e6-8276-abc37503661d&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:13,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:5000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:5000},{&quot;uuid&quot;:&quot;09a21e95-0d5c-4bcd-b8bc-361a9971ac2b&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/health&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;b2145cb6-7be5-4747-84cc-285b60b47f72&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/health&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;fullTitle&quot;:&quot;Health &gt; Ready controller - extend config &gt; should be defined with extend config&quot;,&quot;title&quot;:&quot;Health &gt; Ready controller - extend config &gt; should be defined with extend config&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:757,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { HttpModule } from &#x27;@nestjs/axios&#x27;;\nimport {\n  HealthCheckService,\n  HttpHealthIndicator,\n  TerminusModule,\n  TypeOrmHealthIndicator,\n  MicroserviceHealthIndicator,\n} from &#x27;@nestjs/terminus&#x27;;\n\nimport { ReadinessController } from &#x27;../health/controllers/readiness.controller&#x27;;\nimport { CONFIG_OPTIONS } from &#x27;../health/constants&#x27;;\n\nconst mockedConfig = {\n  services: {\n    myService: {\n      url: &#x27;http://localhost:8082&#x27;,\n      timeout: 3000,\n    },\n    demoApi: {\n      url: &#x27;https://nestjs-starter.up.railway.app&#x27;,\n      timeout: 3000,\n      healthPath: &#x27;/v1/health/liveness&#x27;,\n    },\n  },\n  database: {\n    typeorm: {\n      type: &#x27;postgres&#x27;,\n    },\n  },\n  redis: {\n    host: &#x27;localhost&#x27;,\n    port: 6379,\n  },\n  elasticsearch: {\n    name: &#x27;test-app&#x27;,\n    node: &#x27;http://localhost:9200&#x27;,\n  },\n  camunda: {\n    baseUrl: &#x27;http://localhost:8080/engine-rest&#x27;,\n  },\n};\n\nconst mockExpectReadiness = {\n  status: &#x27;ok&#x27;,\n  info: {\n    myService: {\n      status: &#x27;up&#x27;,\n    },\n    typeOrm: {\n      status: &#x27;up&#x27;,\n    },\n    redis: {\n      status: &#x27;up&#x27;,\n    },\n    elasticsearch: {\n      status: &#x27;up&#x27;,\n    },\n    camunda: {\n      status: &#x27;up&#x27;,\n    },\n  },\n  error: {},\n  details: {\n    myService: {\n      status: &#x27;up&#x27;,\n    },\n    typeOrm: {\n      status: &#x27;up&#x27;,\n    },\n    redis: {\n      status: &#x27;up&#x27;,\n    },\n    elasticsearch: {\n      status: &#x27;up&#x27;,\n    },\n    camunda: {\n      status: &#x27;up&#x27;,\n    },\n  },\n};\n\nconst mockExpectReadinessDown = {\n  myService: {\n    status: &#x27;down&#x27;,\n    message: &#x27;connect ECONNREFUSED 127.0.0.1:8082&#x27;,\n  },\n};\n\nconst simpleConfig = {\n  services: {\n    myService: { url: &#x27;http://localhost:8082&#x27; },\n  },\n};\n\ndescribe(&#x27;Health&#x27;, () =&gt; {\n  describe(&#x27;Ready controller - extend config&#x27;, () =&gt; {\n    let controller: ReadinessController;\n    let health: HealthCheckService;\n    let http: HttpHealthIndicator;\n    let typeOrm: TypeOrmHealthIndicator;\n    let redis: MicroserviceHealthIndicator;\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [TerminusModule, HttpModule],\n        controllers: [ReadinessController],\n        providers: [\n          {\n            provide: CONFIG_OPTIONS,\n            useValue: mockedConfig,\n          },\n        ],\n      }).compile();\n\n      controller = module.get&lt;ReadinessController&gt;(ReadinessController);\n      health = await module.resolve&lt;HealthCheckService&gt;(HealthCheckService);\n      http = await module.resolve&lt;HttpHealthIndicator&gt;(HttpHealthIndicator as any);\n      typeOrm = await module.resolve&lt;TypeOrmHealthIndicator&gt;(TypeOrmHealthIndicator);\n      redis = await module.resolve&lt;MicroserviceHealthIndicator&gt;(MicroserviceHealthIndicator);\n    });\n\n    it(&#x27;should be defined with extend config&#x27;, () =&gt; {\n      expect(controller).toBeDefined();\n    });\n\n    it(&#x27;should be return up services with extend config&#x27;, async () =&gt; {\n      http.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      typeOrm.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      redis.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      health.check = jest.fn().mockImplementation(() =&gt; mockExpectReadiness);\n\n      const readinessData = await controller.check();\n      expect(readinessData).toEqual(mockExpectReadiness);\n    });\n  });\n\n  describe(&#x27;Ready controller - simple config&#x27;, () =&gt; {\n    let controller: ReadinessController;\n    let health: HealthCheckService;\n    let http: HttpHealthIndicator;\n    let typeOrm: TypeOrmHealthIndicator;\n    let redis: MicroserviceHealthIndicator;\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [TerminusModule, HttpModule],\n        controllers: [ReadinessController],\n        providers: [\n          {\n            provide: CONFIG_OPTIONS,\n            useValue: simpleConfig,\n          },\n        ],\n      }).compile();\n\n      controller = module.get&lt;ReadinessController&gt;(ReadinessController);\n      health = await module.resolve&lt;HealthCheckService&gt;(HealthCheckService);\n      http = await module.resolve&lt;HttpHealthIndicator&gt;(HttpHealthIndicator as any);\n      typeOrm = await module.resolve&lt;TypeOrmHealthIndicator&gt;(TypeOrmHealthIndicator);\n      redis = await module.resolve&lt;MicroserviceHealthIndicator&gt;(MicroserviceHealthIndicator);\n    });\n\n    it(&#x27;should be defined with simple config&#x27;, () =&gt; {\n      expect(controller).toBeDefined();\n    });\n\n    it(&#x27;should be return up services with simple config&#x27;, async () =&gt; {\n      http.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      typeOrm.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      redis.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      health.check = jest.fn().mockImplementation(() =&gt; mockExpectReadiness);\n\n      const readinessData = await controller.check();\n      expect(readinessData).toEqual(mockExpectReadiness);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;75976538-41b0-4d80-b8ae-b2d5408647e1&quot;,&quot;parentUUID&quot;:&quot;b2145cb6-7be5-4747-84cc-285b60b47f72&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Health &gt; Ready controller - extend config &gt; should be return up services with extend config&quot;,&quot;title&quot;:&quot;Health &gt; Ready controller - extend config &gt; should be return up services with extend config&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:6,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { HttpModule } from &#x27;@nestjs/axios&#x27;;\nimport {\n  HealthCheckService,\n  HttpHealthIndicator,\n  TerminusModule,\n  TypeOrmHealthIndicator,\n  MicroserviceHealthIndicator,\n} from &#x27;@nestjs/terminus&#x27;;\n\nimport { ReadinessController } from &#x27;../health/controllers/readiness.controller&#x27;;\nimport { CONFIG_OPTIONS } from &#x27;../health/constants&#x27;;\n\nconst mockedConfig = {\n  services: {\n    myService: {\n      url: &#x27;http://localhost:8082&#x27;,\n      timeout: 3000,\n    },\n    demoApi: {\n      url: &#x27;https://nestjs-starter.up.railway.app&#x27;,\n      timeout: 3000,\n      healthPath: &#x27;/v1/health/liveness&#x27;,\n    },\n  },\n  database: {\n    typeorm: {\n      type: &#x27;postgres&#x27;,\n    },\n  },\n  redis: {\n    host: &#x27;localhost&#x27;,\n    port: 6379,\n  },\n  elasticsearch: {\n    name: &#x27;test-app&#x27;,\n    node: &#x27;http://localhost:9200&#x27;,\n  },\n  camunda: {\n    baseUrl: &#x27;http://localhost:8080/engine-rest&#x27;,\n  },\n};\n\nconst mockExpectReadiness = {\n  status: &#x27;ok&#x27;,\n  info: {\n    myService: {\n      status: &#x27;up&#x27;,\n    },\n    typeOrm: {\n      status: &#x27;up&#x27;,\n    },\n    redis: {\n      status: &#x27;up&#x27;,\n    },\n    elasticsearch: {\n      status: &#x27;up&#x27;,\n    },\n    camunda: {\n      status: &#x27;up&#x27;,\n    },\n  },\n  error: {},\n  details: {\n    myService: {\n      status: &#x27;up&#x27;,\n    },\n    typeOrm: {\n      status: &#x27;up&#x27;,\n    },\n    redis: {\n      status: &#x27;up&#x27;,\n    },\n    elasticsearch: {\n      status: &#x27;up&#x27;,\n    },\n    camunda: {\n      status: &#x27;up&#x27;,\n    },\n  },\n};\n\nconst mockExpectReadinessDown = {\n  myService: {\n    status: &#x27;down&#x27;,\n    message: &#x27;connect ECONNREFUSED 127.0.0.1:8082&#x27;,\n  },\n};\n\nconst simpleConfig = {\n  services: {\n    myService: { url: &#x27;http://localhost:8082&#x27; },\n  },\n};\n\ndescribe(&#x27;Health&#x27;, () =&gt; {\n  describe(&#x27;Ready controller - extend config&#x27;, () =&gt; {\n    let controller: ReadinessController;\n    let health: HealthCheckService;\n    let http: HttpHealthIndicator;\n    let typeOrm: TypeOrmHealthIndicator;\n    let redis: MicroserviceHealthIndicator;\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [TerminusModule, HttpModule],\n        controllers: [ReadinessController],\n        providers: [\n          {\n            provide: CONFIG_OPTIONS,\n            useValue: mockedConfig,\n          },\n        ],\n      }).compile();\n\n      controller = module.get&lt;ReadinessController&gt;(ReadinessController);\n      health = await module.resolve&lt;HealthCheckService&gt;(HealthCheckService);\n      http = await module.resolve&lt;HttpHealthIndicator&gt;(HttpHealthIndicator as any);\n      typeOrm = await module.resolve&lt;TypeOrmHealthIndicator&gt;(TypeOrmHealthIndicator);\n      redis = await module.resolve&lt;MicroserviceHealthIndicator&gt;(MicroserviceHealthIndicator);\n    });\n\n    it(&#x27;should be defined with extend config&#x27;, () =&gt; {\n      expect(controller).toBeDefined();\n    });\n\n    it(&#x27;should be return up services with extend config&#x27;, async () =&gt; {\n      http.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      typeOrm.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      redis.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      health.check = jest.fn().mockImplementation(() =&gt; mockExpectReadiness);\n\n      const readinessData = await controller.check();\n      expect(readinessData).toEqual(mockExpectReadiness);\n    });\n  });\n\n  describe(&#x27;Ready controller - simple config&#x27;, () =&gt; {\n    let controller: ReadinessController;\n    let health: HealthCheckService;\n    let http: HttpHealthIndicator;\n    let typeOrm: TypeOrmHealthIndicator;\n    let redis: MicroserviceHealthIndicator;\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [TerminusModule, HttpModule],\n        controllers: [ReadinessController],\n        providers: [\n          {\n            provide: CONFIG_OPTIONS,\n            useValue: simpleConfig,\n          },\n        ],\n      }).compile();\n\n      controller = module.get&lt;ReadinessController&gt;(ReadinessController);\n      health = await module.resolve&lt;HealthCheckService&gt;(HealthCheckService);\n      http = await module.resolve&lt;HttpHealthIndicator&gt;(HttpHealthIndicator as any);\n      typeOrm = await module.resolve&lt;TypeOrmHealthIndicator&gt;(TypeOrmHealthIndicator);\n      redis = await module.resolve&lt;MicroserviceHealthIndicator&gt;(MicroserviceHealthIndicator);\n    });\n\n    it(&#x27;should be defined with simple config&#x27;, () =&gt; {\n      expect(controller).toBeDefined();\n    });\n\n    it(&#x27;should be return up services with simple config&#x27;, async () =&gt; {\n      http.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      typeOrm.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      redis.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      health.check = jest.fn().mockImplementation(() =&gt; mockExpectReadiness);\n\n      const readinessData = await controller.check();\n      expect(readinessData).toEqual(mockExpectReadiness);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;5c6ae31a-632a-487a-8cee-8a70c81837e1&quot;,&quot;parentUUID&quot;:&quot;b2145cb6-7be5-4747-84cc-285b60b47f72&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Health &gt; Ready controller - simple config &gt; should be defined with simple config&quot;,&quot;title&quot;:&quot;Health &gt; Ready controller - simple config &gt; should be defined with simple config&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { HttpModule } from &#x27;@nestjs/axios&#x27;;\nimport {\n  HealthCheckService,\n  HttpHealthIndicator,\n  TerminusModule,\n  TypeOrmHealthIndicator,\n  MicroserviceHealthIndicator,\n} from &#x27;@nestjs/terminus&#x27;;\n\nimport { ReadinessController } from &#x27;../health/controllers/readiness.controller&#x27;;\nimport { CONFIG_OPTIONS } from &#x27;../health/constants&#x27;;\n\nconst mockedConfig = {\n  services: {\n    myService: {\n      url: &#x27;http://localhost:8082&#x27;,\n      timeout: 3000,\n    },\n    demoApi: {\n      url: &#x27;https://nestjs-starter.up.railway.app&#x27;,\n      timeout: 3000,\n      healthPath: &#x27;/v1/health/liveness&#x27;,\n    },\n  },\n  database: {\n    typeorm: {\n      type: &#x27;postgres&#x27;,\n    },\n  },\n  redis: {\n    host: &#x27;localhost&#x27;,\n    port: 6379,\n  },\n  elasticsearch: {\n    name: &#x27;test-app&#x27;,\n    node: &#x27;http://localhost:9200&#x27;,\n  },\n  camunda: {\n    baseUrl: &#x27;http://localhost:8080/engine-rest&#x27;,\n  },\n};\n\nconst mockExpectReadiness = {\n  status: &#x27;ok&#x27;,\n  info: {\n    myService: {\n      status: &#x27;up&#x27;,\n    },\n    typeOrm: {\n      status: &#x27;up&#x27;,\n    },\n    redis: {\n      status: &#x27;up&#x27;,\n    },\n    elasticsearch: {\n      status: &#x27;up&#x27;,\n    },\n    camunda: {\n      status: &#x27;up&#x27;,\n    },\n  },\n  error: {},\n  details: {\n    myService: {\n      status: &#x27;up&#x27;,\n    },\n    typeOrm: {\n      status: &#x27;up&#x27;,\n    },\n    redis: {\n      status: &#x27;up&#x27;,\n    },\n    elasticsearch: {\n      status: &#x27;up&#x27;,\n    },\n    camunda: {\n      status: &#x27;up&#x27;,\n    },\n  },\n};\n\nconst mockExpectReadinessDown = {\n  myService: {\n    status: &#x27;down&#x27;,\n    message: &#x27;connect ECONNREFUSED 127.0.0.1:8082&#x27;,\n  },\n};\n\nconst simpleConfig = {\n  services: {\n    myService: { url: &#x27;http://localhost:8082&#x27; },\n  },\n};\n\ndescribe(&#x27;Health&#x27;, () =&gt; {\n  describe(&#x27;Ready controller - extend config&#x27;, () =&gt; {\n    let controller: ReadinessController;\n    let health: HealthCheckService;\n    let http: HttpHealthIndicator;\n    let typeOrm: TypeOrmHealthIndicator;\n    let redis: MicroserviceHealthIndicator;\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [TerminusModule, HttpModule],\n        controllers: [ReadinessController],\n        providers: [\n          {\n            provide: CONFIG_OPTIONS,\n            useValue: mockedConfig,\n          },\n        ],\n      }).compile();\n\n      controller = module.get&lt;ReadinessController&gt;(ReadinessController);\n      health = await module.resolve&lt;HealthCheckService&gt;(HealthCheckService);\n      http = await module.resolve&lt;HttpHealthIndicator&gt;(HttpHealthIndicator as any);\n      typeOrm = await module.resolve&lt;TypeOrmHealthIndicator&gt;(TypeOrmHealthIndicator);\n      redis = await module.resolve&lt;MicroserviceHealthIndicator&gt;(MicroserviceHealthIndicator);\n    });\n\n    it(&#x27;should be defined with extend config&#x27;, () =&gt; {\n      expect(controller).toBeDefined();\n    });\n\n    it(&#x27;should be return up services with extend config&#x27;, async () =&gt; {\n      http.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      typeOrm.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      redis.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      health.check = jest.fn().mockImplementation(() =&gt; mockExpectReadiness);\n\n      const readinessData = await controller.check();\n      expect(readinessData).toEqual(mockExpectReadiness);\n    });\n  });\n\n  describe(&#x27;Ready controller - simple config&#x27;, () =&gt; {\n    let controller: ReadinessController;\n    let health: HealthCheckService;\n    let http: HttpHealthIndicator;\n    let typeOrm: TypeOrmHealthIndicator;\n    let redis: MicroserviceHealthIndicator;\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [TerminusModule, HttpModule],\n        controllers: [ReadinessController],\n        providers: [\n          {\n            provide: CONFIG_OPTIONS,\n            useValue: simpleConfig,\n          },\n        ],\n      }).compile();\n\n      controller = module.get&lt;ReadinessController&gt;(ReadinessController);\n      health = await module.resolve&lt;HealthCheckService&gt;(HealthCheckService);\n      http = await module.resolve&lt;HttpHealthIndicator&gt;(HttpHealthIndicator as any);\n      typeOrm = await module.resolve&lt;TypeOrmHealthIndicator&gt;(TypeOrmHealthIndicator);\n      redis = await module.resolve&lt;MicroserviceHealthIndicator&gt;(MicroserviceHealthIndicator);\n    });\n\n    it(&#x27;should be defined with simple config&#x27;, () =&gt; {\n      expect(controller).toBeDefined();\n    });\n\n    it(&#x27;should be return up services with simple config&#x27;, async () =&gt; {\n      http.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      typeOrm.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      redis.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      health.check = jest.fn().mockImplementation(() =&gt; mockExpectReadiness);\n\n      const readinessData = await controller.check();\n      expect(readinessData).toEqual(mockExpectReadiness);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d3ae8575-54f8-4481-9fa8-856306a1b428&quot;,&quot;parentUUID&quot;:&quot;b2145cb6-7be5-4747-84cc-285b60b47f72&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Health &gt; Ready controller - simple config &gt; should be return up services with simple config&quot;,&quot;title&quot;:&quot;Health &gt; Ready controller - simple config &gt; should be return up services with simple config&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { HttpModule } from &#x27;@nestjs/axios&#x27;;\nimport {\n  HealthCheckService,\n  HttpHealthIndicator,\n  TerminusModule,\n  TypeOrmHealthIndicator,\n  MicroserviceHealthIndicator,\n} from &#x27;@nestjs/terminus&#x27;;\n\nimport { ReadinessController } from &#x27;../health/controllers/readiness.controller&#x27;;\nimport { CONFIG_OPTIONS } from &#x27;../health/constants&#x27;;\n\nconst mockedConfig = {\n  services: {\n    myService: {\n      url: &#x27;http://localhost:8082&#x27;,\n      timeout: 3000,\n    },\n    demoApi: {\n      url: &#x27;https://nestjs-starter.up.railway.app&#x27;,\n      timeout: 3000,\n      healthPath: &#x27;/v1/health/liveness&#x27;,\n    },\n  },\n  database: {\n    typeorm: {\n      type: &#x27;postgres&#x27;,\n    },\n  },\n  redis: {\n    host: &#x27;localhost&#x27;,\n    port: 6379,\n  },\n  elasticsearch: {\n    name: &#x27;test-app&#x27;,\n    node: &#x27;http://localhost:9200&#x27;,\n  },\n  camunda: {\n    baseUrl: &#x27;http://localhost:8080/engine-rest&#x27;,\n  },\n};\n\nconst mockExpectReadiness = {\n  status: &#x27;ok&#x27;,\n  info: {\n    myService: {\n      status: &#x27;up&#x27;,\n    },\n    typeOrm: {\n      status: &#x27;up&#x27;,\n    },\n    redis: {\n      status: &#x27;up&#x27;,\n    },\n    elasticsearch: {\n      status: &#x27;up&#x27;,\n    },\n    camunda: {\n      status: &#x27;up&#x27;,\n    },\n  },\n  error: {},\n  details: {\n    myService: {\n      status: &#x27;up&#x27;,\n    },\n    typeOrm: {\n      status: &#x27;up&#x27;,\n    },\n    redis: {\n      status: &#x27;up&#x27;,\n    },\n    elasticsearch: {\n      status: &#x27;up&#x27;,\n    },\n    camunda: {\n      status: &#x27;up&#x27;,\n    },\n  },\n};\n\nconst mockExpectReadinessDown = {\n  myService: {\n    status: &#x27;down&#x27;,\n    message: &#x27;connect ECONNREFUSED 127.0.0.1:8082&#x27;,\n  },\n};\n\nconst simpleConfig = {\n  services: {\n    myService: { url: &#x27;http://localhost:8082&#x27; },\n  },\n};\n\ndescribe(&#x27;Health&#x27;, () =&gt; {\n  describe(&#x27;Ready controller - extend config&#x27;, () =&gt; {\n    let controller: ReadinessController;\n    let health: HealthCheckService;\n    let http: HttpHealthIndicator;\n    let typeOrm: TypeOrmHealthIndicator;\n    let redis: MicroserviceHealthIndicator;\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [TerminusModule, HttpModule],\n        controllers: [ReadinessController],\n        providers: [\n          {\n            provide: CONFIG_OPTIONS,\n            useValue: mockedConfig,\n          },\n        ],\n      }).compile();\n\n      controller = module.get&lt;ReadinessController&gt;(ReadinessController);\n      health = await module.resolve&lt;HealthCheckService&gt;(HealthCheckService);\n      http = await module.resolve&lt;HttpHealthIndicator&gt;(HttpHealthIndicator as any);\n      typeOrm = await module.resolve&lt;TypeOrmHealthIndicator&gt;(TypeOrmHealthIndicator);\n      redis = await module.resolve&lt;MicroserviceHealthIndicator&gt;(MicroserviceHealthIndicator);\n    });\n\n    it(&#x27;should be defined with extend config&#x27;, () =&gt; {\n      expect(controller).toBeDefined();\n    });\n\n    it(&#x27;should be return up services with extend config&#x27;, async () =&gt; {\n      http.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      typeOrm.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      redis.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      health.check = jest.fn().mockImplementation(() =&gt; mockExpectReadiness);\n\n      const readinessData = await controller.check();\n      expect(readinessData).toEqual(mockExpectReadiness);\n    });\n  });\n\n  describe(&#x27;Ready controller - simple config&#x27;, () =&gt; {\n    let controller: ReadinessController;\n    let health: HealthCheckService;\n    let http: HttpHealthIndicator;\n    let typeOrm: TypeOrmHealthIndicator;\n    let redis: MicroserviceHealthIndicator;\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [TerminusModule, HttpModule],\n        controllers: [ReadinessController],\n        providers: [\n          {\n            provide: CONFIG_OPTIONS,\n            useValue: simpleConfig,\n          },\n        ],\n      }).compile();\n\n      controller = module.get&lt;ReadinessController&gt;(ReadinessController);\n      health = await module.resolve&lt;HealthCheckService&gt;(HealthCheckService);\n      http = await module.resolve&lt;HttpHealthIndicator&gt;(HttpHealthIndicator as any);\n      typeOrm = await module.resolve&lt;TypeOrmHealthIndicator&gt;(TypeOrmHealthIndicator);\n      redis = await module.resolve&lt;MicroserviceHealthIndicator&gt;(MicroserviceHealthIndicator);\n    });\n\n    it(&#x27;should be defined with simple config&#x27;, () =&gt; {\n      expect(controller).toBeDefined();\n    });\n\n    it(&#x27;should be return up services with simple config&#x27;, async () =&gt; {\n      http.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      typeOrm.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      redis.pingCheck = jest.fn().mockImplementation(() =&gt; mockExpectReadiness.info);\n      health.check = jest.fn().mockImplementation(() =&gt; mockExpectReadiness);\n\n      const readinessData = await controller.check();\n      expect(readinessData).toEqual(mockExpectReadiness);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e09a906e-72d3-4246-8ddc-e41080cc259c&quot;,&quot;parentUUID&quot;:&quot;b2145cb6-7be5-4747-84cc-285b60b47f72&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;HealthModule &gt; should be define&quot;,&quot;title&quot;:&quot;HealthModule &gt; should be define&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:548,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport { config } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\n\nimport { HealthModule } from &#x27;../health/health.module&#x27;;\nimport { LivenessController } from &#x27;../health/controllers/liveness.controller&#x27;;\nimport { ReadinessController } from &#x27;../health/controllers/readiness.controller&#x27;;\n\ndescribe(&#x27;HealthModule&#x27;, () =&gt; {\n  let app: INestApplication;\n  let livenessController: LivenessController;\n  let readinessController: ReadinessController;\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HealthModule,\n      ],\n    }).compile();\n\n    app = module.createNestApplication();\n    livenessController = module.get&lt;LivenessController&gt;(LivenessController);\n    readinessController = module.get&lt;ReadinessController&gt;(ReadinessController);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await Promise.all([app.close()]);\n  });\n\n  it(&#x27;should be define&#x27;, async () =&gt; {\n    expect(app).toBeDefined();\n  });\n\n  it(&#x27;should be return status up&#x27;, async () =&gt; {\n    expect(livenessController.getLiveness()).toEqual({ status: &#x27;up&#x27; });\n  });\n\n  it(&#x27;should be return readiness services&#x27;, async () =&gt; {\n    const result = await readinessController.check();\n    expect(result).toHaveProperty(&#x27;details&#x27;);\n    expect(result).toHaveProperty(&#x27;error&#x27;);\n    expect(result).toHaveProperty(&#x27;info&#x27;);\n    expect(result).toHaveProperty(&#x27;status&#x27;);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1cacbe83-279c-4b45-bb77-5b81a6a77ddc&quot;,&quot;parentUUID&quot;:&quot;b2145cb6-7be5-4747-84cc-285b60b47f72&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;HealthModule &gt; should be return status up&quot;,&quot;title&quot;:&quot;HealthModule &gt; should be return status up&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport { config } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\n\nimport { HealthModule } from &#x27;../health/health.module&#x27;;\nimport { LivenessController } from &#x27;../health/controllers/liveness.controller&#x27;;\nimport { ReadinessController } from &#x27;../health/controllers/readiness.controller&#x27;;\n\ndescribe(&#x27;HealthModule&#x27;, () =&gt; {\n  let app: INestApplication;\n  let livenessController: LivenessController;\n  let readinessController: ReadinessController;\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HealthModule,\n      ],\n    }).compile();\n\n    app = module.createNestApplication();\n    livenessController = module.get&lt;LivenessController&gt;(LivenessController);\n    readinessController = module.get&lt;ReadinessController&gt;(ReadinessController);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await Promise.all([app.close()]);\n  });\n\n  it(&#x27;should be define&#x27;, async () =&gt; {\n    expect(app).toBeDefined();\n  });\n\n  it(&#x27;should be return status up&#x27;, async () =&gt; {\n    expect(livenessController.getLiveness()).toEqual({ status: &#x27;up&#x27; });\n  });\n\n  it(&#x27;should be return readiness services&#x27;, async () =&gt; {\n    const result = await readinessController.check();\n    expect(result).toHaveProperty(&#x27;details&#x27;);\n    expect(result).toHaveProperty(&#x27;error&#x27;);\n    expect(result).toHaveProperty(&#x27;info&#x27;);\n    expect(result).toHaveProperty(&#x27;status&#x27;);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;810b7dfc-b80f-4be8-9122-9579f9b0016c&quot;,&quot;parentUUID&quot;:&quot;b2145cb6-7be5-4747-84cc-285b60b47f72&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;HealthModule &gt; should be return readiness services&quot;,&quot;title&quot;:&quot;HealthModule &gt; should be return readiness services&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:461,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport { config } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\n\nimport { HealthModule } from &#x27;../health/health.module&#x27;;\nimport { LivenessController } from &#x27;../health/controllers/liveness.controller&#x27;;\nimport { ReadinessController } from &#x27;../health/controllers/readiness.controller&#x27;;\n\ndescribe(&#x27;HealthModule&#x27;, () =&gt; {\n  let app: INestApplication;\n  let livenessController: LivenessController;\n  let readinessController: ReadinessController;\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HealthModule,\n      ],\n    }).compile();\n\n    app = module.createNestApplication();\n    livenessController = module.get&lt;LivenessController&gt;(LivenessController);\n    readinessController = module.get&lt;ReadinessController&gt;(ReadinessController);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await Promise.all([app.close()]);\n  });\n\n  it(&#x27;should be define&#x27;, async () =&gt; {\n    expect(app).toBeDefined();\n  });\n\n  it(&#x27;should be return status up&#x27;, async () =&gt; {\n    expect(livenessController.getLiveness()).toEqual({ status: &#x27;up&#x27; });\n  });\n\n  it(&#x27;should be return readiness services&#x27;, async () =&gt; {\n    const result = await readinessController.check();\n    expect(result).toHaveProperty(&#x27;details&#x27;);\n    expect(result).toHaveProperty(&#x27;error&#x27;);\n    expect(result).toHaveProperty(&#x27;info&#x27;);\n    expect(result).toHaveProperty(&#x27;status&#x27;);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;12f6f649-052b-45f9-87a4-1a72ded1d762&quot;,&quot;parentUUID&quot;:&quot;b2145cb6-7be5-4747-84cc-285b60b47f72&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Health - Live controller &gt; should be defined&quot;,&quot;title&quot;:&quot;Health - Live controller &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { LivenessController } from &#x27;../health/controllers/liveness.controller&#x27;;\n\ndescribe(&#x27;Health - Live controller&#x27;, () =&gt; {\n  let controller: LivenessController;\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      controllers: [LivenessController],\n    }).compile();\n\n    controller = module.get&lt;LivenessController&gt;(LivenessController);\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(controller).toBeDefined();\n  });\n\n  it(&#x27;should be return up liveness&#x27;, () =&gt; {\n    expect(controller.getLiveness()).toEqual({ status: &#x27;up&#x27; });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;075e4b39-7308-45ae-91ad-d0149c497523&quot;,&quot;parentUUID&quot;:&quot;b2145cb6-7be5-4747-84cc-285b60b47f72&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Health - Live controller &gt; should be return up liveness&quot;,&quot;title&quot;:&quot;Health - Live controller &gt; should be return up liveness&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { LivenessController } from &#x27;../health/controllers/liveness.controller&#x27;;\n\ndescribe(&#x27;Health - Live controller&#x27;, () =&gt; {\n  let controller: LivenessController;\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      controllers: [LivenessController],\n    }).compile();\n\n    controller = module.get&lt;LivenessController&gt;(LivenessController);\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(controller).toBeDefined();\n  });\n\n  it(&#x27;should be return up liveness&#x27;, () =&gt; {\n    expect(controller.getLiveness()).toEqual({ status: &#x27;up&#x27; });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;0719a904-d955-4784-97f9-93b0865ec190&quot;,&quot;parentUUID&quot;:&quot;b2145cb6-7be5-4747-84cc-285b60b47f72&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;healthConstants &gt; should be return exclude to prefix global&quot;,&quot;title&quot;:&quot;healthConstants &gt; should be return exclude to prefix global&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { RequestMethod } from &#x27;@nestjs/common&#x27;;\nimport { controllersExcludes } from &#x27;../health/constants&#x27;;\n\ndescribe(&#x27;healthConstants&#x27;, () =&gt; {\n  it(&#x27;should be return exclude to prefix global&#x27;, async () =&gt; {\n    expect(controllersExcludes).toEqual(expect.any(Array));\n    expect(controllersExcludes).toMatchObject([\n      {\n        path: &#x27;/health/liveness&#x27;,\n        method: RequestMethod.GET,\n      },\n      {\n        path: &#x27;/health/readiness&#x27;,\n        method: RequestMethod.GET,\n      },\n    ]);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;67a0d58c-202a-4ecd-a39e-d23a50105863&quot;,&quot;parentUUID&quot;:&quot;b2145cb6-7be5-4747-84cc-285b60b47f72&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;75976538-41b0-4d80-b8ae-b2d5408647e1&quot;,&quot;5c6ae31a-632a-487a-8cee-8a70c81837e1&quot;,&quot;d3ae8575-54f8-4481-9fa8-856306a1b428&quot;,&quot;e09a906e-72d3-4246-8ddc-e41080cc259c&quot;,&quot;1cacbe83-279c-4b45-bb77-5b81a6a77ddc&quot;,&quot;810b7dfc-b80f-4be8-9122-9579f9b0016c&quot;,&quot;12f6f649-052b-45f9-87a4-1a72ded1d762&quot;,&quot;075e4b39-7308-45ae-91ad-d0149c497523&quot;,&quot;0719a904-d955-4784-97f9-93b0865ec190&quot;,&quot;67a0d58c-202a-4ecd-a39e-d23a50105863&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:1809,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:5000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:5000},{&quot;uuid&quot;:&quot;0fb8adf6-07d2-45ee-8254-64903da372e9&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/http-client&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;24319c5d-6917-47c5-98ff-d0f61875e522&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/http-client&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;fullTitle&quot;:&quot;HttpService &gt; should be defined&quot;,&quot;title&quot;:&quot;HttpService &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:142,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule, ConfigService } from &#x27;@nestjs/config&#x27;;\n\nimport { HttpClientService } from &#x27;../http/services/httpClient.service&#x27;;\nimport { HttpClientModule } from &#x27;../http/httpClient.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\n\nconst API_NESTJS_STARTER = &#x27;https://jsonplaceholder.typicode.com&#x27;;\n\nconst mockRequestBody = {\n  userId: 1,\n  id: 1,\n  title: &#x27;sunt aut facere repellat provident occaecati excepturi optio reprehenderit&#x27;,\n  body: &#x27;quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto&#x27;,\n};\n\ndescribe(&#x27;HttpService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let service: HttpClientService;\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HttpClientModule.registerAsync({\n          imports: [ConfigModule],\n          useFactory: async (configService: ConfigService) =&gt;\n            configService.get(&#x27;config.httpOptions&#x27;),\n          inject: [ConfigService],\n        }),\n      ],\n    }).compile();\n    app = module.createNestApplication();\n    await app.init;\n    service = module.get&lt;HttpClientService&gt;(HttpClientService);\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(service).toBeDefined();\n    expect(service).toBeInstanceOf(HttpClientService);\n    expect(service.axiosRef).not.toBeNull();\n  });\n\n  it(&#x27;should be return status 200 - request&#x27;, async () =&gt; {\n    const { status, data } = await service.request({\n      url: `${API_NESTJS_STARTER}/posts`,\n      method: &#x27;GET&#x27;,\n    });\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 200 - get&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 201 - post&#x27;, async () =&gt; {\n    const { status, data } = await service.post(`${API_NESTJS_STARTER}/posts`, {\n      data: mockRequestBody,\n    });\n    expect(status).toBe(201);\n    expect(data).toEqual({\n      ...mockRequestBody,\n      id: 101,\n    });\n  });\n\n  it(&#x27;should be return status 200 - get by id&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts/1`);\n    expect(status).toBe(200);\n    expect(data).toEqual(mockRequestBody);\n  });\n\n  it(&#x27;should be return status 200 - put&#x27;, async () =&gt; {\n    const { status, data } = await service.put(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - delete&#x27;, async () =&gt; {\n    const { status, data } = await service.delete(`${API_NESTJS_STARTER}/posts/2`);\n    expect(status).toBe(200);\n    expect(data).toEqual({});\n  });\n\n  it(&#x27;should be return status 200 - patch&#x27;, async () =&gt; {\n    const { status, data } = await service.patch(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - head&#x27;, async () =&gt; {\n    const { status, headers } = await service.head(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(headers).toHaveProperty(&#x27;etag&#x27;);\n  });\n\n  it(&#x27;should be return error&#x27;, async () =&gt; {\n    try {\n      const { data } = await service.get(`${API_NESTJS_STARTER}/postss`);\n      expect(data).toBe(200);\n    } catch (error) {\n      expect(error.response.status).toBe(404);\n      expect(error.message).toBe(&#x27;Request failed with status code 404&#x27;);\n    }\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;18e7b96f-3b1f-405d-988f-aacbc003be53&quot;,&quot;parentUUID&quot;:&quot;24319c5d-6917-47c5-98ff-d0f61875e522&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;HttpService &gt; should be return status 200 - request&quot;,&quot;title&quot;:&quot;HttpService &gt; should be return status 200 - request&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:544,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule, ConfigService } from &#x27;@nestjs/config&#x27;;\n\nimport { HttpClientService } from &#x27;../http/services/httpClient.service&#x27;;\nimport { HttpClientModule } from &#x27;../http/httpClient.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\n\nconst API_NESTJS_STARTER = &#x27;https://jsonplaceholder.typicode.com&#x27;;\n\nconst mockRequestBody = {\n  userId: 1,\n  id: 1,\n  title: &#x27;sunt aut facere repellat provident occaecati excepturi optio reprehenderit&#x27;,\n  body: &#x27;quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto&#x27;,\n};\n\ndescribe(&#x27;HttpService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let service: HttpClientService;\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HttpClientModule.registerAsync({\n          imports: [ConfigModule],\n          useFactory: async (configService: ConfigService) =&gt;\n            configService.get(&#x27;config.httpOptions&#x27;),\n          inject: [ConfigService],\n        }),\n      ],\n    }).compile();\n    app = module.createNestApplication();\n    await app.init;\n    service = module.get&lt;HttpClientService&gt;(HttpClientService);\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(service).toBeDefined();\n    expect(service).toBeInstanceOf(HttpClientService);\n    expect(service.axiosRef).not.toBeNull();\n  });\n\n  it(&#x27;should be return status 200 - request&#x27;, async () =&gt; {\n    const { status, data } = await service.request({\n      url: `${API_NESTJS_STARTER}/posts`,\n      method: &#x27;GET&#x27;,\n    });\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 200 - get&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 201 - post&#x27;, async () =&gt; {\n    const { status, data } = await service.post(`${API_NESTJS_STARTER}/posts`, {\n      data: mockRequestBody,\n    });\n    expect(status).toBe(201);\n    expect(data).toEqual({\n      ...mockRequestBody,\n      id: 101,\n    });\n  });\n\n  it(&#x27;should be return status 200 - get by id&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts/1`);\n    expect(status).toBe(200);\n    expect(data).toEqual(mockRequestBody);\n  });\n\n  it(&#x27;should be return status 200 - put&#x27;, async () =&gt; {\n    const { status, data } = await service.put(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - delete&#x27;, async () =&gt; {\n    const { status, data } = await service.delete(`${API_NESTJS_STARTER}/posts/2`);\n    expect(status).toBe(200);\n    expect(data).toEqual({});\n  });\n\n  it(&#x27;should be return status 200 - patch&#x27;, async () =&gt; {\n    const { status, data } = await service.patch(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - head&#x27;, async () =&gt; {\n    const { status, headers } = await service.head(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(headers).toHaveProperty(&#x27;etag&#x27;);\n  });\n\n  it(&#x27;should be return error&#x27;, async () =&gt; {\n    try {\n      const { data } = await service.get(`${API_NESTJS_STARTER}/postss`);\n      expect(data).toBe(200);\n    } catch (error) {\n      expect(error.response.status).toBe(404);\n      expect(error.message).toBe(&#x27;Request failed with status code 404&#x27;);\n    }\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ca71b7a7-b92a-4cf6-9f55-5de56c44713f&quot;,&quot;parentUUID&quot;:&quot;24319c5d-6917-47c5-98ff-d0f61875e522&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;HttpService &gt; should be return status 200 - get&quot;,&quot;title&quot;:&quot;HttpService &gt; should be return status 200 - get&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:468,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule, ConfigService } from &#x27;@nestjs/config&#x27;;\n\nimport { HttpClientService } from &#x27;../http/services/httpClient.service&#x27;;\nimport { HttpClientModule } from &#x27;../http/httpClient.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\n\nconst API_NESTJS_STARTER = &#x27;https://jsonplaceholder.typicode.com&#x27;;\n\nconst mockRequestBody = {\n  userId: 1,\n  id: 1,\n  title: &#x27;sunt aut facere repellat provident occaecati excepturi optio reprehenderit&#x27;,\n  body: &#x27;quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto&#x27;,\n};\n\ndescribe(&#x27;HttpService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let service: HttpClientService;\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HttpClientModule.registerAsync({\n          imports: [ConfigModule],\n          useFactory: async (configService: ConfigService) =&gt;\n            configService.get(&#x27;config.httpOptions&#x27;),\n          inject: [ConfigService],\n        }),\n      ],\n    }).compile();\n    app = module.createNestApplication();\n    await app.init;\n    service = module.get&lt;HttpClientService&gt;(HttpClientService);\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(service).toBeDefined();\n    expect(service).toBeInstanceOf(HttpClientService);\n    expect(service.axiosRef).not.toBeNull();\n  });\n\n  it(&#x27;should be return status 200 - request&#x27;, async () =&gt; {\n    const { status, data } = await service.request({\n      url: `${API_NESTJS_STARTER}/posts`,\n      method: &#x27;GET&#x27;,\n    });\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 200 - get&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 201 - post&#x27;, async () =&gt; {\n    const { status, data } = await service.post(`${API_NESTJS_STARTER}/posts`, {\n      data: mockRequestBody,\n    });\n    expect(status).toBe(201);\n    expect(data).toEqual({\n      ...mockRequestBody,\n      id: 101,\n    });\n  });\n\n  it(&#x27;should be return status 200 - get by id&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts/1`);\n    expect(status).toBe(200);\n    expect(data).toEqual(mockRequestBody);\n  });\n\n  it(&#x27;should be return status 200 - put&#x27;, async () =&gt; {\n    const { status, data } = await service.put(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - delete&#x27;, async () =&gt; {\n    const { status, data } = await service.delete(`${API_NESTJS_STARTER}/posts/2`);\n    expect(status).toBe(200);\n    expect(data).toEqual({});\n  });\n\n  it(&#x27;should be return status 200 - patch&#x27;, async () =&gt; {\n    const { status, data } = await service.patch(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - head&#x27;, async () =&gt; {\n    const { status, headers } = await service.head(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(headers).toHaveProperty(&#x27;etag&#x27;);\n  });\n\n  it(&#x27;should be return error&#x27;, async () =&gt; {\n    try {\n      const { data } = await service.get(`${API_NESTJS_STARTER}/postss`);\n      expect(data).toBe(200);\n    } catch (error) {\n      expect(error.response.status).toBe(404);\n      expect(error.message).toBe(&#x27;Request failed with status code 404&#x27;);\n    }\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;472578f1-2697-4018-8a00-535a6d800921&quot;,&quot;parentUUID&quot;:&quot;24319c5d-6917-47c5-98ff-d0f61875e522&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;HttpService &gt; should be return status 201 - post&quot;,&quot;title&quot;:&quot;HttpService &gt; should be return status 201 - post&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:531,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule, ConfigService } from &#x27;@nestjs/config&#x27;;\n\nimport { HttpClientService } from &#x27;../http/services/httpClient.service&#x27;;\nimport { HttpClientModule } from &#x27;../http/httpClient.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\n\nconst API_NESTJS_STARTER = &#x27;https://jsonplaceholder.typicode.com&#x27;;\n\nconst mockRequestBody = {\n  userId: 1,\n  id: 1,\n  title: &#x27;sunt aut facere repellat provident occaecati excepturi optio reprehenderit&#x27;,\n  body: &#x27;quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto&#x27;,\n};\n\ndescribe(&#x27;HttpService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let service: HttpClientService;\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HttpClientModule.registerAsync({\n          imports: [ConfigModule],\n          useFactory: async (configService: ConfigService) =&gt;\n            configService.get(&#x27;config.httpOptions&#x27;),\n          inject: [ConfigService],\n        }),\n      ],\n    }).compile();\n    app = module.createNestApplication();\n    await app.init;\n    service = module.get&lt;HttpClientService&gt;(HttpClientService);\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(service).toBeDefined();\n    expect(service).toBeInstanceOf(HttpClientService);\n    expect(service.axiosRef).not.toBeNull();\n  });\n\n  it(&#x27;should be return status 200 - request&#x27;, async () =&gt; {\n    const { status, data } = await service.request({\n      url: `${API_NESTJS_STARTER}/posts`,\n      method: &#x27;GET&#x27;,\n    });\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 200 - get&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 201 - post&#x27;, async () =&gt; {\n    const { status, data } = await service.post(`${API_NESTJS_STARTER}/posts`, {\n      data: mockRequestBody,\n    });\n    expect(status).toBe(201);\n    expect(data).toEqual({\n      ...mockRequestBody,\n      id: 101,\n    });\n  });\n\n  it(&#x27;should be return status 200 - get by id&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts/1`);\n    expect(status).toBe(200);\n    expect(data).toEqual(mockRequestBody);\n  });\n\n  it(&#x27;should be return status 200 - put&#x27;, async () =&gt; {\n    const { status, data } = await service.put(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - delete&#x27;, async () =&gt; {\n    const { status, data } = await service.delete(`${API_NESTJS_STARTER}/posts/2`);\n    expect(status).toBe(200);\n    expect(data).toEqual({});\n  });\n\n  it(&#x27;should be return status 200 - patch&#x27;, async () =&gt; {\n    const { status, data } = await service.patch(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - head&#x27;, async () =&gt; {\n    const { status, headers } = await service.head(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(headers).toHaveProperty(&#x27;etag&#x27;);\n  });\n\n  it(&#x27;should be return error&#x27;, async () =&gt; {\n    try {\n      const { data } = await service.get(`${API_NESTJS_STARTER}/postss`);\n      expect(data).toBe(200);\n    } catch (error) {\n      expect(error.response.status).toBe(404);\n      expect(error.message).toBe(&#x27;Request failed with status code 404&#x27;);\n    }\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1a2bfeca-9820-4833-b20c-77e9f54cd118&quot;,&quot;parentUUID&quot;:&quot;24319c5d-6917-47c5-98ff-d0f61875e522&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;HttpService &gt; should be return status 200 - get by id&quot;,&quot;title&quot;:&quot;HttpService &gt; should be return status 200 - get by id&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:519,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule, ConfigService } from &#x27;@nestjs/config&#x27;;\n\nimport { HttpClientService } from &#x27;../http/services/httpClient.service&#x27;;\nimport { HttpClientModule } from &#x27;../http/httpClient.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\n\nconst API_NESTJS_STARTER = &#x27;https://jsonplaceholder.typicode.com&#x27;;\n\nconst mockRequestBody = {\n  userId: 1,\n  id: 1,\n  title: &#x27;sunt aut facere repellat provident occaecati excepturi optio reprehenderit&#x27;,\n  body: &#x27;quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto&#x27;,\n};\n\ndescribe(&#x27;HttpService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let service: HttpClientService;\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HttpClientModule.registerAsync({\n          imports: [ConfigModule],\n          useFactory: async (configService: ConfigService) =&gt;\n            configService.get(&#x27;config.httpOptions&#x27;),\n          inject: [ConfigService],\n        }),\n      ],\n    }).compile();\n    app = module.createNestApplication();\n    await app.init;\n    service = module.get&lt;HttpClientService&gt;(HttpClientService);\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(service).toBeDefined();\n    expect(service).toBeInstanceOf(HttpClientService);\n    expect(service.axiosRef).not.toBeNull();\n  });\n\n  it(&#x27;should be return status 200 - request&#x27;, async () =&gt; {\n    const { status, data } = await service.request({\n      url: `${API_NESTJS_STARTER}/posts`,\n      method: &#x27;GET&#x27;,\n    });\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 200 - get&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 201 - post&#x27;, async () =&gt; {\n    const { status, data } = await service.post(`${API_NESTJS_STARTER}/posts`, {\n      data: mockRequestBody,\n    });\n    expect(status).toBe(201);\n    expect(data).toEqual({\n      ...mockRequestBody,\n      id: 101,\n    });\n  });\n\n  it(&#x27;should be return status 200 - get by id&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts/1`);\n    expect(status).toBe(200);\n    expect(data).toEqual(mockRequestBody);\n  });\n\n  it(&#x27;should be return status 200 - put&#x27;, async () =&gt; {\n    const { status, data } = await service.put(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - delete&#x27;, async () =&gt; {\n    const { status, data } = await service.delete(`${API_NESTJS_STARTER}/posts/2`);\n    expect(status).toBe(200);\n    expect(data).toEqual({});\n  });\n\n  it(&#x27;should be return status 200 - patch&#x27;, async () =&gt; {\n    const { status, data } = await service.patch(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - head&#x27;, async () =&gt; {\n    const { status, headers } = await service.head(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(headers).toHaveProperty(&#x27;etag&#x27;);\n  });\n\n  it(&#x27;should be return error&#x27;, async () =&gt; {\n    try {\n      const { data } = await service.get(`${API_NESTJS_STARTER}/postss`);\n      expect(data).toBe(200);\n    } catch (error) {\n      expect(error.response.status).toBe(404);\n      expect(error.message).toBe(&#x27;Request failed with status code 404&#x27;);\n    }\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;765e9f24-3edb-4538-9315-03a37b2d57d5&quot;,&quot;parentUUID&quot;:&quot;24319c5d-6917-47c5-98ff-d0f61875e522&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;HttpService &gt; should be return status 200 - put&quot;,&quot;title&quot;:&quot;HttpService &gt; should be return status 200 - put&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:549,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule, ConfigService } from &#x27;@nestjs/config&#x27;;\n\nimport { HttpClientService } from &#x27;../http/services/httpClient.service&#x27;;\nimport { HttpClientModule } from &#x27;../http/httpClient.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\n\nconst API_NESTJS_STARTER = &#x27;https://jsonplaceholder.typicode.com&#x27;;\n\nconst mockRequestBody = {\n  userId: 1,\n  id: 1,\n  title: &#x27;sunt aut facere repellat provident occaecati excepturi optio reprehenderit&#x27;,\n  body: &#x27;quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto&#x27;,\n};\n\ndescribe(&#x27;HttpService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let service: HttpClientService;\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HttpClientModule.registerAsync({\n          imports: [ConfigModule],\n          useFactory: async (configService: ConfigService) =&gt;\n            configService.get(&#x27;config.httpOptions&#x27;),\n          inject: [ConfigService],\n        }),\n      ],\n    }).compile();\n    app = module.createNestApplication();\n    await app.init;\n    service = module.get&lt;HttpClientService&gt;(HttpClientService);\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(service).toBeDefined();\n    expect(service).toBeInstanceOf(HttpClientService);\n    expect(service.axiosRef).not.toBeNull();\n  });\n\n  it(&#x27;should be return status 200 - request&#x27;, async () =&gt; {\n    const { status, data } = await service.request({\n      url: `${API_NESTJS_STARTER}/posts`,\n      method: &#x27;GET&#x27;,\n    });\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 200 - get&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 201 - post&#x27;, async () =&gt; {\n    const { status, data } = await service.post(`${API_NESTJS_STARTER}/posts`, {\n      data: mockRequestBody,\n    });\n    expect(status).toBe(201);\n    expect(data).toEqual({\n      ...mockRequestBody,\n      id: 101,\n    });\n  });\n\n  it(&#x27;should be return status 200 - get by id&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts/1`);\n    expect(status).toBe(200);\n    expect(data).toEqual(mockRequestBody);\n  });\n\n  it(&#x27;should be return status 200 - put&#x27;, async () =&gt; {\n    const { status, data } = await service.put(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - delete&#x27;, async () =&gt; {\n    const { status, data } = await service.delete(`${API_NESTJS_STARTER}/posts/2`);\n    expect(status).toBe(200);\n    expect(data).toEqual({});\n  });\n\n  it(&#x27;should be return status 200 - patch&#x27;, async () =&gt; {\n    const { status, data } = await service.patch(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - head&#x27;, async () =&gt; {\n    const { status, headers } = await service.head(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(headers).toHaveProperty(&#x27;etag&#x27;);\n  });\n\n  it(&#x27;should be return error&#x27;, async () =&gt; {\n    try {\n      const { data } = await service.get(`${API_NESTJS_STARTER}/postss`);\n      expect(data).toBe(200);\n    } catch (error) {\n      expect(error.response.status).toBe(404);\n      expect(error.message).toBe(&#x27;Request failed with status code 404&#x27;);\n    }\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;bf369938-3c8d-4dfb-9cb2-d6f0730fcd2a&quot;,&quot;parentUUID&quot;:&quot;24319c5d-6917-47c5-98ff-d0f61875e522&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;HttpService &gt; should be return status 200 - delete&quot;,&quot;title&quot;:&quot;HttpService &gt; should be return status 200 - delete&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:523,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule, ConfigService } from &#x27;@nestjs/config&#x27;;\n\nimport { HttpClientService } from &#x27;../http/services/httpClient.service&#x27;;\nimport { HttpClientModule } from &#x27;../http/httpClient.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\n\nconst API_NESTJS_STARTER = &#x27;https://jsonplaceholder.typicode.com&#x27;;\n\nconst mockRequestBody = {\n  userId: 1,\n  id: 1,\n  title: &#x27;sunt aut facere repellat provident occaecati excepturi optio reprehenderit&#x27;,\n  body: &#x27;quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto&#x27;,\n};\n\ndescribe(&#x27;HttpService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let service: HttpClientService;\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HttpClientModule.registerAsync({\n          imports: [ConfigModule],\n          useFactory: async (configService: ConfigService) =&gt;\n            configService.get(&#x27;config.httpOptions&#x27;),\n          inject: [ConfigService],\n        }),\n      ],\n    }).compile();\n    app = module.createNestApplication();\n    await app.init;\n    service = module.get&lt;HttpClientService&gt;(HttpClientService);\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(service).toBeDefined();\n    expect(service).toBeInstanceOf(HttpClientService);\n    expect(service.axiosRef).not.toBeNull();\n  });\n\n  it(&#x27;should be return status 200 - request&#x27;, async () =&gt; {\n    const { status, data } = await service.request({\n      url: `${API_NESTJS_STARTER}/posts`,\n      method: &#x27;GET&#x27;,\n    });\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 200 - get&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 201 - post&#x27;, async () =&gt; {\n    const { status, data } = await service.post(`${API_NESTJS_STARTER}/posts`, {\n      data: mockRequestBody,\n    });\n    expect(status).toBe(201);\n    expect(data).toEqual({\n      ...mockRequestBody,\n      id: 101,\n    });\n  });\n\n  it(&#x27;should be return status 200 - get by id&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts/1`);\n    expect(status).toBe(200);\n    expect(data).toEqual(mockRequestBody);\n  });\n\n  it(&#x27;should be return status 200 - put&#x27;, async () =&gt; {\n    const { status, data } = await service.put(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - delete&#x27;, async () =&gt; {\n    const { status, data } = await service.delete(`${API_NESTJS_STARTER}/posts/2`);\n    expect(status).toBe(200);\n    expect(data).toEqual({});\n  });\n\n  it(&#x27;should be return status 200 - patch&#x27;, async () =&gt; {\n    const { status, data } = await service.patch(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - head&#x27;, async () =&gt; {\n    const { status, headers } = await service.head(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(headers).toHaveProperty(&#x27;etag&#x27;);\n  });\n\n  it(&#x27;should be return error&#x27;, async () =&gt; {\n    try {\n      const { data } = await service.get(`${API_NESTJS_STARTER}/postss`);\n      expect(data).toBe(200);\n    } catch (error) {\n      expect(error.response.status).toBe(404);\n      expect(error.message).toBe(&#x27;Request failed with status code 404&#x27;);\n    }\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;34b844bf-3aa3-41d5-a99a-c34b29577a39&quot;,&quot;parentUUID&quot;:&quot;24319c5d-6917-47c5-98ff-d0f61875e522&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;HttpService &gt; should be return status 200 - patch&quot;,&quot;title&quot;:&quot;HttpService &gt; should be return status 200 - patch&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:759,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule, ConfigService } from &#x27;@nestjs/config&#x27;;\n\nimport { HttpClientService } from &#x27;../http/services/httpClient.service&#x27;;\nimport { HttpClientModule } from &#x27;../http/httpClient.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\n\nconst API_NESTJS_STARTER = &#x27;https://jsonplaceholder.typicode.com&#x27;;\n\nconst mockRequestBody = {\n  userId: 1,\n  id: 1,\n  title: &#x27;sunt aut facere repellat provident occaecati excepturi optio reprehenderit&#x27;,\n  body: &#x27;quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto&#x27;,\n};\n\ndescribe(&#x27;HttpService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let service: HttpClientService;\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HttpClientModule.registerAsync({\n          imports: [ConfigModule],\n          useFactory: async (configService: ConfigService) =&gt;\n            configService.get(&#x27;config.httpOptions&#x27;),\n          inject: [ConfigService],\n        }),\n      ],\n    }).compile();\n    app = module.createNestApplication();\n    await app.init;\n    service = module.get&lt;HttpClientService&gt;(HttpClientService);\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(service).toBeDefined();\n    expect(service).toBeInstanceOf(HttpClientService);\n    expect(service.axiosRef).not.toBeNull();\n  });\n\n  it(&#x27;should be return status 200 - request&#x27;, async () =&gt; {\n    const { status, data } = await service.request({\n      url: `${API_NESTJS_STARTER}/posts`,\n      method: &#x27;GET&#x27;,\n    });\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 200 - get&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 201 - post&#x27;, async () =&gt; {\n    const { status, data } = await service.post(`${API_NESTJS_STARTER}/posts`, {\n      data: mockRequestBody,\n    });\n    expect(status).toBe(201);\n    expect(data).toEqual({\n      ...mockRequestBody,\n      id: 101,\n    });\n  });\n\n  it(&#x27;should be return status 200 - get by id&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts/1`);\n    expect(status).toBe(200);\n    expect(data).toEqual(mockRequestBody);\n  });\n\n  it(&#x27;should be return status 200 - put&#x27;, async () =&gt; {\n    const { status, data } = await service.put(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - delete&#x27;, async () =&gt; {\n    const { status, data } = await service.delete(`${API_NESTJS_STARTER}/posts/2`);\n    expect(status).toBe(200);\n    expect(data).toEqual({});\n  });\n\n  it(&#x27;should be return status 200 - patch&#x27;, async () =&gt; {\n    const { status, data } = await service.patch(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - head&#x27;, async () =&gt; {\n    const { status, headers } = await service.head(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(headers).toHaveProperty(&#x27;etag&#x27;);\n  });\n\n  it(&#x27;should be return error&#x27;, async () =&gt; {\n    try {\n      const { data } = await service.get(`${API_NESTJS_STARTER}/postss`);\n      expect(data).toBe(200);\n    } catch (error) {\n      expect(error.response.status).toBe(404);\n      expect(error.message).toBe(&#x27;Request failed with status code 404&#x27;);\n    }\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;5f43a1e5-f288-4364-84c5-c508eb4413f3&quot;,&quot;parentUUID&quot;:&quot;24319c5d-6917-47c5-98ff-d0f61875e522&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;HttpService &gt; should be return status 200 - head&quot;,&quot;title&quot;:&quot;HttpService &gt; should be return status 200 - head&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:477,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule, ConfigService } from &#x27;@nestjs/config&#x27;;\n\nimport { HttpClientService } from &#x27;../http/services/httpClient.service&#x27;;\nimport { HttpClientModule } from &#x27;../http/httpClient.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\n\nconst API_NESTJS_STARTER = &#x27;https://jsonplaceholder.typicode.com&#x27;;\n\nconst mockRequestBody = {\n  userId: 1,\n  id: 1,\n  title: &#x27;sunt aut facere repellat provident occaecati excepturi optio reprehenderit&#x27;,\n  body: &#x27;quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto&#x27;,\n};\n\ndescribe(&#x27;HttpService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let service: HttpClientService;\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HttpClientModule.registerAsync({\n          imports: [ConfigModule],\n          useFactory: async (configService: ConfigService) =&gt;\n            configService.get(&#x27;config.httpOptions&#x27;),\n          inject: [ConfigService],\n        }),\n      ],\n    }).compile();\n    app = module.createNestApplication();\n    await app.init;\n    service = module.get&lt;HttpClientService&gt;(HttpClientService);\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(service).toBeDefined();\n    expect(service).toBeInstanceOf(HttpClientService);\n    expect(service.axiosRef).not.toBeNull();\n  });\n\n  it(&#x27;should be return status 200 - request&#x27;, async () =&gt; {\n    const { status, data } = await service.request({\n      url: `${API_NESTJS_STARTER}/posts`,\n      method: &#x27;GET&#x27;,\n    });\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 200 - get&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 201 - post&#x27;, async () =&gt; {\n    const { status, data } = await service.post(`${API_NESTJS_STARTER}/posts`, {\n      data: mockRequestBody,\n    });\n    expect(status).toBe(201);\n    expect(data).toEqual({\n      ...mockRequestBody,\n      id: 101,\n    });\n  });\n\n  it(&#x27;should be return status 200 - get by id&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts/1`);\n    expect(status).toBe(200);\n    expect(data).toEqual(mockRequestBody);\n  });\n\n  it(&#x27;should be return status 200 - put&#x27;, async () =&gt; {\n    const { status, data } = await service.put(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - delete&#x27;, async () =&gt; {\n    const { status, data } = await service.delete(`${API_NESTJS_STARTER}/posts/2`);\n    expect(status).toBe(200);\n    expect(data).toEqual({});\n  });\n\n  it(&#x27;should be return status 200 - patch&#x27;, async () =&gt; {\n    const { status, data } = await service.patch(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - head&#x27;, async () =&gt; {\n    const { status, headers } = await service.head(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(headers).toHaveProperty(&#x27;etag&#x27;);\n  });\n\n  it(&#x27;should be return error&#x27;, async () =&gt; {\n    try {\n      const { data } = await service.get(`${API_NESTJS_STARTER}/postss`);\n      expect(data).toBe(200);\n    } catch (error) {\n      expect(error.response.status).toBe(404);\n      expect(error.message).toBe(&#x27;Request failed with status code 404&#x27;);\n    }\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ab214ad7-10c9-47a2-8d12-eb625c98414a&quot;,&quot;parentUUID&quot;:&quot;24319c5d-6917-47c5-98ff-d0f61875e522&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;HttpService &gt; should be return error&quot;,&quot;title&quot;:&quot;HttpService &gt; should be return error&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:473,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule, ConfigService } from &#x27;@nestjs/config&#x27;;\n\nimport { HttpClientService } from &#x27;../http/services/httpClient.service&#x27;;\nimport { HttpClientModule } from &#x27;../http/httpClient.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\n\nconst API_NESTJS_STARTER = &#x27;https://jsonplaceholder.typicode.com&#x27;;\n\nconst mockRequestBody = {\n  userId: 1,\n  id: 1,\n  title: &#x27;sunt aut facere repellat provident occaecati excepturi optio reprehenderit&#x27;,\n  body: &#x27;quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto&#x27;,\n};\n\ndescribe(&#x27;HttpService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let service: HttpClientService;\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HttpClientModule.registerAsync({\n          imports: [ConfigModule],\n          useFactory: async (configService: ConfigService) =&gt;\n            configService.get(&#x27;config.httpOptions&#x27;),\n          inject: [ConfigService],\n        }),\n      ],\n    }).compile();\n    app = module.createNestApplication();\n    await app.init;\n    service = module.get&lt;HttpClientService&gt;(HttpClientService);\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(service).toBeDefined();\n    expect(service).toBeInstanceOf(HttpClientService);\n    expect(service.axiosRef).not.toBeNull();\n  });\n\n  it(&#x27;should be return status 200 - request&#x27;, async () =&gt; {\n    const { status, data } = await service.request({\n      url: `${API_NESTJS_STARTER}/posts`,\n      method: &#x27;GET&#x27;,\n    });\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 200 - get&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it(&#x27;should be return status 201 - post&#x27;, async () =&gt; {\n    const { status, data } = await service.post(`${API_NESTJS_STARTER}/posts`, {\n      data: mockRequestBody,\n    });\n    expect(status).toBe(201);\n    expect(data).toEqual({\n      ...mockRequestBody,\n      id: 101,\n    });\n  });\n\n  it(&#x27;should be return status 200 - get by id&#x27;, async () =&gt; {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts/1`);\n    expect(status).toBe(200);\n    expect(data).toEqual(mockRequestBody);\n  });\n\n  it(&#x27;should be return status 200 - put&#x27;, async () =&gt; {\n    const { status, data } = await service.put(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - delete&#x27;, async () =&gt; {\n    const { status, data } = await service.delete(`${API_NESTJS_STARTER}/posts/2`);\n    expect(status).toBe(200);\n    expect(data).toEqual({});\n  });\n\n  it(&#x27;should be return status 200 - patch&#x27;, async () =&gt; {\n    const { status, data } = await service.patch(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: &#x27;mockito&#x27;,\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: &#x27;mockito&#x27; });\n  });\n\n  it(&#x27;should be return status 200 - head&#x27;, async () =&gt; {\n    const { status, headers } = await service.head(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(headers).toHaveProperty(&#x27;etag&#x27;);\n  });\n\n  it(&#x27;should be return error&#x27;, async () =&gt; {\n    try {\n      const { data } = await service.get(`${API_NESTJS_STARTER}/postss`);\n      expect(data).toBe(200);\n    } catch (error) {\n      expect(error.response.status).toBe(404);\n      expect(error.message).toBe(&#x27;Request failed with status code 404&#x27;);\n    }\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;006434b5-4b13-4ae9-8e9f-76c48462f084&quot;,&quot;parentUUID&quot;:&quot;24319c5d-6917-47c5-98ff-d0f61875e522&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;HttpModule &gt; registerAsync useFactory &gt; should be define&quot;,&quot;title&quot;:&quot;HttpModule &gt; registerAsync useFactory &gt; should be define&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:74,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\n\nimport { HttpClientModule } from &#x27;../http/httpClient.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\nimport { HttpModuleAsyncOptions } from &#x27;../http/interfaces/http-module.interface&#x27;;\n\nclass MockedClass {\n  createHttpOptions() {\n    return {\n      timeout: 5000,\n      maxRedirects: 5,\n    };\n  }\n}\n\ndescribe(&#x27;HttpModule&#x27;, () =&gt; {\n  const mockedUseFactory: HttpModuleAsyncOptions = {\n    useFactory: async () =&gt; ({\n      timeout: 5000,\n      maxRedirects: 5,\n    }),\n  };\n\n  describe(&#x27;registerAsync useFactory&#x27;, () =&gt; {\n    let app: INestApplication;\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.registerAsync(mockedUseFactory),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be define&#x27;, async () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n\n  const mockedUseClassOptions: HttpModuleAsyncOptions = {\n    useClass: MockedClass,\n  };\n\n  describe(&#x27;registerAsync useClass&#x27;, () =&gt; {\n    let app: INestApplication;\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.registerAsync(mockedUseClassOptions),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be define&#x27;, async () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n\n  const mockedUseExistingOptions: HttpModuleAsyncOptions = {\n    extraProviders: [MockedClass],\n    useExisting: MockedClass,\n  };\n\n  describe(&#x27;registerAsync useExisting&#x27;, () =&gt; {\n    let app: INestApplication;\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.registerAsync(mockedUseExistingOptions),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be define&#x27;, async () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n\n  describe(&#x27;register&#x27;, () =&gt; {\n    let app: INestApplication;\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.register({ ...config().httOptions }),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be define&#x27;, async () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7b2cf546-547d-472f-a34e-bdf1e1d145ab&quot;,&quot;parentUUID&quot;:&quot;24319c5d-6917-47c5-98ff-d0f61875e522&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;HttpModule &gt; registerAsync useClass &gt; should be define&quot;,&quot;title&quot;:&quot;HttpModule &gt; registerAsync useClass &gt; should be define&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\n\nimport { HttpClientModule } from &#x27;../http/httpClient.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\nimport { HttpModuleAsyncOptions } from &#x27;../http/interfaces/http-module.interface&#x27;;\n\nclass MockedClass {\n  createHttpOptions() {\n    return {\n      timeout: 5000,\n      maxRedirects: 5,\n    };\n  }\n}\n\ndescribe(&#x27;HttpModule&#x27;, () =&gt; {\n  const mockedUseFactory: HttpModuleAsyncOptions = {\n    useFactory: async () =&gt; ({\n      timeout: 5000,\n      maxRedirects: 5,\n    }),\n  };\n\n  describe(&#x27;registerAsync useFactory&#x27;, () =&gt; {\n    let app: INestApplication;\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.registerAsync(mockedUseFactory),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be define&#x27;, async () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n\n  const mockedUseClassOptions: HttpModuleAsyncOptions = {\n    useClass: MockedClass,\n  };\n\n  describe(&#x27;registerAsync useClass&#x27;, () =&gt; {\n    let app: INestApplication;\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.registerAsync(mockedUseClassOptions),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be define&#x27;, async () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n\n  const mockedUseExistingOptions: HttpModuleAsyncOptions = {\n    extraProviders: [MockedClass],\n    useExisting: MockedClass,\n  };\n\n  describe(&#x27;registerAsync useExisting&#x27;, () =&gt; {\n    let app: INestApplication;\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.registerAsync(mockedUseExistingOptions),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be define&#x27;, async () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n\n  describe(&#x27;register&#x27;, () =&gt; {\n    let app: INestApplication;\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.register({ ...config().httOptions }),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be define&#x27;, async () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b7beb8bf-2084-401f-b905-35844c56d685&quot;,&quot;parentUUID&quot;:&quot;24319c5d-6917-47c5-98ff-d0f61875e522&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;HttpModule &gt; registerAsync useExisting &gt; should be define&quot;,&quot;title&quot;:&quot;HttpModule &gt; registerAsync useExisting &gt; should be define&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:14,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\n\nimport { HttpClientModule } from &#x27;../http/httpClient.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\nimport { HttpModuleAsyncOptions } from &#x27;../http/interfaces/http-module.interface&#x27;;\n\nclass MockedClass {\n  createHttpOptions() {\n    return {\n      timeout: 5000,\n      maxRedirects: 5,\n    };\n  }\n}\n\ndescribe(&#x27;HttpModule&#x27;, () =&gt; {\n  const mockedUseFactory: HttpModuleAsyncOptions = {\n    useFactory: async () =&gt; ({\n      timeout: 5000,\n      maxRedirects: 5,\n    }),\n  };\n\n  describe(&#x27;registerAsync useFactory&#x27;, () =&gt; {\n    let app: INestApplication;\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.registerAsync(mockedUseFactory),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be define&#x27;, async () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n\n  const mockedUseClassOptions: HttpModuleAsyncOptions = {\n    useClass: MockedClass,\n  };\n\n  describe(&#x27;registerAsync useClass&#x27;, () =&gt; {\n    let app: INestApplication;\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.registerAsync(mockedUseClassOptions),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be define&#x27;, async () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n\n  const mockedUseExistingOptions: HttpModuleAsyncOptions = {\n    extraProviders: [MockedClass],\n    useExisting: MockedClass,\n  };\n\n  describe(&#x27;registerAsync useExisting&#x27;, () =&gt; {\n    let app: INestApplication;\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.registerAsync(mockedUseExistingOptions),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be define&#x27;, async () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n\n  describe(&#x27;register&#x27;, () =&gt; {\n    let app: INestApplication;\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.register({ ...config().httOptions }),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be define&#x27;, async () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a17326e6-2a9f-49bf-bfe5-470f80ff5ee9&quot;,&quot;parentUUID&quot;:&quot;24319c5d-6917-47c5-98ff-d0f61875e522&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;HttpModule &gt; register &gt; should be define&quot;,&quot;title&quot;:&quot;HttpModule &gt; register &gt; should be define&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\n\nimport { HttpClientModule } from &#x27;../http/httpClient.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\nimport { HttpModuleAsyncOptions } from &#x27;../http/interfaces/http-module.interface&#x27;;\n\nclass MockedClass {\n  createHttpOptions() {\n    return {\n      timeout: 5000,\n      maxRedirects: 5,\n    };\n  }\n}\n\ndescribe(&#x27;HttpModule&#x27;, () =&gt; {\n  const mockedUseFactory: HttpModuleAsyncOptions = {\n    useFactory: async () =&gt; ({\n      timeout: 5000,\n      maxRedirects: 5,\n    }),\n  };\n\n  describe(&#x27;registerAsync useFactory&#x27;, () =&gt; {\n    let app: INestApplication;\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.registerAsync(mockedUseFactory),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be define&#x27;, async () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n\n  const mockedUseClassOptions: HttpModuleAsyncOptions = {\n    useClass: MockedClass,\n  };\n\n  describe(&#x27;registerAsync useClass&#x27;, () =&gt; {\n    let app: INestApplication;\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.registerAsync(mockedUseClassOptions),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be define&#x27;, async () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n\n  const mockedUseExistingOptions: HttpModuleAsyncOptions = {\n    extraProviders: [MockedClass],\n    useExisting: MockedClass,\n  };\n\n  describe(&#x27;registerAsync useExisting&#x27;, () =&gt; {\n    let app: INestApplication;\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.registerAsync(mockedUseExistingOptions),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be define&#x27;, async () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n\n  describe(&#x27;register&#x27;, () =&gt; {\n    let app: INestApplication;\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.register({ ...config().httOptions }),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be define&#x27;, async () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;df521797-3029-4f24-9db9-f3835160fe27&quot;,&quot;parentUUID&quot;:&quot;24319c5d-6917-47c5-98ff-d0f61875e522&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;HttpInterceptor &gt; should be defined&quot;,&quot;title&quot;:&quot;HttpInterceptor &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:64,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\n\nimport { HttpClientService } from &#x27;../http/services/httpClient.service&#x27;;\nimport { HttpClientInterceptor } from &#x27;../http/interceptors/httpClient.interceptor&#x27;;\nimport { HttpClientModule } from &#x27;../http/httpClient.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\n\nconst executionContext: any = {\n  switchToHttp: jest.fn().mockReturnThis(),\n  getRequest: jest.fn().mockReturnThis(),\n  getResponse: jest.fn().mockReturnThis(),\n};\n\nconst callHandler: any = {\n  handle: jest.fn(),\n};\n\ndescribe(&#x27;HttpInterceptor&#x27;, () =&gt; {\n  let app: INestApplication;\n  let service: HttpClientService;\n  let interceptor: HttpClientInterceptor&lt;any&gt;;\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HttpClientModule,\n      ],\n    }).compile();\n    app = module.createNestApplication();\n    await app.init;\n\n    service = module.get&lt;HttpClientService&gt;(HttpClientService);\n    interceptor = new HttpClientInterceptor(service);\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(interceptor).toBeDefined();\n  });\n\n  it(&#x27;should be intercept and pass headers&#x27;, async () =&gt; {\n    await interceptor.intercept(executionContext, callHandler);\n    expect(callHandler.handle).toBeCalledTimes(1);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;76a6ead2-6749-41d2-9231-51523600a569&quot;,&quot;parentUUID&quot;:&quot;24319c5d-6917-47c5-98ff-d0f61875e522&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;HttpInterceptor &gt; should be intercept and pass headers&quot;,&quot;title&quot;:&quot;HttpInterceptor &gt; should be intercept and pass headers&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\n\nimport { HttpClientService } from &#x27;../http/services/httpClient.service&#x27;;\nimport { HttpClientInterceptor } from &#x27;../http/interceptors/httpClient.interceptor&#x27;;\nimport { HttpClientModule } from &#x27;../http/httpClient.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\n\nconst executionContext: any = {\n  switchToHttp: jest.fn().mockReturnThis(),\n  getRequest: jest.fn().mockReturnThis(),\n  getResponse: jest.fn().mockReturnThis(),\n};\n\nconst callHandler: any = {\n  handle: jest.fn(),\n};\n\ndescribe(&#x27;HttpInterceptor&#x27;, () =&gt; {\n  let app: INestApplication;\n  let service: HttpClientService;\n  let interceptor: HttpClientInterceptor&lt;any&gt;;\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HttpClientModule,\n      ],\n    }).compile();\n    app = module.createNestApplication();\n    await app.init;\n\n    service = module.get&lt;HttpClientService&gt;(HttpClientService);\n    interceptor = new HttpClientInterceptor(service);\n  });\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(interceptor).toBeDefined();\n  });\n\n  it(&#x27;should be intercept and pass headers&#x27;, async () =&gt; {\n    await interceptor.intercept(executionContext, callHandler);\n    expect(callHandler.handle).toBeCalledTimes(1);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;199d6a53-b351-4d71-823f-478c3ed2635d&quot;,&quot;parentUUID&quot;:&quot;24319c5d-6917-47c5-98ff-d0f61875e522&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;18e7b96f-3b1f-405d-988f-aacbc003be53&quot;,&quot;ca71b7a7-b92a-4cf6-9f55-5de56c44713f&quot;,&quot;472578f1-2697-4018-8a00-535a6d800921&quot;,&quot;1a2bfeca-9820-4833-b20c-77e9f54cd118&quot;,&quot;765e9f24-3edb-4538-9315-03a37b2d57d5&quot;,&quot;bf369938-3c8d-4dfb-9cb2-d6f0730fcd2a&quot;,&quot;34b844bf-3aa3-41d5-a99a-c34b29577a39&quot;,&quot;5f43a1e5-f288-4364-84c5-c508eb4413f3&quot;,&quot;ab214ad7-10c9-47a2-8d12-eb625c98414a&quot;,&quot;006434b5-4b13-4ae9-8e9f-76c48462f084&quot;,&quot;7b2cf546-547d-472f-a34e-bdf1e1d145ab&quot;,&quot;b7beb8bf-2084-401f-b905-35844c56d685&quot;,&quot;a17326e6-2a9f-49bf-bfe5-470f80ff5ee9&quot;,&quot;df521797-3029-4f24-9db9-f3835160fe27&quot;,&quot;76a6ead2-6749-41d2-9231-51523600a569&quot;,&quot;199d6a53-b351-4d71-823f-478c3ed2635d&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:5154,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:5000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:5000},{&quot;uuid&quot;:&quot;125451d8-296f-43c9-a280-6c5bef195263&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/mailer&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;e8eec7ef-3d71-4c50-8654-8823a88f3958&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/mailer&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;fullTitle&quot;:&quot;MailerService &gt; should not be defined if a transport is not provided&quot;,&quot;title&quot;:&quot;MailerService &gt; should not be defined if a transport is not provided&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1047b1dc-7876-4a7a-8eff-241b356e717a&quot;,&quot;parentUUID&quot;:&quot;e8eec7ef-3d71-4c50-8654-8823a88f3958&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should accept a smtp transport string&quot;,&quot;title&quot;:&quot;MailerService &gt; should accept a smtp transport string&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:7,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;8b9c5193-85c2-4056-9b08-01d1c05813bb&quot;,&quot;parentUUID&quot;:&quot;e8eec7ef-3d71-4c50-8654-8823a88f3958&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should accept a smtp transports string&quot;,&quot;title&quot;:&quot;MailerService &gt; should accept a smtp transports string&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e4334e57-2e1c-483e-ac48-d1a7ed317f4a&quot;,&quot;parentUUID&quot;:&quot;e8eec7ef-3d71-4c50-8654-8823a88f3958&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should accept smtp transport options&quot;,&quot;title&quot;:&quot;MailerService &gt; should accept smtp transport options&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4c085371-41e3-4610-ac2e-55974fd01068&quot;,&quot;parentUUID&quot;:&quot;e8eec7ef-3d71-4c50-8654-8823a88f3958&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should accept a smtp transport instance&quot;,&quot;title&quot;:&quot;MailerService &gt; should accept a smtp transport instance&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;27044537-be08-4289-bcfc-36425bd62b89&quot;,&quot;parentUUID&quot;:&quot;e8eec7ef-3d71-4c50-8654-8823a88f3958&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should send emails with nodemailer&quot;,&quot;title&quot;:&quot;MailerService &gt; should send emails with nodemailer&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;13ae129c-2422-42a8-bdd0-1bbdd5ef3e24&quot;,&quot;parentUUID&quot;:&quot;e8eec7ef-3d71-4c50-8654-8823a88f3958&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should send emails with nodemailer transports&quot;,&quot;title&quot;:&quot;MailerService &gt; should send emails with nodemailer transports&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4d1df8cd-1601-4604-ba13-945b18d3a72d&quot;,&quot;parentUUID&quot;:&quot;e8eec7ef-3d71-4c50-8654-8823a88f3958&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should send emails with nodemailer with different transports name&quot;,&quot;title&quot;:&quot;MailerService &gt; should send emails with nodemailer with different transports name&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;92a7a2fa-5271-446f-8605-b148b12d3579&quot;,&quot;parentUUID&quot;:&quot;e8eec7ef-3d71-4c50-8654-8823a88f3958&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should send emails with nodemailer without transports&quot;,&quot;title&quot;:&quot;MailerService &gt; should send emails with nodemailer without transports&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;8e608fff-094f-4fe8-b0fb-7d373ea7a0f1&quot;,&quot;parentUUID&quot;:&quot;e8eec7ef-3d71-4c50-8654-8823a88f3958&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should use mailerOptions.defaults when send emails&quot;,&quot;title&quot;:&quot;MailerService &gt; should use mailerOptions.defaults when send emails&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9b3578b4-8bae-4351-85b3-0f0602a5361e&quot;,&quot;parentUUID&quot;:&quot;e8eec7ef-3d71-4c50-8654-8823a88f3958&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should use custom transport to send mail&quot;,&quot;title&quot;:&quot;MailerService &gt; should use custom transport to send mail&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4a0caedf-3f27-4926-9a96-0df9eafcf54e&quot;,&quot;parentUUID&quot;:&quot;e8eec7ef-3d71-4c50-8654-8823a88f3958&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should compile template with the handlebars adapter&quot;,&quot;title&quot;:&quot;MailerService &gt; should compile template with the handlebars adapter&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:21,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3ffa1f89-e8c7-4f10-827d-df6164d48e90&quot;,&quot;parentUUID&quot;:&quot;e8eec7ef-3d71-4c50-8654-8823a88f3958&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should compile template with the handlebars adapter with relative path&quot;,&quot;title&quot;:&quot;MailerService &gt; should compile template with the handlebars adapter with relative path&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a374307b-84e7-429e-8f35-e9c9b5bdab43&quot;,&quot;parentUUID&quot;:&quot;e8eec7ef-3d71-4c50-8654-8823a88f3958&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should compile template with the handlebars adapter with error template path&quot;,&quot;title&quot;:&quot;MailerService &gt; should compile template with the handlebars adapter with error template path&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;32589576-76e5-4c71-a3e0-143f36049b6c&quot;,&quot;parentUUID&quot;:&quot;e8eec7ef-3d71-4c50-8654-8823a88f3958&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should compile template with the handlebars adapter with disabled inline-css&quot;,&quot;title&quot;:&quot;MailerService &gt; should compile template with the handlebars adapter with disabled inline-css&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9663fb40-7d04-4fee-8451-8336bb765ce0&quot;,&quot;parentUUID&quot;:&quot;e8eec7ef-3d71-4c50-8654-8823a88f3958&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should compile template with the handlebars adapter with enabled inline-css and media query&quot;,&quot;title&quot;:&quot;MailerService &gt; should compile template with the handlebars adapter with enabled inline-css and media query&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:7,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f3870633-cefb-466e-94e2-2d504c34dfa7&quot;,&quot;parentUUID&quot;:&quot;e8eec7ef-3d71-4c50-8654-8823a88f3958&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should compile template with the pug adapter&quot;,&quot;title&quot;:&quot;MailerService &gt; should compile template with the pug adapter&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:24,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;06aa9310-8d6f-4b44-98a8-57cccb6b0edd&quot;,&quot;parentUUID&quot;:&quot;e8eec7ef-3d71-4c50-8654-8823a88f3958&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should compile template with the pug adapter with relative path&quot;,&quot;title&quot;:&quot;MailerService &gt; should compile template with the pug adapter with relative path&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:6,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;35b7bf58-d573-4401-b7e5-b9ff8a0f6b20&quot;,&quot;parentUUID&quot;:&quot;e8eec7ef-3d71-4c50-8654-8823a88f3958&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should compile template with the pug adapter with error to read template&quot;,&quot;title&quot;:&quot;MailerService &gt; should compile template with the pug adapter with error to read template&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;042ce14c-3a47-4c36-926b-4ba4dd5ca8cc&quot;,&quot;parentUUID&quot;:&quot;e8eec7ef-3d71-4c50-8654-8823a88f3958&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should compile template with the pug adapter without inline css&quot;,&quot;title&quot;:&quot;MailerService &gt; should compile template with the pug adapter without inline css&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;359fa6e6-e0c1-4240-b3af-f9c8d0459741&quot;,&quot;parentUUID&quot;:&quot;e8eec7ef-3d71-4c50-8654-8823a88f3958&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should compile template with the ejs adapter&quot;,&quot;title&quot;:&quot;MailerService &gt; should compile template with the ejs adapter&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c32328d9-a0ee-44e8-af4f-031d4e75dede&quot;,&quot;parentUUID&quot;:&quot;e8eec7ef-3d71-4c50-8654-8823a88f3958&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should compile template with the ejs adapter with error to read template&quot;,&quot;title&quot;:&quot;MailerService &gt; should compile template with the ejs adapter with error to read template&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3a25d77a-3d56-42c3-8b20-3a709b8a1ec2&quot;,&quot;parentUUID&quot;:&quot;e8eec7ef-3d71-4c50-8654-8823a88f3958&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should compile template with the ejs adapter read template relative url&quot;,&quot;title&quot;:&quot;MailerService &gt; should compile template with the ejs adapter read template relative url&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b8285d42-58e2-4cdd-b0dd-f8c2707cd06c&quot;,&quot;parentUUID&quot;:&quot;e8eec7ef-3d71-4c50-8654-8823a88f3958&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should compile template with the ejs adapter without css inline&quot;,&quot;title&quot;:&quot;MailerService &gt; should compile template with the ejs adapter without css inline&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3c77f777-992d-4509-8c85-177a485138a8&quot;,&quot;parentUUID&quot;:&quot;e8eec7ef-3d71-4c50-8654-8823a88f3958&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerService &gt; should compile template with the ejs adapter with css inline&quot;,&quot;title&quot;:&quot;MailerService &gt; should compile template with the ejs adapter with css inline&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { pathJoin } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport * as nodemailerMock from &#x27;nodemailer-mock&#x27;;\nimport MailMessage from &#x27;nodemailer/lib/mailer/mail-message&#x27;;\nimport SMTPTransport from &#x27;nodemailer/lib/smtp-transport&#x27;;\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from &#x27;../mailer/constants/mailer.constant&#x27;;\n\nimport { MailerOptions, TransportType } from &#x27;../mailer/interfaces/mailer-options.interface&#x27;;\nimport { MailerTransportFactory } from &#x27;../mailer/interfaces/mailer-transport-factory.interface&#x27;;\n\nimport { HandlebarsAdapter } from &#x27;../mailer/adapters/handlebars.adapter&#x27;;\nimport { PugAdapter } from &#x27;../mailer/adapters/pug.adapter&#x27;;\nimport { EjsAdapter } from &#x27;../mailer/adapters/ejs.adapter&#x27;;\n\nimport { MailerService } from &#x27;../mailer/services/mailer.service&#x27;;\n\nconst template_path = pathJoin(__dirname, &#x27;utils/test-templates&#x27;);\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise&lt;MailerService&gt; {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) =&gt; void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, &#x27;send&#x27;)\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) =&gt; void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: &#x27;ABCD&#x27;,\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: &#x27;ok&#x27;,\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise&lt;MailerService&gt; {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: &#x27;localhost&#x27;, port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get&lt;MailerService&gt;(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe(&#x27;MailerService&#x27;, () =&gt; {\n  it(&#x27;should not be defined if a transport is not provided&#x27;, async () =&gt; {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it(&#x27;should accept a smtp transport string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transports string&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) =&gt; {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it(&#x27;should accept smtp transport options&#x27;, async () =&gt; {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: &#x27;user@domain.com&#x27;,\n          pass: &#x27;pass&#x27;,\n        },\n        options: {\n          host: &#x27;smtp.domain.com&#x27;,\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it(&#x27;should accept a smtp transport instance&#x27;, async () =&gt; {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it(&#x27;should send emails with nodemailer&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer transports&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      transporterName: &#x27;myDomain&#x27;,\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.to).toBe(&#x27;user2@example.test&#x27;);\n    expect(lastMail.data.subject).toBe(&#x27;Test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;This is test.&#x27;);\n  });\n\n  it(&#x27;should send emails with nodemailer with different transports name&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n        },\n      });\n\n      await service.sendMail({\n        transporterName: &#x27;testDomain&#x27;,\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\&quot;Transporters object doesn&#x27;t have testDomain key\&quot;);\n    }\n  });\n\n  it(&#x27;should send emails with nodemailer without transports&#x27;, async () =&gt; {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        html: &#x27;This is test.&#x27;,\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(&#x27;Transporter object undefined&#x27;);\n    }\n  });\n\n  it(&#x27;should use mailerOptions.defaults when send emails&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n      defaults: {\n        from: &#x27;user1@example.test&#x27;,\n      },\n    });\n\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n  });\n\n  it(&#x27;should use custom transport to send mail&#x27;, async () =&gt; {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n    });\n    await service.sendMail({\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      html: &#x27;This is test.&#x27;,\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./handlebars-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with error template path&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/handlebars-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.hbs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with disabled inline-css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) =&gt; {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the handlebars adapter with enabled inline-css and media query&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: &#x27; &#x27;, preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;@media only screen and (max-width:350px)&#x27;);\n    expect(lastMail.data.html).toContain(&#x27;&lt;p&gt;Handlebars test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the pug adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with relative path&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n\n  it(&#x27;should compile template with the pug adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/pug-templates&#x27;);\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          world: &#x27;World&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open &#x27;${templatePath}.pug&#x27;`);\n    }\n  });\n\n  it(&#x27;should compile template with the pug adapter without inline css&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/pug-template`,\n      context: {\n        world: &#x27;World&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Pug test template.&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with error to read template&#x27;, async () =&gt; {\n    let templatePath = pathJoin(template_path, &#x27;/ejs-templates&#x27;);\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: &#x27;user1@example.test&#x27;,\n        to: &#x27;user2@example.test&#x27;,\n        subject: &#x27;Test&#x27;,\n        template: `${templatePath}`,\n        context: {\n          MAILER: &#x27;Nest-modules TM&#x27;,\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open &#x27;${templatePath}.ejs&#x27;`,\n      );\n    }\n  });\n\n  it(&#x27;should compile template with the ejs adapter read template relative url&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `./ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter without css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(&#x27;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&#x27;);\n  });\n\n  it(&#x27;should compile template with the ejs adapter with css inline&#x27;, async () =&gt; {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) =&gt; {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: &#x27;user1@example.test&#x27;,\n      to: &#x27;user2@example.test&#x27;,\n      subject: &#x27;Test&#x27;,\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: &#x27;Nest-modules TM&#x27;,\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe(&#x27;user1@example.test&#x27;);\n    expect(lastMail.data.html).toBe(\n      &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Ejs test template. by Nest-modules TM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\n    );\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;5df23c55-aa1e-4a28-8609-e6752c557f1c&quot;,&quot;parentUUID&quot;:&quot;e8eec7ef-3d71-4c50-8654-8823a88f3958&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerModule &gt; forRoot &gt; should be defined&quot;,&quot;title&quot;:&quot;MailerModule &gt; forRoot &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:282,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { MailerModule } from &#x27;../mailer/mailer.module&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport { dynamicConfig } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\n\ndescribe(&#x27;MailerModule&#x27;, () =&gt; {\n  let app: INestApplication;\n\n  describe(&#x27;forRoot&#x27;, () =&gt; {\n    beforeEach(async () =&gt; {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          MailerModule.forRoot({\n            transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n            defaults: {\n              from: &#x27;\&quot;nest-modules\&quot; &lt;modules@nestjs.com&gt;&#x27;,\n            },\n          }),\n        ],\n      }).compile();\n\n      app = moduleFixture.createNestApplication();\n      await app.init();\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n\n  describe(&#x27;forRootAsync&#x27;, () =&gt; {\n    beforeEach(async () =&gt; {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [\n              dynamicConfig({\n                mailer: {\n                  transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n                  defaults: {\n                    from: &#x27;\&quot;nest-modules\&quot; &lt;modules@nestjs.com&gt;&#x27;,\n                  },\n                },\n              }),\n            ],\n          }),\n          MailerModule,\n        ],\n      }).compile();\n\n      app = moduleFixture.createNestApplication();\n      await app.init();\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;58e8611e-6ae7-4153-9676-a986ca3ff343&quot;,&quot;parentUUID&quot;:&quot;e8eec7ef-3d71-4c50-8654-8823a88f3958&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;MailerModule &gt; forRootAsync &gt; should be defined&quot;,&quot;title&quot;:&quot;MailerModule &gt; forRootAsync &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { MailerModule } from &#x27;../mailer/mailer.module&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport { dynamicConfig } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\n\ndescribe(&#x27;MailerModule&#x27;, () =&gt; {\n  let app: INestApplication;\n\n  describe(&#x27;forRoot&#x27;, () =&gt; {\n    beforeEach(async () =&gt; {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          MailerModule.forRoot({\n            transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n            defaults: {\n              from: &#x27;\&quot;nest-modules\&quot; &lt;modules@nestjs.com&gt;&#x27;,\n            },\n          }),\n        ],\n      }).compile();\n\n      app = moduleFixture.createNestApplication();\n      await app.init();\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n\n  describe(&#x27;forRootAsync&#x27;, () =&gt; {\n    beforeEach(async () =&gt; {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [\n              dynamicConfig({\n                mailer: {\n                  transport: &#x27;smtps://user@domain.com:pass@smtp.domain.com&#x27;,\n                  defaults: {\n                    from: &#x27;\&quot;nest-modules\&quot; &lt;modules@nestjs.com&gt;&#x27;,\n                  },\n                },\n              }),\n            ],\n          }),\n          MailerModule,\n        ],\n      }).compile();\n\n      app = moduleFixture.createNestApplication();\n      await app.init();\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(app).toBeDefined();\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3fc80f1e-efb4-40cd-a8b0-28497c7fcb0d&quot;,&quot;parentUUID&quot;:&quot;e8eec7ef-3d71-4c50-8654-8823a88f3958&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;1047b1dc-7876-4a7a-8eff-241b356e717a&quot;,&quot;8b9c5193-85c2-4056-9b08-01d1c05813bb&quot;,&quot;e4334e57-2e1c-483e-ac48-d1a7ed317f4a&quot;,&quot;4c085371-41e3-4610-ac2e-55974fd01068&quot;,&quot;27044537-be08-4289-bcfc-36425bd62b89&quot;,&quot;13ae129c-2422-42a8-bdd0-1bbdd5ef3e24&quot;,&quot;4d1df8cd-1601-4604-ba13-945b18d3a72d&quot;,&quot;92a7a2fa-5271-446f-8605-b148b12d3579&quot;,&quot;8e608fff-094f-4fe8-b0fb-7d373ea7a0f1&quot;,&quot;9b3578b4-8bae-4351-85b3-0f0602a5361e&quot;,&quot;4a0caedf-3f27-4926-9a96-0df9eafcf54e&quot;,&quot;3ffa1f89-e8c7-4f10-827d-df6164d48e90&quot;,&quot;a374307b-84e7-429e-8f35-e9c9b5bdab43&quot;,&quot;32589576-76e5-4c71-a3e0-143f36049b6c&quot;,&quot;9663fb40-7d04-4fee-8451-8336bb765ce0&quot;,&quot;f3870633-cefb-466e-94e2-2d504c34dfa7&quot;,&quot;06aa9310-8d6f-4b44-98a8-57cccb6b0edd&quot;,&quot;35b7bf58-d573-4401-b7e5-b9ff8a0f6b20&quot;,&quot;042ce14c-3a47-4c36-926b-4ba4dd5ca8cc&quot;,&quot;359fa6e6-e0c1-4240-b3af-f9c8d0459741&quot;,&quot;c32328d9-a0ee-44e8-af4f-031d4e75dede&quot;,&quot;3a25d77a-3d56-42c3-8b20-3a709b8a1ec2&quot;,&quot;b8285d42-58e2-4cdd-b0dd-f8c2707cd06c&quot;,&quot;3c77f777-992d-4509-8c85-177a485138a8&quot;,&quot;5df23c55-aa1e-4a28-8609-e6752c557f1c&quot;,&quot;58e8611e-6ae7-4153-9676-a986ca3ff343&quot;,&quot;3fc80f1e-efb4-40cd-a8b0-28497c7fcb0d&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:443,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:5000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:5000},{&quot;uuid&quot;:&quot;95381830-30f0-4c86-80b7-0dcd5180b154&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/redis&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;ed52d5e4-01de-481b-ad2c-470378e0d014&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/redis&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;fullTitle&quot;:&quot;RedisService &gt; should be defined&quot;,&quot;title&quot;:&quot;RedisService &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:348,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { delay, tcName, TCRedisOptions, testContainers } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { RedisModule } from &#x27;../redis/redis.module&#x27;;\nimport { RedisService } from &#x27;../redis/services/redis.service&#x27;;\n\ndescribe(&#x27;RedisService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () =&gt; {\n    container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n      ...TCRedisOptions,\n      command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: &#x27;test-redis-module&#x27;,\n          username: encodeURIComponent(&#x27;default&#x27;),\n          password: encodeURIComponent(&#x27;123456&#x27;),\n          host: global.hostContainer,\n          port: parseInt(&#x27;6379&#x27;, 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, async () =&gt; {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it(&#x27;should be return echo&#x27;, async () =&gt; {\n    const msg = &#x27;hello world&#x27;;\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it(&#x27;should be return false if key dont exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return OK when set value in redis&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKey&#x27;, &#x27;hello world&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return value of key&#x27;, async () =&gt; {\n    expect(await service.get(&#x27;myKey&#x27;)).toEqual(&#x27;hello world&#x27;);\n  });\n\n  it(&#x27;should be return true if key exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be set value in redis with expiration date&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKeyEx&#x27;, &#x27;hello world&#x27;, 2)).toEqual(&#x27;OK&#x27;);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey&#x27;, &#x27;copyKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be return false when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey2&#x27;, &#x27;copyKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be rename a key&#x27;, async () =&gt; {\n    expect(await service.rename(&#x27;copyKey&#x27;, &#x27;newKey&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return false when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;testKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;newKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be flush all&#x27;, async () =&gt; {\n    expect(await service.flushAll()).toEqual(&#x27;OK&#x27;);\n    expect(await service.get(&#x27;myKey&#x27;)).toBeNull();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;8f8d6e6a-b170-469f-86a3-efca036be45c&quot;,&quot;parentUUID&quot;:&quot;ed52d5e4-01de-481b-ad2c-470378e0d014&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;RedisService &gt; should be return echo&quot;,&quot;title&quot;:&quot;RedisService &gt; should be return echo&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { delay, tcName, TCRedisOptions, testContainers } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { RedisModule } from &#x27;../redis/redis.module&#x27;;\nimport { RedisService } from &#x27;../redis/services/redis.service&#x27;;\n\ndescribe(&#x27;RedisService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () =&gt; {\n    container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n      ...TCRedisOptions,\n      command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: &#x27;test-redis-module&#x27;,\n          username: encodeURIComponent(&#x27;default&#x27;),\n          password: encodeURIComponent(&#x27;123456&#x27;),\n          host: global.hostContainer,\n          port: parseInt(&#x27;6379&#x27;, 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, async () =&gt; {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it(&#x27;should be return echo&#x27;, async () =&gt; {\n    const msg = &#x27;hello world&#x27;;\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it(&#x27;should be return false if key dont exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return OK when set value in redis&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKey&#x27;, &#x27;hello world&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return value of key&#x27;, async () =&gt; {\n    expect(await service.get(&#x27;myKey&#x27;)).toEqual(&#x27;hello world&#x27;);\n  });\n\n  it(&#x27;should be return true if key exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be set value in redis with expiration date&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKeyEx&#x27;, &#x27;hello world&#x27;, 2)).toEqual(&#x27;OK&#x27;);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey&#x27;, &#x27;copyKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be return false when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey2&#x27;, &#x27;copyKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be rename a key&#x27;, async () =&gt; {\n    expect(await service.rename(&#x27;copyKey&#x27;, &#x27;newKey&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return false when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;testKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;newKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be flush all&#x27;, async () =&gt; {\n    expect(await service.flushAll()).toEqual(&#x27;OK&#x27;);\n    expect(await service.get(&#x27;myKey&#x27;)).toBeNull();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4bc0dbf0-85f9-43ff-b423-d91c7d05aad1&quot;,&quot;parentUUID&quot;:&quot;ed52d5e4-01de-481b-ad2c-470378e0d014&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;RedisService &gt; should be return false if key dont exist in redis&quot;,&quot;title&quot;:&quot;RedisService &gt; should be return false if key dont exist in redis&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { delay, tcName, TCRedisOptions, testContainers } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { RedisModule } from &#x27;../redis/redis.module&#x27;;\nimport { RedisService } from &#x27;../redis/services/redis.service&#x27;;\n\ndescribe(&#x27;RedisService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () =&gt; {\n    container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n      ...TCRedisOptions,\n      command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: &#x27;test-redis-module&#x27;,\n          username: encodeURIComponent(&#x27;default&#x27;),\n          password: encodeURIComponent(&#x27;123456&#x27;),\n          host: global.hostContainer,\n          port: parseInt(&#x27;6379&#x27;, 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, async () =&gt; {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it(&#x27;should be return echo&#x27;, async () =&gt; {\n    const msg = &#x27;hello world&#x27;;\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it(&#x27;should be return false if key dont exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return OK when set value in redis&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKey&#x27;, &#x27;hello world&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return value of key&#x27;, async () =&gt; {\n    expect(await service.get(&#x27;myKey&#x27;)).toEqual(&#x27;hello world&#x27;);\n  });\n\n  it(&#x27;should be return true if key exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be set value in redis with expiration date&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKeyEx&#x27;, &#x27;hello world&#x27;, 2)).toEqual(&#x27;OK&#x27;);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey&#x27;, &#x27;copyKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be return false when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey2&#x27;, &#x27;copyKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be rename a key&#x27;, async () =&gt; {\n    expect(await service.rename(&#x27;copyKey&#x27;, &#x27;newKey&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return false when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;testKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;newKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be flush all&#x27;, async () =&gt; {\n    expect(await service.flushAll()).toEqual(&#x27;OK&#x27;);\n    expect(await service.get(&#x27;myKey&#x27;)).toBeNull();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9fd83323-127c-4ce6-bc28-b60e5c5dac6d&quot;,&quot;parentUUID&quot;:&quot;ed52d5e4-01de-481b-ad2c-470378e0d014&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;RedisService &gt; should be return OK when set value in redis&quot;,&quot;title&quot;:&quot;RedisService &gt; should be return OK when set value in redis&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:11,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { delay, tcName, TCRedisOptions, testContainers } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { RedisModule } from &#x27;../redis/redis.module&#x27;;\nimport { RedisService } from &#x27;../redis/services/redis.service&#x27;;\n\ndescribe(&#x27;RedisService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () =&gt; {\n    container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n      ...TCRedisOptions,\n      command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: &#x27;test-redis-module&#x27;,\n          username: encodeURIComponent(&#x27;default&#x27;),\n          password: encodeURIComponent(&#x27;123456&#x27;),\n          host: global.hostContainer,\n          port: parseInt(&#x27;6379&#x27;, 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, async () =&gt; {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it(&#x27;should be return echo&#x27;, async () =&gt; {\n    const msg = &#x27;hello world&#x27;;\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it(&#x27;should be return false if key dont exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return OK when set value in redis&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKey&#x27;, &#x27;hello world&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return value of key&#x27;, async () =&gt; {\n    expect(await service.get(&#x27;myKey&#x27;)).toEqual(&#x27;hello world&#x27;);\n  });\n\n  it(&#x27;should be return true if key exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be set value in redis with expiration date&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKeyEx&#x27;, &#x27;hello world&#x27;, 2)).toEqual(&#x27;OK&#x27;);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey&#x27;, &#x27;copyKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be return false when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey2&#x27;, &#x27;copyKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be rename a key&#x27;, async () =&gt; {\n    expect(await service.rename(&#x27;copyKey&#x27;, &#x27;newKey&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return false when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;testKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;newKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be flush all&#x27;, async () =&gt; {\n    expect(await service.flushAll()).toEqual(&#x27;OK&#x27;);\n    expect(await service.get(&#x27;myKey&#x27;)).toBeNull();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;36ecfada-6161-43fa-b586-bc1730b59f16&quot;,&quot;parentUUID&quot;:&quot;ed52d5e4-01de-481b-ad2c-470378e0d014&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;RedisService &gt; should be return value of key&quot;,&quot;title&quot;:&quot;RedisService &gt; should be return value of key&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { delay, tcName, TCRedisOptions, testContainers } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { RedisModule } from &#x27;../redis/redis.module&#x27;;\nimport { RedisService } from &#x27;../redis/services/redis.service&#x27;;\n\ndescribe(&#x27;RedisService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () =&gt; {\n    container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n      ...TCRedisOptions,\n      command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: &#x27;test-redis-module&#x27;,\n          username: encodeURIComponent(&#x27;default&#x27;),\n          password: encodeURIComponent(&#x27;123456&#x27;),\n          host: global.hostContainer,\n          port: parseInt(&#x27;6379&#x27;, 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, async () =&gt; {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it(&#x27;should be return echo&#x27;, async () =&gt; {\n    const msg = &#x27;hello world&#x27;;\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it(&#x27;should be return false if key dont exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return OK when set value in redis&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKey&#x27;, &#x27;hello world&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return value of key&#x27;, async () =&gt; {\n    expect(await service.get(&#x27;myKey&#x27;)).toEqual(&#x27;hello world&#x27;);\n  });\n\n  it(&#x27;should be return true if key exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be set value in redis with expiration date&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKeyEx&#x27;, &#x27;hello world&#x27;, 2)).toEqual(&#x27;OK&#x27;);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey&#x27;, &#x27;copyKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be return false when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey2&#x27;, &#x27;copyKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be rename a key&#x27;, async () =&gt; {\n    expect(await service.rename(&#x27;copyKey&#x27;, &#x27;newKey&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return false when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;testKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;newKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be flush all&#x27;, async () =&gt; {\n    expect(await service.flushAll()).toEqual(&#x27;OK&#x27;);\n    expect(await service.get(&#x27;myKey&#x27;)).toBeNull();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9b08764f-fb2a-424c-b617-8d0b3f587376&quot;,&quot;parentUUID&quot;:&quot;ed52d5e4-01de-481b-ad2c-470378e0d014&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;RedisService &gt; should be return true if key exist in redis&quot;,&quot;title&quot;:&quot;RedisService &gt; should be return true if key exist in redis&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { delay, tcName, TCRedisOptions, testContainers } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { RedisModule } from &#x27;../redis/redis.module&#x27;;\nimport { RedisService } from &#x27;../redis/services/redis.service&#x27;;\n\ndescribe(&#x27;RedisService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () =&gt; {\n    container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n      ...TCRedisOptions,\n      command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: &#x27;test-redis-module&#x27;,\n          username: encodeURIComponent(&#x27;default&#x27;),\n          password: encodeURIComponent(&#x27;123456&#x27;),\n          host: global.hostContainer,\n          port: parseInt(&#x27;6379&#x27;, 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, async () =&gt; {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it(&#x27;should be return echo&#x27;, async () =&gt; {\n    const msg = &#x27;hello world&#x27;;\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it(&#x27;should be return false if key dont exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return OK when set value in redis&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKey&#x27;, &#x27;hello world&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return value of key&#x27;, async () =&gt; {\n    expect(await service.get(&#x27;myKey&#x27;)).toEqual(&#x27;hello world&#x27;);\n  });\n\n  it(&#x27;should be return true if key exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be set value in redis with expiration date&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKeyEx&#x27;, &#x27;hello world&#x27;, 2)).toEqual(&#x27;OK&#x27;);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey&#x27;, &#x27;copyKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be return false when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey2&#x27;, &#x27;copyKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be rename a key&#x27;, async () =&gt; {\n    expect(await service.rename(&#x27;copyKey&#x27;, &#x27;newKey&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return false when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;testKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;newKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be flush all&#x27;, async () =&gt; {\n    expect(await service.flushAll()).toEqual(&#x27;OK&#x27;);\n    expect(await service.get(&#x27;myKey&#x27;)).toBeNull();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d3a59d24-2ebb-49ca-b805-cbb1854af140&quot;,&quot;parentUUID&quot;:&quot;ed52d5e4-01de-481b-ad2c-470378e0d014&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;RedisService &gt; should be set value in redis with expiration date&quot;,&quot;title&quot;:&quot;RedisService &gt; should be set value in redis with expiration date&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3013,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { delay, tcName, TCRedisOptions, testContainers } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { RedisModule } from &#x27;../redis/redis.module&#x27;;\nimport { RedisService } from &#x27;../redis/services/redis.service&#x27;;\n\ndescribe(&#x27;RedisService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () =&gt; {\n    container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n      ...TCRedisOptions,\n      command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: &#x27;test-redis-module&#x27;,\n          username: encodeURIComponent(&#x27;default&#x27;),\n          password: encodeURIComponent(&#x27;123456&#x27;),\n          host: global.hostContainer,\n          port: parseInt(&#x27;6379&#x27;, 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, async () =&gt; {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it(&#x27;should be return echo&#x27;, async () =&gt; {\n    const msg = &#x27;hello world&#x27;;\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it(&#x27;should be return false if key dont exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return OK when set value in redis&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKey&#x27;, &#x27;hello world&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return value of key&#x27;, async () =&gt; {\n    expect(await service.get(&#x27;myKey&#x27;)).toEqual(&#x27;hello world&#x27;);\n  });\n\n  it(&#x27;should be return true if key exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be set value in redis with expiration date&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKeyEx&#x27;, &#x27;hello world&#x27;, 2)).toEqual(&#x27;OK&#x27;);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey&#x27;, &#x27;copyKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be return false when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey2&#x27;, &#x27;copyKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be rename a key&#x27;, async () =&gt; {\n    expect(await service.rename(&#x27;copyKey&#x27;, &#x27;newKey&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return false when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;testKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;newKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be flush all&#x27;, async () =&gt; {\n    expect(await service.flushAll()).toEqual(&#x27;OK&#x27;);\n    expect(await service.get(&#x27;myKey&#x27;)).toBeNull();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;904f11bd-fef6-48c4-b3c6-fd49bb4a17f3&quot;,&quot;parentUUID&quot;:&quot;ed52d5e4-01de-481b-ad2c-470378e0d014&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;RedisService &gt; should be return true when copy key&quot;,&quot;title&quot;:&quot;RedisService &gt; should be return true when copy key&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { delay, tcName, TCRedisOptions, testContainers } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { RedisModule } from &#x27;../redis/redis.module&#x27;;\nimport { RedisService } from &#x27;../redis/services/redis.service&#x27;;\n\ndescribe(&#x27;RedisService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () =&gt; {\n    container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n      ...TCRedisOptions,\n      command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: &#x27;test-redis-module&#x27;,\n          username: encodeURIComponent(&#x27;default&#x27;),\n          password: encodeURIComponent(&#x27;123456&#x27;),\n          host: global.hostContainer,\n          port: parseInt(&#x27;6379&#x27;, 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, async () =&gt; {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it(&#x27;should be return echo&#x27;, async () =&gt; {\n    const msg = &#x27;hello world&#x27;;\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it(&#x27;should be return false if key dont exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return OK when set value in redis&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKey&#x27;, &#x27;hello world&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return value of key&#x27;, async () =&gt; {\n    expect(await service.get(&#x27;myKey&#x27;)).toEqual(&#x27;hello world&#x27;);\n  });\n\n  it(&#x27;should be return true if key exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be set value in redis with expiration date&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKeyEx&#x27;, &#x27;hello world&#x27;, 2)).toEqual(&#x27;OK&#x27;);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey&#x27;, &#x27;copyKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be return false when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey2&#x27;, &#x27;copyKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be rename a key&#x27;, async () =&gt; {\n    expect(await service.rename(&#x27;copyKey&#x27;, &#x27;newKey&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return false when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;testKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;newKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be flush all&#x27;, async () =&gt; {\n    expect(await service.flushAll()).toEqual(&#x27;OK&#x27;);\n    expect(await service.get(&#x27;myKey&#x27;)).toBeNull();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3667b2ba-ec3d-4be1-9565-10768be81e60&quot;,&quot;parentUUID&quot;:&quot;ed52d5e4-01de-481b-ad2c-470378e0d014&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;RedisService &gt; should be return false when copy key&quot;,&quot;title&quot;:&quot;RedisService &gt; should be return false when copy key&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:12,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { delay, tcName, TCRedisOptions, testContainers } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { RedisModule } from &#x27;../redis/redis.module&#x27;;\nimport { RedisService } from &#x27;../redis/services/redis.service&#x27;;\n\ndescribe(&#x27;RedisService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () =&gt; {\n    container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n      ...TCRedisOptions,\n      command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: &#x27;test-redis-module&#x27;,\n          username: encodeURIComponent(&#x27;default&#x27;),\n          password: encodeURIComponent(&#x27;123456&#x27;),\n          host: global.hostContainer,\n          port: parseInt(&#x27;6379&#x27;, 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, async () =&gt; {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it(&#x27;should be return echo&#x27;, async () =&gt; {\n    const msg = &#x27;hello world&#x27;;\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it(&#x27;should be return false if key dont exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return OK when set value in redis&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKey&#x27;, &#x27;hello world&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return value of key&#x27;, async () =&gt; {\n    expect(await service.get(&#x27;myKey&#x27;)).toEqual(&#x27;hello world&#x27;);\n  });\n\n  it(&#x27;should be return true if key exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be set value in redis with expiration date&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKeyEx&#x27;, &#x27;hello world&#x27;, 2)).toEqual(&#x27;OK&#x27;);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey&#x27;, &#x27;copyKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be return false when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey2&#x27;, &#x27;copyKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be rename a key&#x27;, async () =&gt; {\n    expect(await service.rename(&#x27;copyKey&#x27;, &#x27;newKey&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return false when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;testKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;newKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be flush all&#x27;, async () =&gt; {\n    expect(await service.flushAll()).toEqual(&#x27;OK&#x27;);\n    expect(await service.get(&#x27;myKey&#x27;)).toBeNull();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;58ec4d79-395e-4977-94b2-7e16df70158d&quot;,&quot;parentUUID&quot;:&quot;ed52d5e4-01de-481b-ad2c-470378e0d014&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;RedisService &gt; should be rename a key&quot;,&quot;title&quot;:&quot;RedisService &gt; should be rename a key&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:11,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { delay, tcName, TCRedisOptions, testContainers } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { RedisModule } from &#x27;../redis/redis.module&#x27;;\nimport { RedisService } from &#x27;../redis/services/redis.service&#x27;;\n\ndescribe(&#x27;RedisService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () =&gt; {\n    container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n      ...TCRedisOptions,\n      command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: &#x27;test-redis-module&#x27;,\n          username: encodeURIComponent(&#x27;default&#x27;),\n          password: encodeURIComponent(&#x27;123456&#x27;),\n          host: global.hostContainer,\n          port: parseInt(&#x27;6379&#x27;, 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, async () =&gt; {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it(&#x27;should be return echo&#x27;, async () =&gt; {\n    const msg = &#x27;hello world&#x27;;\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it(&#x27;should be return false if key dont exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return OK when set value in redis&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKey&#x27;, &#x27;hello world&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return value of key&#x27;, async () =&gt; {\n    expect(await service.get(&#x27;myKey&#x27;)).toEqual(&#x27;hello world&#x27;);\n  });\n\n  it(&#x27;should be return true if key exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be set value in redis with expiration date&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKeyEx&#x27;, &#x27;hello world&#x27;, 2)).toEqual(&#x27;OK&#x27;);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey&#x27;, &#x27;copyKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be return false when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey2&#x27;, &#x27;copyKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be rename a key&#x27;, async () =&gt; {\n    expect(await service.rename(&#x27;copyKey&#x27;, &#x27;newKey&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return false when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;testKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;newKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be flush all&#x27;, async () =&gt; {\n    expect(await service.flushAll()).toEqual(&#x27;OK&#x27;);\n    expect(await service.get(&#x27;myKey&#x27;)).toBeNull();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d602b3fc-cec2-40eb-a9fa-119dce319768&quot;,&quot;parentUUID&quot;:&quot;ed52d5e4-01de-481b-ad2c-470378e0d014&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;RedisService &gt; should be return false when delete a key&quot;,&quot;title&quot;:&quot;RedisService &gt; should be return false when delete a key&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { delay, tcName, TCRedisOptions, testContainers } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { RedisModule } from &#x27;../redis/redis.module&#x27;;\nimport { RedisService } from &#x27;../redis/services/redis.service&#x27;;\n\ndescribe(&#x27;RedisService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () =&gt; {\n    container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n      ...TCRedisOptions,\n      command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: &#x27;test-redis-module&#x27;,\n          username: encodeURIComponent(&#x27;default&#x27;),\n          password: encodeURIComponent(&#x27;123456&#x27;),\n          host: global.hostContainer,\n          port: parseInt(&#x27;6379&#x27;, 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, async () =&gt; {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it(&#x27;should be return echo&#x27;, async () =&gt; {\n    const msg = &#x27;hello world&#x27;;\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it(&#x27;should be return false if key dont exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return OK when set value in redis&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKey&#x27;, &#x27;hello world&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return value of key&#x27;, async () =&gt; {\n    expect(await service.get(&#x27;myKey&#x27;)).toEqual(&#x27;hello world&#x27;);\n  });\n\n  it(&#x27;should be return true if key exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be set value in redis with expiration date&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKeyEx&#x27;, &#x27;hello world&#x27;, 2)).toEqual(&#x27;OK&#x27;);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey&#x27;, &#x27;copyKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be return false when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey2&#x27;, &#x27;copyKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be rename a key&#x27;, async () =&gt; {\n    expect(await service.rename(&#x27;copyKey&#x27;, &#x27;newKey&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return false when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;testKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;newKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be flush all&#x27;, async () =&gt; {\n    expect(await service.flushAll()).toEqual(&#x27;OK&#x27;);\n    expect(await service.get(&#x27;myKey&#x27;)).toBeNull();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;cefc2db0-9b69-4ae9-8445-75a28b8abb76&quot;,&quot;parentUUID&quot;:&quot;ed52d5e4-01de-481b-ad2c-470378e0d014&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;RedisService &gt; should be return true when delete a key&quot;,&quot;title&quot;:&quot;RedisService &gt; should be return true when delete a key&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { delay, tcName, TCRedisOptions, testContainers } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { RedisModule } from &#x27;../redis/redis.module&#x27;;\nimport { RedisService } from &#x27;../redis/services/redis.service&#x27;;\n\ndescribe(&#x27;RedisService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () =&gt; {\n    container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n      ...TCRedisOptions,\n      command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: &#x27;test-redis-module&#x27;,\n          username: encodeURIComponent(&#x27;default&#x27;),\n          password: encodeURIComponent(&#x27;123456&#x27;),\n          host: global.hostContainer,\n          port: parseInt(&#x27;6379&#x27;, 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, async () =&gt; {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it(&#x27;should be return echo&#x27;, async () =&gt; {\n    const msg = &#x27;hello world&#x27;;\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it(&#x27;should be return false if key dont exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return OK when set value in redis&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKey&#x27;, &#x27;hello world&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return value of key&#x27;, async () =&gt; {\n    expect(await service.get(&#x27;myKey&#x27;)).toEqual(&#x27;hello world&#x27;);\n  });\n\n  it(&#x27;should be return true if key exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be set value in redis with expiration date&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKeyEx&#x27;, &#x27;hello world&#x27;, 2)).toEqual(&#x27;OK&#x27;);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey&#x27;, &#x27;copyKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be return false when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey2&#x27;, &#x27;copyKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be rename a key&#x27;, async () =&gt; {\n    expect(await service.rename(&#x27;copyKey&#x27;, &#x27;newKey&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return false when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;testKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;newKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be flush all&#x27;, async () =&gt; {\n    expect(await service.flushAll()).toEqual(&#x27;OK&#x27;);\n    expect(await service.get(&#x27;myKey&#x27;)).toBeNull();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;bcb3aa50-4314-4864-970f-7b0db8dc8cc0&quot;,&quot;parentUUID&quot;:&quot;ed52d5e4-01de-481b-ad2c-470378e0d014&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;RedisService &gt; should be flush all&quot;,&quot;title&quot;:&quot;RedisService &gt; should be flush all&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:12,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { delay, tcName, TCRedisOptions, testContainers } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { RedisModule } from &#x27;../redis/redis.module&#x27;;\nimport { RedisService } from &#x27;../redis/services/redis.service&#x27;;\n\ndescribe(&#x27;RedisService&#x27;, () =&gt; {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () =&gt; {\n    container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n      ...TCRedisOptions,\n      command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () =&gt; {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () =&gt; {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: &#x27;test-redis-module&#x27;,\n          username: encodeURIComponent(&#x27;default&#x27;),\n          password: encodeURIComponent(&#x27;123456&#x27;),\n          host: global.hostContainer,\n          port: parseInt(&#x27;6379&#x27;, 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () =&gt; {\n    await app.close();\n  });\n\n  it(&#x27;should be defined&#x27;, async () =&gt; {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it(&#x27;should be return echo&#x27;, async () =&gt; {\n    const msg = &#x27;hello world&#x27;;\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it(&#x27;should be return false if key dont exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return OK when set value in redis&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKey&#x27;, &#x27;hello world&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return value of key&#x27;, async () =&gt; {\n    expect(await service.get(&#x27;myKey&#x27;)).toEqual(&#x27;hello world&#x27;);\n  });\n\n  it(&#x27;should be return true if key exist in redis&#x27;, async () =&gt; {\n    expect(await service.exists(&#x27;myKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be set value in redis with expiration date&#x27;, async () =&gt; {\n    expect(await service.set(&#x27;myKeyEx&#x27;, &#x27;hello world&#x27;, 2)).toEqual(&#x27;OK&#x27;);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists(&#x27;myKeyEx&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey&#x27;, &#x27;copyKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be return false when copy key&#x27;, async () =&gt; {\n    expect(await service.copy(&#x27;myKey2&#x27;, &#x27;copyKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be rename a key&#x27;, async () =&gt; {\n    expect(await service.rename(&#x27;copyKey&#x27;, &#x27;newKey&#x27;)).toEqual(&#x27;OK&#x27;);\n  });\n\n  it(&#x27;should be return false when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;testKey&#x27;)).toBeFalsy();\n  });\n\n  it(&#x27;should be return true when delete a key&#x27;, async () =&gt; {\n    expect(await service.del(&#x27;newKey&#x27;)).toBeTruthy();\n  });\n\n  it(&#x27;should be flush all&#x27;, async () =&gt; {\n    expect(await service.flushAll()).toEqual(&#x27;OK&#x27;);\n    expect(await service.get(&#x27;myKey&#x27;)).toBeNull();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;06a98bfb-380f-4687-9293-140cac85e03c&quot;,&quot;parentUUID&quot;:&quot;ed52d5e4-01de-481b-ad2c-470378e0d014&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;RedisModule &gt; with auth &gt; forRootAsync &gt; should be defined&quot;,&quot;title&quot;:&quot;RedisModule &gt; with auth &gt; forRootAsync &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:90,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport { tcName, TCRedisOptions, testContainers } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\n\nimport { RedisModule } from &#x27;../redis/redis.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;RedisModule&#x27;, () =&gt; {\n  describe(&#x27;with auth&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n        containerName: `${tcName}-redis-module-with-auth`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    describe(&#x27;forRootAsync&#x27;, () =&gt; {\n      beforeEach(async () =&gt; {\n        const module: TestingModule = await Test.createTestingModule({\n          imports: [\n            ConfigModule.forRoot({\n              isGlobal: true,\n              load: [config],\n            }),\n            RedisModule,\n          ],\n        }).compile();\n\n        app = module.createNestApplication();\n        await app.init();\n      });\n\n      afterEach(async () =&gt; {\n        await app.close();\n      });\n\n      it(&#x27;should be defined&#x27;, async () =&gt; {\n        await expect(app).toBeDefined();\n      }, 50000);\n    });\n\n    describe(&#x27;register&#x27;, () =&gt; {\n      beforeEach(async () =&gt; {\n        const module: TestingModule = await Test.createTestingModule({\n          imports: [\n            RedisModule.register({\n              name: &#x27;test-redis-module&#x27;,\n              username: encodeURIComponent(&#x27;default&#x27;),\n              password: encodeURIComponent(&#x27;123456&#x27;),\n              host: global.hostContainer,\n              port: parseInt(&#x27;6379&#x27;, 10),\n            }),\n          ],\n        }).compile();\n\n        app = module.createNestApplication();\n        await app.init();\n      });\n\n      afterEach(async () =&gt; {\n        await app.close();\n      });\n\n      it(&#x27;should be defined&#x27;, async () =&gt; {\n        await expect(app).toBeDefined();\n      }, 50000);\n    });\n  });\n\n  describe(&#x27;without auth&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        containerName: `${tcName}-redis-module-without-auth`,\n        envs: {},\n        ports: [\n          {\n            container: 6379,\n            host: 6380,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          RedisModule.register({\n            host: global.hostContainer,\n            port: parseInt(&#x27;6380&#x27;, 10),\n            database: 1,\n          }),\n        ],\n      }).compile();\n\n      app = module.createNestApplication();\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;55188c8f-9a18-4c5b-93a7-2da973ebd944&quot;,&quot;parentUUID&quot;:&quot;ed52d5e4-01de-481b-ad2c-470378e0d014&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;RedisModule &gt; with auth &gt; register &gt; should be defined&quot;,&quot;title&quot;:&quot;RedisModule &gt; with auth &gt; register &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:11,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport { tcName, TCRedisOptions, testContainers } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\n\nimport { RedisModule } from &#x27;../redis/redis.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;RedisModule&#x27;, () =&gt; {\n  describe(&#x27;with auth&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n        containerName: `${tcName}-redis-module-with-auth`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    describe(&#x27;forRootAsync&#x27;, () =&gt; {\n      beforeEach(async () =&gt; {\n        const module: TestingModule = await Test.createTestingModule({\n          imports: [\n            ConfigModule.forRoot({\n              isGlobal: true,\n              load: [config],\n            }),\n            RedisModule,\n          ],\n        }).compile();\n\n        app = module.createNestApplication();\n        await app.init();\n      });\n\n      afterEach(async () =&gt; {\n        await app.close();\n      });\n\n      it(&#x27;should be defined&#x27;, async () =&gt; {\n        await expect(app).toBeDefined();\n      }, 50000);\n    });\n\n    describe(&#x27;register&#x27;, () =&gt; {\n      beforeEach(async () =&gt; {\n        const module: TestingModule = await Test.createTestingModule({\n          imports: [\n            RedisModule.register({\n              name: &#x27;test-redis-module&#x27;,\n              username: encodeURIComponent(&#x27;default&#x27;),\n              password: encodeURIComponent(&#x27;123456&#x27;),\n              host: global.hostContainer,\n              port: parseInt(&#x27;6379&#x27;, 10),\n            }),\n          ],\n        }).compile();\n\n        app = module.createNestApplication();\n        await app.init();\n      });\n\n      afterEach(async () =&gt; {\n        await app.close();\n      });\n\n      it(&#x27;should be defined&#x27;, async () =&gt; {\n        await expect(app).toBeDefined();\n      }, 50000);\n    });\n  });\n\n  describe(&#x27;without auth&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        containerName: `${tcName}-redis-module-without-auth`,\n        envs: {},\n        ports: [\n          {\n            container: 6379,\n            host: 6380,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          RedisModule.register({\n            host: global.hostContainer,\n            port: parseInt(&#x27;6380&#x27;, 10),\n            database: 1,\n          }),\n        ],\n      }).compile();\n\n      app = module.createNestApplication();\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;90601268-cd5e-4d0d-9365-9a15416f5753&quot;,&quot;parentUUID&quot;:&quot;ed52d5e4-01de-481b-ad2c-470378e0d014&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;RedisModule &gt; without auth &gt; should be defined&quot;,&quot;title&quot;:&quot;RedisModule &gt; without auth &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport { tcName, TCRedisOptions, testContainers } from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\n\nimport { RedisModule } from &#x27;../redis/redis.module&#x27;;\nimport { config } from &#x27;./utils&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;RedisModule&#x27;, () =&gt; {\n  describe(&#x27;with auth&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n        containerName: `${tcName}-redis-module-with-auth`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    describe(&#x27;forRootAsync&#x27;, () =&gt; {\n      beforeEach(async () =&gt; {\n        const module: TestingModule = await Test.createTestingModule({\n          imports: [\n            ConfigModule.forRoot({\n              isGlobal: true,\n              load: [config],\n            }),\n            RedisModule,\n          ],\n        }).compile();\n\n        app = module.createNestApplication();\n        await app.init();\n      });\n\n      afterEach(async () =&gt; {\n        await app.close();\n      });\n\n      it(&#x27;should be defined&#x27;, async () =&gt; {\n        await expect(app).toBeDefined();\n      }, 50000);\n    });\n\n    describe(&#x27;register&#x27;, () =&gt; {\n      beforeEach(async () =&gt; {\n        const module: TestingModule = await Test.createTestingModule({\n          imports: [\n            RedisModule.register({\n              name: &#x27;test-redis-module&#x27;,\n              username: encodeURIComponent(&#x27;default&#x27;),\n              password: encodeURIComponent(&#x27;123456&#x27;),\n              host: global.hostContainer,\n              port: parseInt(&#x27;6379&#x27;, 10),\n            }),\n          ],\n        }).compile();\n\n        app = module.createNestApplication();\n        await app.init();\n      });\n\n      afterEach(async () =&gt; {\n        await app.close();\n      });\n\n      it(&#x27;should be defined&#x27;, async () =&gt; {\n        await expect(app).toBeDefined();\n      }, 50000);\n    });\n  });\n\n  describe(&#x27;without auth&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        containerName: `${tcName}-redis-module-without-auth`,\n        envs: {},\n        ports: [\n          {\n            container: 6379,\n            host: 6380,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          RedisModule.register({\n            host: global.hostContainer,\n            port: parseInt(&#x27;6380&#x27;, 10),\n            database: 1,\n          }),\n        ],\n      }).compile();\n\n      app = module.createNestApplication();\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e3cae4bc-1561-4865-8a9c-5fa3ca0b6c07&quot;,&quot;parentUUID&quot;:&quot;ed52d5e4-01de-481b-ad2c-470378e0d014&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;8f8d6e6a-b170-469f-86a3-efca036be45c&quot;,&quot;4bc0dbf0-85f9-43ff-b423-d91c7d05aad1&quot;,&quot;9fd83323-127c-4ce6-bc28-b60e5c5dac6d&quot;,&quot;36ecfada-6161-43fa-b586-bc1730b59f16&quot;,&quot;9b08764f-fb2a-424c-b617-8d0b3f587376&quot;,&quot;d3a59d24-2ebb-49ca-b805-cbb1854af140&quot;,&quot;904f11bd-fef6-48c4-b3c6-fd49bb4a17f3&quot;,&quot;3667b2ba-ec3d-4be1-9565-10768be81e60&quot;,&quot;58ec4d79-395e-4977-94b2-7e16df70158d&quot;,&quot;d602b3fc-cec2-40eb-a9fa-119dce319768&quot;,&quot;cefc2db0-9b69-4ae9-8445-75a28b8abb76&quot;,&quot;bcb3aa50-4314-4864-970f-7b0db8dc8cc0&quot;,&quot;06a98bfb-380f-4687-9293-140cac85e03c&quot;,&quot;55188c8f-9a18-4c5b-93a7-2da973ebd944&quot;,&quot;90601268-cd5e-4d0d-9365-9a15416f5753&quot;,&quot;e3cae4bc-1561-4865-8a9c-5fa3ca0b6c07&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:3583,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:5000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:5000},{&quot;uuid&quot;:&quot;4f14b01a-8d77-4b67-b9e4-0787fb38f919&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/response-parser&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;3dabf9e8-cc1d-49f2-bc0d-c3c0ecff7ae6&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/response-parser&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;fullTitle&quot;:&quot;ResponseInterceptor &gt; should be defined&quot;,&quot;title&quot;:&quot;ResponseInterceptor &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { ResponseInterceptor } from &#x27;../response/response.interceptor&#x27;;\nimport {\n  JestFN,\n  fixtureUserResponse,\n  fixtureUserArrayResponse,\n} from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { of } from &#x27;rxjs&#x27;;\n\nconst executionContext: any = JestFN.executionContext;\n\ndescribe(&#x27;ResponseInterceptor&#x27;, () =&gt; {\n  let interceptor = new ResponseInterceptor();\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(interceptor).toBeDefined();\n  });\n\n  it(&#x27;should return an ResponseInterceptor instance simple entity&#x27;, (done) =&gt; {\n    const callHandler: any = {\n      handle: jest.fn(() =&gt; of(fixtureUserResponse)),\n    };\n\n    const obs = interceptor.intercept(executionContext, callHandler);\n    expect(callHandler.handle).toBeCalledTimes(1);\n\n    obs.subscribe({\n      next: (value) =&gt; {\n        expect(value).toMatchObject(fixtureUserResponse);\n      },\n      error: (error) =&gt; {\n        throw error;\n      },\n      complete: () =&gt; {\n        done();\n      },\n    });\n  });\n\n  it(&#x27;should return an ResponseInterceptor instance multiple entity&#x27;, (done) =&gt; {\n    const callHandler: any = {\n      handle: jest.fn(() =&gt; of(fixtureUserArrayResponse)),\n    };\n    const obs = interceptor.intercept(executionContext, callHandler);\n    expect(callHandler.handle).toBeCalledTimes(1);\n\n    obs.subscribe({\n      next: (value) =&gt; {\n        expect(value).toMatchObject({ data: fixtureUserArrayResponse });\n      },\n      error: (error) =&gt; {\n        throw error;\n      },\n      complete: () =&gt; {\n        done();\n      },\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6c101314-bfbb-4c2d-9a18-b73993fd1446&quot;,&quot;parentUUID&quot;:&quot;3dabf9e8-cc1d-49f2-bc0d-c3c0ecff7ae6&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;ResponseInterceptor &gt; should return an ResponseInterceptor instance simple entity&quot;,&quot;title&quot;:&quot;ResponseInterceptor &gt; should return an ResponseInterceptor instance simple entity&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { ResponseInterceptor } from &#x27;../response/response.interceptor&#x27;;\nimport {\n  JestFN,\n  fixtureUserResponse,\n  fixtureUserArrayResponse,\n} from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { of } from &#x27;rxjs&#x27;;\n\nconst executionContext: any = JestFN.executionContext;\n\ndescribe(&#x27;ResponseInterceptor&#x27;, () =&gt; {\n  let interceptor = new ResponseInterceptor();\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(interceptor).toBeDefined();\n  });\n\n  it(&#x27;should return an ResponseInterceptor instance simple entity&#x27;, (done) =&gt; {\n    const callHandler: any = {\n      handle: jest.fn(() =&gt; of(fixtureUserResponse)),\n    };\n\n    const obs = interceptor.intercept(executionContext, callHandler);\n    expect(callHandler.handle).toBeCalledTimes(1);\n\n    obs.subscribe({\n      next: (value) =&gt; {\n        expect(value).toMatchObject(fixtureUserResponse);\n      },\n      error: (error) =&gt; {\n        throw error;\n      },\n      complete: () =&gt; {\n        done();\n      },\n    });\n  });\n\n  it(&#x27;should return an ResponseInterceptor instance multiple entity&#x27;, (done) =&gt; {\n    const callHandler: any = {\n      handle: jest.fn(() =&gt; of(fixtureUserArrayResponse)),\n    };\n    const obs = interceptor.intercept(executionContext, callHandler);\n    expect(callHandler.handle).toBeCalledTimes(1);\n\n    obs.subscribe({\n      next: (value) =&gt; {\n        expect(value).toMatchObject({ data: fixtureUserArrayResponse });\n      },\n      error: (error) =&gt; {\n        throw error;\n      },\n      complete: () =&gt; {\n        done();\n      },\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;fee506dd-2eca-4169-9338-c6d6325a89a8&quot;,&quot;parentUUID&quot;:&quot;3dabf9e8-cc1d-49f2-bc0d-c3c0ecff7ae6&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;ResponseInterceptor &gt; should return an ResponseInterceptor instance multiple entity&quot;,&quot;title&quot;:&quot;ResponseInterceptor &gt; should return an ResponseInterceptor instance multiple entity&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:0,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { ResponseInterceptor } from &#x27;../response/response.interceptor&#x27;;\nimport {\n  JestFN,\n  fixtureUserResponse,\n  fixtureUserArrayResponse,\n} from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { of } from &#x27;rxjs&#x27;;\n\nconst executionContext: any = JestFN.executionContext;\n\ndescribe(&#x27;ResponseInterceptor&#x27;, () =&gt; {\n  let interceptor = new ResponseInterceptor();\n\n  it(&#x27;should be defined&#x27;, () =&gt; {\n    expect(interceptor).toBeDefined();\n  });\n\n  it(&#x27;should return an ResponseInterceptor instance simple entity&#x27;, (done) =&gt; {\n    const callHandler: any = {\n      handle: jest.fn(() =&gt; of(fixtureUserResponse)),\n    };\n\n    const obs = interceptor.intercept(executionContext, callHandler);\n    expect(callHandler.handle).toBeCalledTimes(1);\n\n    obs.subscribe({\n      next: (value) =&gt; {\n        expect(value).toMatchObject(fixtureUserResponse);\n      },\n      error: (error) =&gt; {\n        throw error;\n      },\n      complete: () =&gt; {\n        done();\n      },\n    });\n  });\n\n  it(&#x27;should return an ResponseInterceptor instance multiple entity&#x27;, (done) =&gt; {\n    const callHandler: any = {\n      handle: jest.fn(() =&gt; of(fixtureUserArrayResponse)),\n    };\n    const obs = interceptor.intercept(executionContext, callHandler);\n    expect(callHandler.handle).toBeCalledTimes(1);\n\n    obs.subscribe({\n      next: (value) =&gt; {\n        expect(value).toMatchObject({ data: fixtureUserArrayResponse });\n      },\n      error: (error) =&gt; {\n        throw error;\n      },\n      complete: () =&gt; {\n        done();\n      },\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4609300b-01ed-4bc6-8936-95d386da6dc3&quot;,&quot;parentUUID&quot;:&quot;3dabf9e8-cc1d-49f2-bc0d-c3c0ecff7ae6&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;6c101314-bfbb-4c2d-9a18-b73993fd1446&quot;,&quot;fee506dd-2eca-4169-9338-c6d6325a89a8&quot;,&quot;4609300b-01ed-4bc6-8936-95d386da6dc3&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:5,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:5000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:5000},{&quot;uuid&quot;:&quot;33d839f2-4b85-4c52-a735-2d57fb203ae3&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/test-utils&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;5c887eb5-977e-4a72-bbd1-da842b7d1992&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/test-utils&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;fullTitle&quot;:&quot;globalTestContainers &gt; should be initialize service from docker-compose.yml&quot;,&quot;title&quot;:&quot;globalTestContainers &gt; should be initialize service from docker-compose.yml&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:12465,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { StartedDockerComposeEnvironment } from &#x27;testcontainers&#x27;;\nimport { closeDockerCompose, initDockerCompose } from &#x27;../testcontainers&#x27;;\nimport path from &#x27;path&#x27;;\n\ndescribe(&#x27;globalTestContainers&#x27;, () =&gt; {\n  const composeFilePath = path.resolve(__dirname, &#x27;..&#x27;, &#x27;fixtures&#x27;, &#x27;docker-compose&#x27;);\n  const composeFile = &#x27;docker-compose.yml&#x27;;\n\n  it(&#x27;should be initialize service from docker-compose.yml&#x27;, async () =&gt; {\n    const services = [&#x27;mongo&#x27;];\n    const environment: StartedDockerComposeEnvironment = await initDockerCompose(\n      services,\n      composeFilePath,\n      composeFile,\n    )();\n    expect(environment).toBeDefined();\n    expect(environment).toBeInstanceOf(StartedDockerComposeEnvironment);\n    await closeDockerCompose({ removeVolumes: true })();\n  });\n\n  it(&#x27;should be initialize all services from docker-compose.yml&#x27;, async () =&gt; {\n    const services = [];\n    const environment: StartedDockerComposeEnvironment = await initDockerCompose(\n      services,\n      composeFilePath,\n      composeFile,\n    )();\n    expect(environment).toBeDefined();\n    expect(environment).toBeInstanceOf(StartedDockerComposeEnvironment);\n    await closeDockerCompose({ removeVolumes: true })();\n  });\n\n  it(&#x27;should be initialize services from docker-compose.yml in default path and filename&#x27;, async () =&gt; {\n    const services = [];\n    const environment: StartedDockerComposeEnvironment = await initDockerCompose(services)();\n    expect(environment).toBeDefined();\n    expect(environment).toBeInstanceOf(StartedDockerComposeEnvironment);\n    await closeDockerCompose({ removeVolumes: true })();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;0cfdc5c7-f9da-46db-b066-f9bc9a67a9d1&quot;,&quot;parentUUID&quot;:&quot;5c887eb5-977e-4a72-bbd1-da842b7d1992&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;globalTestContainers &gt; should be initialize all services from docker-compose.yml&quot;,&quot;title&quot;:&quot;globalTestContainers &gt; should be initialize all services from docker-compose.yml&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13205,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { StartedDockerComposeEnvironment } from &#x27;testcontainers&#x27;;\nimport { closeDockerCompose, initDockerCompose } from &#x27;../testcontainers&#x27;;\nimport path from &#x27;path&#x27;;\n\ndescribe(&#x27;globalTestContainers&#x27;, () =&gt; {\n  const composeFilePath = path.resolve(__dirname, &#x27;..&#x27;, &#x27;fixtures&#x27;, &#x27;docker-compose&#x27;);\n  const composeFile = &#x27;docker-compose.yml&#x27;;\n\n  it(&#x27;should be initialize service from docker-compose.yml&#x27;, async () =&gt; {\n    const services = [&#x27;mongo&#x27;];\n    const environment: StartedDockerComposeEnvironment = await initDockerCompose(\n      services,\n      composeFilePath,\n      composeFile,\n    )();\n    expect(environment).toBeDefined();\n    expect(environment).toBeInstanceOf(StartedDockerComposeEnvironment);\n    await closeDockerCompose({ removeVolumes: true })();\n  });\n\n  it(&#x27;should be initialize all services from docker-compose.yml&#x27;, async () =&gt; {\n    const services = [];\n    const environment: StartedDockerComposeEnvironment = await initDockerCompose(\n      services,\n      composeFilePath,\n      composeFile,\n    )();\n    expect(environment).toBeDefined();\n    expect(environment).toBeInstanceOf(StartedDockerComposeEnvironment);\n    await closeDockerCompose({ removeVolumes: true })();\n  });\n\n  it(&#x27;should be initialize services from docker-compose.yml in default path and filename&#x27;, async () =&gt; {\n    const services = [];\n    const environment: StartedDockerComposeEnvironment = await initDockerCompose(services)();\n    expect(environment).toBeDefined();\n    expect(environment).toBeInstanceOf(StartedDockerComposeEnvironment);\n    await closeDockerCompose({ removeVolumes: true })();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f65528a0-d5e7-4213-821b-34d9039ba9b5&quot;,&quot;parentUUID&quot;:&quot;5c887eb5-977e-4a72-bbd1-da842b7d1992&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;globalTestContainers &gt; should be initialize services from docker-compose.yml in default path and filename&quot;,&quot;title&quot;:&quot;globalTestContainers &gt; should be initialize services from docker-compose.yml in default path and filename&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:11869,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { StartedDockerComposeEnvironment } from &#x27;testcontainers&#x27;;\nimport { closeDockerCompose, initDockerCompose } from &#x27;../testcontainers&#x27;;\nimport path from &#x27;path&#x27;;\n\ndescribe(&#x27;globalTestContainers&#x27;, () =&gt; {\n  const composeFilePath = path.resolve(__dirname, &#x27;..&#x27;, &#x27;fixtures&#x27;, &#x27;docker-compose&#x27;);\n  const composeFile = &#x27;docker-compose.yml&#x27;;\n\n  it(&#x27;should be initialize service from docker-compose.yml&#x27;, async () =&gt; {\n    const services = [&#x27;mongo&#x27;];\n    const environment: StartedDockerComposeEnvironment = await initDockerCompose(\n      services,\n      composeFilePath,\n      composeFile,\n    )();\n    expect(environment).toBeDefined();\n    expect(environment).toBeInstanceOf(StartedDockerComposeEnvironment);\n    await closeDockerCompose({ removeVolumes: true })();\n  });\n\n  it(&#x27;should be initialize all services from docker-compose.yml&#x27;, async () =&gt; {\n    const services = [];\n    const environment: StartedDockerComposeEnvironment = await initDockerCompose(\n      services,\n      composeFilePath,\n      composeFile,\n    )();\n    expect(environment).toBeDefined();\n    expect(environment).toBeInstanceOf(StartedDockerComposeEnvironment);\n    await closeDockerCompose({ removeVolumes: true })();\n  });\n\n  it(&#x27;should be initialize services from docker-compose.yml in default path and filename&#x27;, async () =&gt; {\n    const services = [];\n    const environment: StartedDockerComposeEnvironment = await initDockerCompose(services)();\n    expect(environment).toBeDefined();\n    expect(environment).toBeInstanceOf(StartedDockerComposeEnvironment);\n    await closeDockerCompose({ removeVolumes: true })();\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;73b4d2ec-8510-4e44-87cf-a5d2d491f16b&quot;,&quot;parentUUID&quot;:&quot;5c887eb5-977e-4a72-bbd1-da842b7d1992&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;TestContainers &gt; Redis &gt; should be defined&quot;,&quot;title&quot;:&quot;TestContainers &gt; Redis &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { testContainers } from &#x27;../testcontainers&#x27;;\nimport { StartedGenericContainer } from &#x27;testcontainers/dist/src/generic-container/started-generic-container&#x27;;\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from &#x27;../fixtures&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TestContainers&#x27;, () =&gt; {\n  describe(&#x27;Redis&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return exception of instance&#x27;, async () =&gt; {\n      try {\n        await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe(&#x27;Use testContainers.getInstance() instead of new.&#x27;);\n      }\n    });\n\n    it(&#x27;should be get instance of test container&#x27;, () =&gt; {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return envs of instance&#x27;, () =&gt; {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it(&#x27;should be return container instance&#x27;, () =&gt; {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it(&#x27;should be return host of container instance&#x27;, () =&gt; {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual(&#x27;localhost&#x27;);\n    });\n\n    it(&#x27;should be return name of container instance&#x27;, () =&gt; {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it(&#x27;should be return mapped port&#x27;, () =&gt; {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe(&#x27;DynamoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;amazon/dynamodb-local:latest&#x27;, {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MongoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;ElasticSearch&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;31ef60f8-b865-4d54-bb8b-c8ec22064298&quot;,&quot;parentUUID&quot;:&quot;5c887eb5-977e-4a72-bbd1-da842b7d1992&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;TestContainers &gt; Redis &gt; should be return exception of instance&quot;,&quot;title&quot;:&quot;TestContainers &gt; Redis &gt; should be return exception of instance&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:0,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { testContainers } from &#x27;../testcontainers&#x27;;\nimport { StartedGenericContainer } from &#x27;testcontainers/dist/src/generic-container/started-generic-container&#x27;;\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from &#x27;../fixtures&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TestContainers&#x27;, () =&gt; {\n  describe(&#x27;Redis&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return exception of instance&#x27;, async () =&gt; {\n      try {\n        await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe(&#x27;Use testContainers.getInstance() instead of new.&#x27;);\n      }\n    });\n\n    it(&#x27;should be get instance of test container&#x27;, () =&gt; {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return envs of instance&#x27;, () =&gt; {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it(&#x27;should be return container instance&#x27;, () =&gt; {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it(&#x27;should be return host of container instance&#x27;, () =&gt; {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual(&#x27;localhost&#x27;);\n    });\n\n    it(&#x27;should be return name of container instance&#x27;, () =&gt; {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it(&#x27;should be return mapped port&#x27;, () =&gt; {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe(&#x27;DynamoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;amazon/dynamodb-local:latest&#x27;, {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MongoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;ElasticSearch&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b0792a9d-2926-43f4-bbcd-fc24e344f8e9&quot;,&quot;parentUUID&quot;:&quot;5c887eb5-977e-4a72-bbd1-da842b7d1992&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;TestContainers &gt; Redis &gt; should be get instance of test container&quot;,&quot;title&quot;:&quot;TestContainers &gt; Redis &gt; should be get instance of test container&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { testContainers } from &#x27;../testcontainers&#x27;;\nimport { StartedGenericContainer } from &#x27;testcontainers/dist/src/generic-container/started-generic-container&#x27;;\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from &#x27;../fixtures&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TestContainers&#x27;, () =&gt; {\n  describe(&#x27;Redis&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return exception of instance&#x27;, async () =&gt; {\n      try {\n        await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe(&#x27;Use testContainers.getInstance() instead of new.&#x27;);\n      }\n    });\n\n    it(&#x27;should be get instance of test container&#x27;, () =&gt; {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return envs of instance&#x27;, () =&gt; {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it(&#x27;should be return container instance&#x27;, () =&gt; {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it(&#x27;should be return host of container instance&#x27;, () =&gt; {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual(&#x27;localhost&#x27;);\n    });\n\n    it(&#x27;should be return name of container instance&#x27;, () =&gt; {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it(&#x27;should be return mapped port&#x27;, () =&gt; {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe(&#x27;DynamoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;amazon/dynamodb-local:latest&#x27;, {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MongoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;ElasticSearch&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;fe42670a-928e-45bf-8e1a-c6a39235864f&quot;,&quot;parentUUID&quot;:&quot;5c887eb5-977e-4a72-bbd1-da842b7d1992&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;TestContainers &gt; Redis &gt; should be return envs of instance&quot;,&quot;title&quot;:&quot;TestContainers &gt; Redis &gt; should be return envs of instance&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { testContainers } from &#x27;../testcontainers&#x27;;\nimport { StartedGenericContainer } from &#x27;testcontainers/dist/src/generic-container/started-generic-container&#x27;;\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from &#x27;../fixtures&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TestContainers&#x27;, () =&gt; {\n  describe(&#x27;Redis&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return exception of instance&#x27;, async () =&gt; {\n      try {\n        await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe(&#x27;Use testContainers.getInstance() instead of new.&#x27;);\n      }\n    });\n\n    it(&#x27;should be get instance of test container&#x27;, () =&gt; {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return envs of instance&#x27;, () =&gt; {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it(&#x27;should be return container instance&#x27;, () =&gt; {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it(&#x27;should be return host of container instance&#x27;, () =&gt; {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual(&#x27;localhost&#x27;);\n    });\n\n    it(&#x27;should be return name of container instance&#x27;, () =&gt; {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it(&#x27;should be return mapped port&#x27;, () =&gt; {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe(&#x27;DynamoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;amazon/dynamodb-local:latest&#x27;, {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MongoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;ElasticSearch&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;77349436-b2d8-435d-af0f-3f7cb267f196&quot;,&quot;parentUUID&quot;:&quot;5c887eb5-977e-4a72-bbd1-da842b7d1992&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;TestContainers &gt; Redis &gt; should be return container instance&quot;,&quot;title&quot;:&quot;TestContainers &gt; Redis &gt; should be return container instance&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { testContainers } from &#x27;../testcontainers&#x27;;\nimport { StartedGenericContainer } from &#x27;testcontainers/dist/src/generic-container/started-generic-container&#x27;;\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from &#x27;../fixtures&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TestContainers&#x27;, () =&gt; {\n  describe(&#x27;Redis&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return exception of instance&#x27;, async () =&gt; {\n      try {\n        await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe(&#x27;Use testContainers.getInstance() instead of new.&#x27;);\n      }\n    });\n\n    it(&#x27;should be get instance of test container&#x27;, () =&gt; {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return envs of instance&#x27;, () =&gt; {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it(&#x27;should be return container instance&#x27;, () =&gt; {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it(&#x27;should be return host of container instance&#x27;, () =&gt; {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual(&#x27;localhost&#x27;);\n    });\n\n    it(&#x27;should be return name of container instance&#x27;, () =&gt; {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it(&#x27;should be return mapped port&#x27;, () =&gt; {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe(&#x27;DynamoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;amazon/dynamodb-local:latest&#x27;, {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MongoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;ElasticSearch&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b0b03bab-cf81-4d06-9134-fb4d7f232d0e&quot;,&quot;parentUUID&quot;:&quot;5c887eb5-977e-4a72-bbd1-da842b7d1992&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;TestContainers &gt; Redis &gt; should be return host of container instance&quot;,&quot;title&quot;:&quot;TestContainers &gt; Redis &gt; should be return host of container instance&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:0,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { testContainers } from &#x27;../testcontainers&#x27;;\nimport { StartedGenericContainer } from &#x27;testcontainers/dist/src/generic-container/started-generic-container&#x27;;\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from &#x27;../fixtures&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TestContainers&#x27;, () =&gt; {\n  describe(&#x27;Redis&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return exception of instance&#x27;, async () =&gt; {\n      try {\n        await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe(&#x27;Use testContainers.getInstance() instead of new.&#x27;);\n      }\n    });\n\n    it(&#x27;should be get instance of test container&#x27;, () =&gt; {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return envs of instance&#x27;, () =&gt; {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it(&#x27;should be return container instance&#x27;, () =&gt; {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it(&#x27;should be return host of container instance&#x27;, () =&gt; {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual(&#x27;localhost&#x27;);\n    });\n\n    it(&#x27;should be return name of container instance&#x27;, () =&gt; {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it(&#x27;should be return mapped port&#x27;, () =&gt; {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe(&#x27;DynamoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;amazon/dynamodb-local:latest&#x27;, {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MongoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;ElasticSearch&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6e6e80ab-2b5c-471d-afb6-9e3d862d63a6&quot;,&quot;parentUUID&quot;:&quot;5c887eb5-977e-4a72-bbd1-da842b7d1992&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;TestContainers &gt; Redis &gt; should be return name of container instance&quot;,&quot;title&quot;:&quot;TestContainers &gt; Redis &gt; should be return name of container instance&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:0,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { testContainers } from &#x27;../testcontainers&#x27;;\nimport { StartedGenericContainer } from &#x27;testcontainers/dist/src/generic-container/started-generic-container&#x27;;\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from &#x27;../fixtures&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TestContainers&#x27;, () =&gt; {\n  describe(&#x27;Redis&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return exception of instance&#x27;, async () =&gt; {\n      try {\n        await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe(&#x27;Use testContainers.getInstance() instead of new.&#x27;);\n      }\n    });\n\n    it(&#x27;should be get instance of test container&#x27;, () =&gt; {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return envs of instance&#x27;, () =&gt; {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it(&#x27;should be return container instance&#x27;, () =&gt; {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it(&#x27;should be return host of container instance&#x27;, () =&gt; {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual(&#x27;localhost&#x27;);\n    });\n\n    it(&#x27;should be return name of container instance&#x27;, () =&gt; {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it(&#x27;should be return mapped port&#x27;, () =&gt; {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe(&#x27;DynamoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;amazon/dynamodb-local:latest&#x27;, {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MongoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;ElasticSearch&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;8c50f53d-ada2-4453-80b6-1ebc5f357624&quot;,&quot;parentUUID&quot;:&quot;5c887eb5-977e-4a72-bbd1-da842b7d1992&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;TestContainers &gt; Redis &gt; should be return mapped port&quot;,&quot;title&quot;:&quot;TestContainers &gt; Redis &gt; should be return mapped port&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { testContainers } from &#x27;../testcontainers&#x27;;\nimport { StartedGenericContainer } from &#x27;testcontainers/dist/src/generic-container/started-generic-container&#x27;;\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from &#x27;../fixtures&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TestContainers&#x27;, () =&gt; {\n  describe(&#x27;Redis&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return exception of instance&#x27;, async () =&gt; {\n      try {\n        await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe(&#x27;Use testContainers.getInstance() instead of new.&#x27;);\n      }\n    });\n\n    it(&#x27;should be get instance of test container&#x27;, () =&gt; {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return envs of instance&#x27;, () =&gt; {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it(&#x27;should be return container instance&#x27;, () =&gt; {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it(&#x27;should be return host of container instance&#x27;, () =&gt; {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual(&#x27;localhost&#x27;);\n    });\n\n    it(&#x27;should be return name of container instance&#x27;, () =&gt; {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it(&#x27;should be return mapped port&#x27;, () =&gt; {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe(&#x27;DynamoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;amazon/dynamodb-local:latest&#x27;, {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MongoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;ElasticSearch&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f2f82f28-d19d-4e35-84b5-dfb4b268e219&quot;,&quot;parentUUID&quot;:&quot;5c887eb5-977e-4a72-bbd1-da842b7d1992&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;TestContainers &gt; DynamoDB &gt; should be defined&quot;,&quot;title&quot;:&quot;TestContainers &gt; DynamoDB &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { testContainers } from &#x27;../testcontainers&#x27;;\nimport { StartedGenericContainer } from &#x27;testcontainers/dist/src/generic-container/started-generic-container&#x27;;\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from &#x27;../fixtures&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TestContainers&#x27;, () =&gt; {\n  describe(&#x27;Redis&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return exception of instance&#x27;, async () =&gt; {\n      try {\n        await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe(&#x27;Use testContainers.getInstance() instead of new.&#x27;);\n      }\n    });\n\n    it(&#x27;should be get instance of test container&#x27;, () =&gt; {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return envs of instance&#x27;, () =&gt; {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it(&#x27;should be return container instance&#x27;, () =&gt; {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it(&#x27;should be return host of container instance&#x27;, () =&gt; {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual(&#x27;localhost&#x27;);\n    });\n\n    it(&#x27;should be return name of container instance&#x27;, () =&gt; {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it(&#x27;should be return mapped port&#x27;, () =&gt; {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe(&#x27;DynamoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;amazon/dynamodb-local:latest&#x27;, {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MongoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;ElasticSearch&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;58c59965-2230-455b-aac6-f6e9c8390be8&quot;,&quot;parentUUID&quot;:&quot;5c887eb5-977e-4a72-bbd1-da842b7d1992&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;TestContainers &gt; MongoDB &gt; should be defined&quot;,&quot;title&quot;:&quot;TestContainers &gt; MongoDB &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { testContainers } from &#x27;../testcontainers&#x27;;\nimport { StartedGenericContainer } from &#x27;testcontainers/dist/src/generic-container/started-generic-container&#x27;;\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from &#x27;../fixtures&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TestContainers&#x27;, () =&gt; {\n  describe(&#x27;Redis&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return exception of instance&#x27;, async () =&gt; {\n      try {\n        await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe(&#x27;Use testContainers.getInstance() instead of new.&#x27;);\n      }\n    });\n\n    it(&#x27;should be get instance of test container&#x27;, () =&gt; {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return envs of instance&#x27;, () =&gt; {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it(&#x27;should be return container instance&#x27;, () =&gt; {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it(&#x27;should be return host of container instance&#x27;, () =&gt; {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual(&#x27;localhost&#x27;);\n    });\n\n    it(&#x27;should be return name of container instance&#x27;, () =&gt; {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it(&#x27;should be return mapped port&#x27;, () =&gt; {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe(&#x27;DynamoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;amazon/dynamodb-local:latest&#x27;, {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MongoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;ElasticSearch&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;14892eab-97d8-478e-856d-fb09e74e4725&quot;,&quot;parentUUID&quot;:&quot;5c887eb5-977e-4a72-bbd1-da842b7d1992&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;TestContainers &gt; MySql &gt; should be defined&quot;,&quot;title&quot;:&quot;TestContainers &gt; MySql &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:0,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { testContainers } from &#x27;../testcontainers&#x27;;\nimport { StartedGenericContainer } from &#x27;testcontainers/dist/src/generic-container/started-generic-container&#x27;;\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from &#x27;../fixtures&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TestContainers&#x27;, () =&gt; {\n  describe(&#x27;Redis&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return exception of instance&#x27;, async () =&gt; {\n      try {\n        await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe(&#x27;Use testContainers.getInstance() instead of new.&#x27;);\n      }\n    });\n\n    it(&#x27;should be get instance of test container&#x27;, () =&gt; {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return envs of instance&#x27;, () =&gt; {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it(&#x27;should be return container instance&#x27;, () =&gt; {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it(&#x27;should be return host of container instance&#x27;, () =&gt; {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual(&#x27;localhost&#x27;);\n    });\n\n    it(&#x27;should be return name of container instance&#x27;, () =&gt; {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it(&#x27;should be return mapped port&#x27;, () =&gt; {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe(&#x27;DynamoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;amazon/dynamodb-local:latest&#x27;, {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MongoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;ElasticSearch&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;43b6eaef-127d-4e2b-8b02-5b476ccbce9a&quot;,&quot;parentUUID&quot;:&quot;5c887eb5-977e-4a72-bbd1-da842b7d1992&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;TestContainers &gt; Postgres &gt; should be defined&quot;,&quot;title&quot;:&quot;TestContainers &gt; Postgres &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:0,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { testContainers } from &#x27;../testcontainers&#x27;;\nimport { StartedGenericContainer } from &#x27;testcontainers/dist/src/generic-container/started-generic-container&#x27;;\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from &#x27;../fixtures&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TestContainers&#x27;, () =&gt; {\n  describe(&#x27;Redis&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return exception of instance&#x27;, async () =&gt; {\n      try {\n        await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe(&#x27;Use testContainers.getInstance() instead of new.&#x27;);\n      }\n    });\n\n    it(&#x27;should be get instance of test container&#x27;, () =&gt; {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return envs of instance&#x27;, () =&gt; {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it(&#x27;should be return container instance&#x27;, () =&gt; {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it(&#x27;should be return host of container instance&#x27;, () =&gt; {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual(&#x27;localhost&#x27;);\n    });\n\n    it(&#x27;should be return name of container instance&#x27;, () =&gt; {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it(&#x27;should be return mapped port&#x27;, () =&gt; {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe(&#x27;DynamoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;amazon/dynamodb-local:latest&#x27;, {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MongoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;ElasticSearch&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c81a7561-8a42-4dde-bd12-f9f8aaa8ea28&quot;,&quot;parentUUID&quot;:&quot;5c887eb5-977e-4a72-bbd1-da842b7d1992&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;TestContainers &gt; ElasticSearch &gt; should be defined&quot;,&quot;title&quot;:&quot;TestContainers &gt; ElasticSearch &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { testContainers } from &#x27;../testcontainers&#x27;;\nimport { StartedGenericContainer } from &#x27;testcontainers/dist/src/generic-container/started-generic-container&#x27;;\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from &#x27;../fixtures&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TestContainers&#x27;, () =&gt; {\n  describe(&#x27;Redis&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;redis:6.2-alpine&#x27;, {\n        ...TCRedisOptions,\n        command: [&#x27;redis-server&#x27;, &#x27;--appendonly&#x27;, &#x27;yes&#x27;, &#x27;--requirepass&#x27;, &#x27;123456&#x27;],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return exception of instance&#x27;, async () =&gt; {\n      try {\n        await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe(&#x27;Use testContainers.getInstance() instead of new.&#x27;);\n      }\n    });\n\n    it(&#x27;should be get instance of test container&#x27;, () =&gt; {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it(&#x27;should be return envs of instance&#x27;, () =&gt; {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it(&#x27;should be return container instance&#x27;, () =&gt; {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it(&#x27;should be return host of container instance&#x27;, () =&gt; {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual(&#x27;localhost&#x27;);\n    });\n\n    it(&#x27;should be return name of container instance&#x27;, () =&gt; {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it(&#x27;should be return mapped port&#x27;, () =&gt; {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe(&#x27;DynamoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;amazon/dynamodb-local:latest&#x27;, {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MongoDB&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe(&#x27;ElasticSearch&#x27;, () =&gt; {\n    let container: testContainers;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;elasticsearch:8.3.3&#x27;, {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it(&#x27;should be defined&#x27;, () =&gt; {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;05e70c6a-cd45-4255-9555-c3777d48f844&quot;,&quot;parentUUID&quot;:&quot;5c887eb5-977e-4a72-bbd1-da842b7d1992&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;utilities &gt; should be return delay default time&quot;,&quot;title&quot;:&quot;utilities &gt; should be return delay default time&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10005,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { delay, pathJoin } from &#x27;../utilities&#x27;;\nimport path from &#x27;path&#x27;;\n\ndescribe(&#x27;utilities&#x27;, () =&gt; {\n  it(&#x27;should be return delay default time&#x27;, async () =&gt; {\n    jest.spyOn(global, &#x27;setTimeout&#x27;);\n    await delay();\n    expect(setTimeout).toHaveBeenCalledTimes(1);\n    expect(setTimeout).toHaveBeenLastCalledWith(expect.any(Function), 10000);\n  });\n\n  it(&#x27;should be return delay custom time&#x27;, async () =&gt; {\n    jest.spyOn(global, &#x27;setTimeout&#x27;);\n    await delay(60);\n    expect(setTimeout).toHaveBeenCalledTimes(2);\n    expect(setTimeout).toHaveBeenLastCalledWith(expect.any(Function), 60);\n  });\n\n  it(&#x27;should be return a join of paths&#x27;, async () =&gt; {\n    const filePath = pathJoin(__dirname, &#x27;join&#x27;);\n    expect(filePath).toBe(path.join(__dirname, &#x27;join&#x27;));\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;87db4f60-8fcc-4ce4-8c7d-02987fe7b595&quot;,&quot;parentUUID&quot;:&quot;5c887eb5-977e-4a72-bbd1-da842b7d1992&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;utilities &gt; should be return delay custom time&quot;,&quot;title&quot;:&quot;utilities &gt; should be return delay custom time&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:62,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { delay, pathJoin } from &#x27;../utilities&#x27;;\nimport path from &#x27;path&#x27;;\n\ndescribe(&#x27;utilities&#x27;, () =&gt; {\n  it(&#x27;should be return delay default time&#x27;, async () =&gt; {\n    jest.spyOn(global, &#x27;setTimeout&#x27;);\n    await delay();\n    expect(setTimeout).toHaveBeenCalledTimes(1);\n    expect(setTimeout).toHaveBeenLastCalledWith(expect.any(Function), 10000);\n  });\n\n  it(&#x27;should be return delay custom time&#x27;, async () =&gt; {\n    jest.spyOn(global, &#x27;setTimeout&#x27;);\n    await delay(60);\n    expect(setTimeout).toHaveBeenCalledTimes(2);\n    expect(setTimeout).toHaveBeenLastCalledWith(expect.any(Function), 60);\n  });\n\n  it(&#x27;should be return a join of paths&#x27;, async () =&gt; {\n    const filePath = pathJoin(__dirname, &#x27;join&#x27;);\n    expect(filePath).toBe(path.join(__dirname, &#x27;join&#x27;));\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;8ae81c01-88a0-4074-a57c-954e71775945&quot;,&quot;parentUUID&quot;:&quot;5c887eb5-977e-4a72-bbd1-da842b7d1992&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;utilities &gt; should be return a join of paths&quot;,&quot;title&quot;:&quot;utilities &gt; should be return a join of paths&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { delay, pathJoin } from &#x27;../utilities&#x27;;\nimport path from &#x27;path&#x27;;\n\ndescribe(&#x27;utilities&#x27;, () =&gt; {\n  it(&#x27;should be return delay default time&#x27;, async () =&gt; {\n    jest.spyOn(global, &#x27;setTimeout&#x27;);\n    await delay();\n    expect(setTimeout).toHaveBeenCalledTimes(1);\n    expect(setTimeout).toHaveBeenLastCalledWith(expect.any(Function), 10000);\n  });\n\n  it(&#x27;should be return delay custom time&#x27;, async () =&gt; {\n    jest.spyOn(global, &#x27;setTimeout&#x27;);\n    await delay(60);\n    expect(setTimeout).toHaveBeenCalledTimes(2);\n    expect(setTimeout).toHaveBeenLastCalledWith(expect.any(Function), 60);\n  });\n\n  it(&#x27;should be return a join of paths&#x27;, async () =&gt; {\n    const filePath = pathJoin(__dirname, &#x27;join&#x27;);\n    expect(filePath).toBe(path.join(__dirname, &#x27;join&#x27;));\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3196be4a-5e9f-4b04-acff-93bbf301e569&quot;,&quot;parentUUID&quot;:&quot;5c887eb5-977e-4a72-bbd1-da842b7d1992&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Config &gt; baseConfig &gt; should be return config&quot;,&quot;title&quot;:&quot;Config &gt; baseConfig &gt; should be return config&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { config, dynamicConfig } from &#x27;../config/index&#x27;;\nimport { appConfigBase } from &#x27;../fixtures&#x27;;\n\ndescribe(&#x27;Config&#x27;, () =&gt; {\n  describe(&#x27;baseConfig&#x27;, () =&gt; {\n    it(&#x27;should be return config&#x27;, async () =&gt; {\n      expect(config()).toBeDefined();\n      expect(config()).not.toBe(null);\n      expect(typeof config()).toBe(&#x27;object&#x27;);\n      expect(config()).toEqual(appConfigBase);\n    });\n  });\n\n  describe(&#x27;dynamicConfig&#x27;, () =&gt; {\n    it(&#x27;should be return config with args&#x27;, async () =&gt; {\n      const args = {\n        httOptions: {\n          timeout: 5000,\n          maxRedirects: 5,\n        },\n      };\n\n      expect(dynamicConfig(args)()).toBeDefined();\n      expect(dynamicConfig(args)()).not.toBe(null);\n      expect(typeof dynamicConfig(args)()).toBe(&#x27;object&#x27;);\n      expect(dynamicConfig(args)()).toEqual({ ...appConfigBase, ...args });\n    });\n\n    it(&#x27;should be return config without args&#x27;, async () =&gt; {\n      expect(dynamicConfig()()).toBeDefined();\n      expect(dynamicConfig()()).not.toBe(null);\n      expect(typeof dynamicConfig()()).toBe(&#x27;object&#x27;);\n      expect(dynamicConfig()()).toEqual(appConfigBase);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3e677838-456f-4149-ac2e-d331c8022496&quot;,&quot;parentUUID&quot;:&quot;5c887eb5-977e-4a72-bbd1-da842b7d1992&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Config &gt; dynamicConfig &gt; should be return config with args&quot;,&quot;title&quot;:&quot;Config &gt; dynamicConfig &gt; should be return config with args&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { config, dynamicConfig } from &#x27;../config/index&#x27;;\nimport { appConfigBase } from &#x27;../fixtures&#x27;;\n\ndescribe(&#x27;Config&#x27;, () =&gt; {\n  describe(&#x27;baseConfig&#x27;, () =&gt; {\n    it(&#x27;should be return config&#x27;, async () =&gt; {\n      expect(config()).toBeDefined();\n      expect(config()).not.toBe(null);\n      expect(typeof config()).toBe(&#x27;object&#x27;);\n      expect(config()).toEqual(appConfigBase);\n    });\n  });\n\n  describe(&#x27;dynamicConfig&#x27;, () =&gt; {\n    it(&#x27;should be return config with args&#x27;, async () =&gt; {\n      const args = {\n        httOptions: {\n          timeout: 5000,\n          maxRedirects: 5,\n        },\n      };\n\n      expect(dynamicConfig(args)()).toBeDefined();\n      expect(dynamicConfig(args)()).not.toBe(null);\n      expect(typeof dynamicConfig(args)()).toBe(&#x27;object&#x27;);\n      expect(dynamicConfig(args)()).toEqual({ ...appConfigBase, ...args });\n    });\n\n    it(&#x27;should be return config without args&#x27;, async () =&gt; {\n      expect(dynamicConfig()()).toBeDefined();\n      expect(dynamicConfig()()).not.toBe(null);\n      expect(typeof dynamicConfig()()).toBe(&#x27;object&#x27;);\n      expect(dynamicConfig()()).toEqual(appConfigBase);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d5783114-0707-43b5-ae96-0cf2bc222ce5&quot;,&quot;parentUUID&quot;:&quot;5c887eb5-977e-4a72-bbd1-da842b7d1992&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Config &gt; dynamicConfig &gt; should be return config without args&quot;,&quot;title&quot;:&quot;Config &gt; dynamicConfig &gt; should be return config without args&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { config, dynamicConfig } from &#x27;../config/index&#x27;;\nimport { appConfigBase } from &#x27;../fixtures&#x27;;\n\ndescribe(&#x27;Config&#x27;, () =&gt; {\n  describe(&#x27;baseConfig&#x27;, () =&gt; {\n    it(&#x27;should be return config&#x27;, async () =&gt; {\n      expect(config()).toBeDefined();\n      expect(config()).not.toBe(null);\n      expect(typeof config()).toBe(&#x27;object&#x27;);\n      expect(config()).toEqual(appConfigBase);\n    });\n  });\n\n  describe(&#x27;dynamicConfig&#x27;, () =&gt; {\n    it(&#x27;should be return config with args&#x27;, async () =&gt; {\n      const args = {\n        httOptions: {\n          timeout: 5000,\n          maxRedirects: 5,\n        },\n      };\n\n      expect(dynamicConfig(args)()).toBeDefined();\n      expect(dynamicConfig(args)()).not.toBe(null);\n      expect(typeof dynamicConfig(args)()).toBe(&#x27;object&#x27;);\n      expect(dynamicConfig(args)()).toEqual({ ...appConfigBase, ...args });\n    });\n\n    it(&#x27;should be return config without args&#x27;, async () =&gt; {\n      expect(dynamicConfig()()).toBeDefined();\n      expect(dynamicConfig()()).not.toBe(null);\n      expect(typeof dynamicConfig()()).toBe(&#x27;object&#x27;);\n      expect(dynamicConfig()()).toEqual(appConfigBase);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e8410c96-1b14-42d3-84c4-49b6227b9cbc&quot;,&quot;parentUUID&quot;:&quot;5c887eb5-977e-4a72-bbd1-da842b7d1992&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Fixtures &gt; appConfigBase &gt; should be return appBaseConfig&quot;,&quot;title&quot;:&quot;Fixtures &gt; appConfigBase &gt; should be return appBaseConfig&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import {\n  appConfigBase,\n  manifest,\n  TCRedisOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n  TCDynamoDBOptions,\n} from &#x27;../fixtures&#x27;;\n\nconst containerName_prefix = &#x27;tresdoce-test-container&#x27;;\ndescribe(&#x27;Fixtures&#x27;, () =&gt; {\n  describe(&#x27;appConfigBase&#x27;, () =&gt; {\n    it(&#x27;should be return appBaseConfig&#x27;, async () =&gt; {\n      expect(appConfigBase).toBeDefined();\n      expect(appConfigBase).not.toBe(null);\n      expect(typeof appConfigBase).toBe(&#x27;object&#x27;);\n    });\n  });\n\n  describe(&#x27;manifest&#x27;, () =&gt; {\n    it(&#x27;should be return appBaseConfig&#x27;, async () =&gt; {\n      expect(manifest).toBeDefined();\n      expect(manifest).not.toBe(null);\n      expect(typeof manifest).toBe(&#x27;object&#x27;);\n    });\n  });\n\n  describe(&#x27;TestContainers options&#x27;, () =&gt; {\n    it(&#x27;should be define Redis options&#x27;, async () =&gt; {\n      expect(TCRedisOptions).toBeDefined();\n      expect(TCRedisOptions).not.toBe(null);\n      expect(typeof TCRedisOptions).toBe(&#x27;object&#x27;);\n      expect(TCRedisOptions.containerName).toEqual(`${containerName_prefix}-redis`);\n      expect(TCRedisOptions.ports).toEqual([\n        {\n          container: 6379,\n          host: 6379,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define DynamoDB options&#x27;, async () =&gt; {\n      expect(TCDynamoDBOptions).toBeDefined();\n      expect(TCDynamoDBOptions).not.toBe(null);\n      expect(typeof TCDynamoDBOptions).toBe(&#x27;object&#x27;);\n      expect(TCDynamoDBOptions.containerName).toEqual(`${containerName_prefix}-dynamodb`);\n      expect(TCDynamoDBOptions.ports).toEqual([\n        {\n          container: 8000,\n          host: 8000,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define MongoDB options&#x27;, async () =&gt; {\n      expect(TCMongoOptions).toBeDefined();\n      expect(TCMongoOptions).not.toBe(null);\n      expect(typeof TCMongoOptions).toBe(&#x27;object&#x27;);\n      expect(TCMongoOptions.containerName).toEqual(`${containerName_prefix}-mongo`);\n      expect(TCMongoOptions.ports).toEqual([\n        {\n          container: 27017,\n          host: 27017,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define MySql options&#x27;, async () =&gt; {\n      expect(TCMySqlOptions).toBeDefined();\n      expect(TCMySqlOptions).not.toBe(null);\n      expect(typeof TCMySqlOptions).toBe(&#x27;object&#x27;);\n      expect(TCMySqlOptions.containerName).toEqual(`${containerName_prefix}-mysql`);\n      expect(TCMySqlOptions.ports).toEqual([\n        {\n          container: 3306,\n          host: 3306,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define Postgres options&#x27;, async () =&gt; {\n      expect(TCPostgresOptions).toBeDefined();\n      expect(TCPostgresOptions).not.toBe(null);\n      expect(typeof TCPostgresOptions).toBe(&#x27;object&#x27;);\n      expect(TCPostgresOptions.containerName).toEqual(`${containerName_prefix}-postgres`);\n      expect(TCPostgresOptions.ports).toEqual([\n        {\n          container: 5432,\n          host: 5432,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define ElasticSearch options&#x27;, async () =&gt; {\n      expect(TCElasticSearchOptions).toBeDefined();\n      expect(TCElasticSearchOptions).not.toBe(null);\n      expect(typeof TCElasticSearchOptions).toBe(&#x27;object&#x27;);\n      expect(TCElasticSearchOptions.containerName).toEqual(`${containerName_prefix}-elasticsearch`);\n      expect(TCElasticSearchOptions.ports).toEqual([\n        {\n          container: 9200,\n          host: 9200,\n        },\n      ]);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6faf5878-38f4-49de-8716-9c81c8c36fa8&quot;,&quot;parentUUID&quot;:&quot;5c887eb5-977e-4a72-bbd1-da842b7d1992&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Fixtures &gt; manifest &gt; should be return appBaseConfig&quot;,&quot;title&quot;:&quot;Fixtures &gt; manifest &gt; should be return appBaseConfig&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:0,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import {\n  appConfigBase,\n  manifest,\n  TCRedisOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n  TCDynamoDBOptions,\n} from &#x27;../fixtures&#x27;;\n\nconst containerName_prefix = &#x27;tresdoce-test-container&#x27;;\ndescribe(&#x27;Fixtures&#x27;, () =&gt; {\n  describe(&#x27;appConfigBase&#x27;, () =&gt; {\n    it(&#x27;should be return appBaseConfig&#x27;, async () =&gt; {\n      expect(appConfigBase).toBeDefined();\n      expect(appConfigBase).not.toBe(null);\n      expect(typeof appConfigBase).toBe(&#x27;object&#x27;);\n    });\n  });\n\n  describe(&#x27;manifest&#x27;, () =&gt; {\n    it(&#x27;should be return appBaseConfig&#x27;, async () =&gt; {\n      expect(manifest).toBeDefined();\n      expect(manifest).not.toBe(null);\n      expect(typeof manifest).toBe(&#x27;object&#x27;);\n    });\n  });\n\n  describe(&#x27;TestContainers options&#x27;, () =&gt; {\n    it(&#x27;should be define Redis options&#x27;, async () =&gt; {\n      expect(TCRedisOptions).toBeDefined();\n      expect(TCRedisOptions).not.toBe(null);\n      expect(typeof TCRedisOptions).toBe(&#x27;object&#x27;);\n      expect(TCRedisOptions.containerName).toEqual(`${containerName_prefix}-redis`);\n      expect(TCRedisOptions.ports).toEqual([\n        {\n          container: 6379,\n          host: 6379,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define DynamoDB options&#x27;, async () =&gt; {\n      expect(TCDynamoDBOptions).toBeDefined();\n      expect(TCDynamoDBOptions).not.toBe(null);\n      expect(typeof TCDynamoDBOptions).toBe(&#x27;object&#x27;);\n      expect(TCDynamoDBOptions.containerName).toEqual(`${containerName_prefix}-dynamodb`);\n      expect(TCDynamoDBOptions.ports).toEqual([\n        {\n          container: 8000,\n          host: 8000,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define MongoDB options&#x27;, async () =&gt; {\n      expect(TCMongoOptions).toBeDefined();\n      expect(TCMongoOptions).not.toBe(null);\n      expect(typeof TCMongoOptions).toBe(&#x27;object&#x27;);\n      expect(TCMongoOptions.containerName).toEqual(`${containerName_prefix}-mongo`);\n      expect(TCMongoOptions.ports).toEqual([\n        {\n          container: 27017,\n          host: 27017,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define MySql options&#x27;, async () =&gt; {\n      expect(TCMySqlOptions).toBeDefined();\n      expect(TCMySqlOptions).not.toBe(null);\n      expect(typeof TCMySqlOptions).toBe(&#x27;object&#x27;);\n      expect(TCMySqlOptions.containerName).toEqual(`${containerName_prefix}-mysql`);\n      expect(TCMySqlOptions.ports).toEqual([\n        {\n          container: 3306,\n          host: 3306,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define Postgres options&#x27;, async () =&gt; {\n      expect(TCPostgresOptions).toBeDefined();\n      expect(TCPostgresOptions).not.toBe(null);\n      expect(typeof TCPostgresOptions).toBe(&#x27;object&#x27;);\n      expect(TCPostgresOptions.containerName).toEqual(`${containerName_prefix}-postgres`);\n      expect(TCPostgresOptions.ports).toEqual([\n        {\n          container: 5432,\n          host: 5432,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define ElasticSearch options&#x27;, async () =&gt; {\n      expect(TCElasticSearchOptions).toBeDefined();\n      expect(TCElasticSearchOptions).not.toBe(null);\n      expect(typeof TCElasticSearchOptions).toBe(&#x27;object&#x27;);\n      expect(TCElasticSearchOptions.containerName).toEqual(`${containerName_prefix}-elasticsearch`);\n      expect(TCElasticSearchOptions.ports).toEqual([\n        {\n          container: 9200,\n          host: 9200,\n        },\n      ]);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e2272bb4-5554-426a-9793-91509d959b41&quot;,&quot;parentUUID&quot;:&quot;5c887eb5-977e-4a72-bbd1-da842b7d1992&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Fixtures &gt; TestContainers options &gt; should be define Redis options&quot;,&quot;title&quot;:&quot;Fixtures &gt; TestContainers options &gt; should be define Redis options&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import {\n  appConfigBase,\n  manifest,\n  TCRedisOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n  TCDynamoDBOptions,\n} from &#x27;../fixtures&#x27;;\n\nconst containerName_prefix = &#x27;tresdoce-test-container&#x27;;\ndescribe(&#x27;Fixtures&#x27;, () =&gt; {\n  describe(&#x27;appConfigBase&#x27;, () =&gt; {\n    it(&#x27;should be return appBaseConfig&#x27;, async () =&gt; {\n      expect(appConfigBase).toBeDefined();\n      expect(appConfigBase).not.toBe(null);\n      expect(typeof appConfigBase).toBe(&#x27;object&#x27;);\n    });\n  });\n\n  describe(&#x27;manifest&#x27;, () =&gt; {\n    it(&#x27;should be return appBaseConfig&#x27;, async () =&gt; {\n      expect(manifest).toBeDefined();\n      expect(manifest).not.toBe(null);\n      expect(typeof manifest).toBe(&#x27;object&#x27;);\n    });\n  });\n\n  describe(&#x27;TestContainers options&#x27;, () =&gt; {\n    it(&#x27;should be define Redis options&#x27;, async () =&gt; {\n      expect(TCRedisOptions).toBeDefined();\n      expect(TCRedisOptions).not.toBe(null);\n      expect(typeof TCRedisOptions).toBe(&#x27;object&#x27;);\n      expect(TCRedisOptions.containerName).toEqual(`${containerName_prefix}-redis`);\n      expect(TCRedisOptions.ports).toEqual([\n        {\n          container: 6379,\n          host: 6379,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define DynamoDB options&#x27;, async () =&gt; {\n      expect(TCDynamoDBOptions).toBeDefined();\n      expect(TCDynamoDBOptions).not.toBe(null);\n      expect(typeof TCDynamoDBOptions).toBe(&#x27;object&#x27;);\n      expect(TCDynamoDBOptions.containerName).toEqual(`${containerName_prefix}-dynamodb`);\n      expect(TCDynamoDBOptions.ports).toEqual([\n        {\n          container: 8000,\n          host: 8000,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define MongoDB options&#x27;, async () =&gt; {\n      expect(TCMongoOptions).toBeDefined();\n      expect(TCMongoOptions).not.toBe(null);\n      expect(typeof TCMongoOptions).toBe(&#x27;object&#x27;);\n      expect(TCMongoOptions.containerName).toEqual(`${containerName_prefix}-mongo`);\n      expect(TCMongoOptions.ports).toEqual([\n        {\n          container: 27017,\n          host: 27017,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define MySql options&#x27;, async () =&gt; {\n      expect(TCMySqlOptions).toBeDefined();\n      expect(TCMySqlOptions).not.toBe(null);\n      expect(typeof TCMySqlOptions).toBe(&#x27;object&#x27;);\n      expect(TCMySqlOptions.containerName).toEqual(`${containerName_prefix}-mysql`);\n      expect(TCMySqlOptions.ports).toEqual([\n        {\n          container: 3306,\n          host: 3306,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define Postgres options&#x27;, async () =&gt; {\n      expect(TCPostgresOptions).toBeDefined();\n      expect(TCPostgresOptions).not.toBe(null);\n      expect(typeof TCPostgresOptions).toBe(&#x27;object&#x27;);\n      expect(TCPostgresOptions.containerName).toEqual(`${containerName_prefix}-postgres`);\n      expect(TCPostgresOptions.ports).toEqual([\n        {\n          container: 5432,\n          host: 5432,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define ElasticSearch options&#x27;, async () =&gt; {\n      expect(TCElasticSearchOptions).toBeDefined();\n      expect(TCElasticSearchOptions).not.toBe(null);\n      expect(typeof TCElasticSearchOptions).toBe(&#x27;object&#x27;);\n      expect(TCElasticSearchOptions.containerName).toEqual(`${containerName_prefix}-elasticsearch`);\n      expect(TCElasticSearchOptions.ports).toEqual([\n        {\n          container: 9200,\n          host: 9200,\n        },\n      ]);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7e704cb3-4d1c-4bd9-a9c4-e2299cd2e349&quot;,&quot;parentUUID&quot;:&quot;5c887eb5-977e-4a72-bbd1-da842b7d1992&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Fixtures &gt; TestContainers options &gt; should be define DynamoDB options&quot;,&quot;title&quot;:&quot;Fixtures &gt; TestContainers options &gt; should be define DynamoDB options&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import {\n  appConfigBase,\n  manifest,\n  TCRedisOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n  TCDynamoDBOptions,\n} from &#x27;../fixtures&#x27;;\n\nconst containerName_prefix = &#x27;tresdoce-test-container&#x27;;\ndescribe(&#x27;Fixtures&#x27;, () =&gt; {\n  describe(&#x27;appConfigBase&#x27;, () =&gt; {\n    it(&#x27;should be return appBaseConfig&#x27;, async () =&gt; {\n      expect(appConfigBase).toBeDefined();\n      expect(appConfigBase).not.toBe(null);\n      expect(typeof appConfigBase).toBe(&#x27;object&#x27;);\n    });\n  });\n\n  describe(&#x27;manifest&#x27;, () =&gt; {\n    it(&#x27;should be return appBaseConfig&#x27;, async () =&gt; {\n      expect(manifest).toBeDefined();\n      expect(manifest).not.toBe(null);\n      expect(typeof manifest).toBe(&#x27;object&#x27;);\n    });\n  });\n\n  describe(&#x27;TestContainers options&#x27;, () =&gt; {\n    it(&#x27;should be define Redis options&#x27;, async () =&gt; {\n      expect(TCRedisOptions).toBeDefined();\n      expect(TCRedisOptions).not.toBe(null);\n      expect(typeof TCRedisOptions).toBe(&#x27;object&#x27;);\n      expect(TCRedisOptions.containerName).toEqual(`${containerName_prefix}-redis`);\n      expect(TCRedisOptions.ports).toEqual([\n        {\n          container: 6379,\n          host: 6379,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define DynamoDB options&#x27;, async () =&gt; {\n      expect(TCDynamoDBOptions).toBeDefined();\n      expect(TCDynamoDBOptions).not.toBe(null);\n      expect(typeof TCDynamoDBOptions).toBe(&#x27;object&#x27;);\n      expect(TCDynamoDBOptions.containerName).toEqual(`${containerName_prefix}-dynamodb`);\n      expect(TCDynamoDBOptions.ports).toEqual([\n        {\n          container: 8000,\n          host: 8000,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define MongoDB options&#x27;, async () =&gt; {\n      expect(TCMongoOptions).toBeDefined();\n      expect(TCMongoOptions).not.toBe(null);\n      expect(typeof TCMongoOptions).toBe(&#x27;object&#x27;);\n      expect(TCMongoOptions.containerName).toEqual(`${containerName_prefix}-mongo`);\n      expect(TCMongoOptions.ports).toEqual([\n        {\n          container: 27017,\n          host: 27017,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define MySql options&#x27;, async () =&gt; {\n      expect(TCMySqlOptions).toBeDefined();\n      expect(TCMySqlOptions).not.toBe(null);\n      expect(typeof TCMySqlOptions).toBe(&#x27;object&#x27;);\n      expect(TCMySqlOptions.containerName).toEqual(`${containerName_prefix}-mysql`);\n      expect(TCMySqlOptions.ports).toEqual([\n        {\n          container: 3306,\n          host: 3306,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define Postgres options&#x27;, async () =&gt; {\n      expect(TCPostgresOptions).toBeDefined();\n      expect(TCPostgresOptions).not.toBe(null);\n      expect(typeof TCPostgresOptions).toBe(&#x27;object&#x27;);\n      expect(TCPostgresOptions.containerName).toEqual(`${containerName_prefix}-postgres`);\n      expect(TCPostgresOptions.ports).toEqual([\n        {\n          container: 5432,\n          host: 5432,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define ElasticSearch options&#x27;, async () =&gt; {\n      expect(TCElasticSearchOptions).toBeDefined();\n      expect(TCElasticSearchOptions).not.toBe(null);\n      expect(typeof TCElasticSearchOptions).toBe(&#x27;object&#x27;);\n      expect(TCElasticSearchOptions.containerName).toEqual(`${containerName_prefix}-elasticsearch`);\n      expect(TCElasticSearchOptions.ports).toEqual([\n        {\n          container: 9200,\n          host: 9200,\n        },\n      ]);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;64c4bd40-3cff-413d-9dd7-132f12072797&quot;,&quot;parentUUID&quot;:&quot;5c887eb5-977e-4a72-bbd1-da842b7d1992&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Fixtures &gt; TestContainers options &gt; should be define MongoDB options&quot;,&quot;title&quot;:&quot;Fixtures &gt; TestContainers options &gt; should be define MongoDB options&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import {\n  appConfigBase,\n  manifest,\n  TCRedisOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n  TCDynamoDBOptions,\n} from &#x27;../fixtures&#x27;;\n\nconst containerName_prefix = &#x27;tresdoce-test-container&#x27;;\ndescribe(&#x27;Fixtures&#x27;, () =&gt; {\n  describe(&#x27;appConfigBase&#x27;, () =&gt; {\n    it(&#x27;should be return appBaseConfig&#x27;, async () =&gt; {\n      expect(appConfigBase).toBeDefined();\n      expect(appConfigBase).not.toBe(null);\n      expect(typeof appConfigBase).toBe(&#x27;object&#x27;);\n    });\n  });\n\n  describe(&#x27;manifest&#x27;, () =&gt; {\n    it(&#x27;should be return appBaseConfig&#x27;, async () =&gt; {\n      expect(manifest).toBeDefined();\n      expect(manifest).not.toBe(null);\n      expect(typeof manifest).toBe(&#x27;object&#x27;);\n    });\n  });\n\n  describe(&#x27;TestContainers options&#x27;, () =&gt; {\n    it(&#x27;should be define Redis options&#x27;, async () =&gt; {\n      expect(TCRedisOptions).toBeDefined();\n      expect(TCRedisOptions).not.toBe(null);\n      expect(typeof TCRedisOptions).toBe(&#x27;object&#x27;);\n      expect(TCRedisOptions.containerName).toEqual(`${containerName_prefix}-redis`);\n      expect(TCRedisOptions.ports).toEqual([\n        {\n          container: 6379,\n          host: 6379,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define DynamoDB options&#x27;, async () =&gt; {\n      expect(TCDynamoDBOptions).toBeDefined();\n      expect(TCDynamoDBOptions).not.toBe(null);\n      expect(typeof TCDynamoDBOptions).toBe(&#x27;object&#x27;);\n      expect(TCDynamoDBOptions.containerName).toEqual(`${containerName_prefix}-dynamodb`);\n      expect(TCDynamoDBOptions.ports).toEqual([\n        {\n          container: 8000,\n          host: 8000,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define MongoDB options&#x27;, async () =&gt; {\n      expect(TCMongoOptions).toBeDefined();\n      expect(TCMongoOptions).not.toBe(null);\n      expect(typeof TCMongoOptions).toBe(&#x27;object&#x27;);\n      expect(TCMongoOptions.containerName).toEqual(`${containerName_prefix}-mongo`);\n      expect(TCMongoOptions.ports).toEqual([\n        {\n          container: 27017,\n          host: 27017,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define MySql options&#x27;, async () =&gt; {\n      expect(TCMySqlOptions).toBeDefined();\n      expect(TCMySqlOptions).not.toBe(null);\n      expect(typeof TCMySqlOptions).toBe(&#x27;object&#x27;);\n      expect(TCMySqlOptions.containerName).toEqual(`${containerName_prefix}-mysql`);\n      expect(TCMySqlOptions.ports).toEqual([\n        {\n          container: 3306,\n          host: 3306,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define Postgres options&#x27;, async () =&gt; {\n      expect(TCPostgresOptions).toBeDefined();\n      expect(TCPostgresOptions).not.toBe(null);\n      expect(typeof TCPostgresOptions).toBe(&#x27;object&#x27;);\n      expect(TCPostgresOptions.containerName).toEqual(`${containerName_prefix}-postgres`);\n      expect(TCPostgresOptions.ports).toEqual([\n        {\n          container: 5432,\n          host: 5432,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define ElasticSearch options&#x27;, async () =&gt; {\n      expect(TCElasticSearchOptions).toBeDefined();\n      expect(TCElasticSearchOptions).not.toBe(null);\n      expect(typeof TCElasticSearchOptions).toBe(&#x27;object&#x27;);\n      expect(TCElasticSearchOptions.containerName).toEqual(`${containerName_prefix}-elasticsearch`);\n      expect(TCElasticSearchOptions.ports).toEqual([\n        {\n          container: 9200,\n          host: 9200,\n        },\n      ]);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7bb0d898-47ae-4cfb-9670-a2b80d25ed35&quot;,&quot;parentUUID&quot;:&quot;5c887eb5-977e-4a72-bbd1-da842b7d1992&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Fixtures &gt; TestContainers options &gt; should be define MySql options&quot;,&quot;title&quot;:&quot;Fixtures &gt; TestContainers options &gt; should be define MySql options&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import {\n  appConfigBase,\n  manifest,\n  TCRedisOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n  TCDynamoDBOptions,\n} from &#x27;../fixtures&#x27;;\n\nconst containerName_prefix = &#x27;tresdoce-test-container&#x27;;\ndescribe(&#x27;Fixtures&#x27;, () =&gt; {\n  describe(&#x27;appConfigBase&#x27;, () =&gt; {\n    it(&#x27;should be return appBaseConfig&#x27;, async () =&gt; {\n      expect(appConfigBase).toBeDefined();\n      expect(appConfigBase).not.toBe(null);\n      expect(typeof appConfigBase).toBe(&#x27;object&#x27;);\n    });\n  });\n\n  describe(&#x27;manifest&#x27;, () =&gt; {\n    it(&#x27;should be return appBaseConfig&#x27;, async () =&gt; {\n      expect(manifest).toBeDefined();\n      expect(manifest).not.toBe(null);\n      expect(typeof manifest).toBe(&#x27;object&#x27;);\n    });\n  });\n\n  describe(&#x27;TestContainers options&#x27;, () =&gt; {\n    it(&#x27;should be define Redis options&#x27;, async () =&gt; {\n      expect(TCRedisOptions).toBeDefined();\n      expect(TCRedisOptions).not.toBe(null);\n      expect(typeof TCRedisOptions).toBe(&#x27;object&#x27;);\n      expect(TCRedisOptions.containerName).toEqual(`${containerName_prefix}-redis`);\n      expect(TCRedisOptions.ports).toEqual([\n        {\n          container: 6379,\n          host: 6379,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define DynamoDB options&#x27;, async () =&gt; {\n      expect(TCDynamoDBOptions).toBeDefined();\n      expect(TCDynamoDBOptions).not.toBe(null);\n      expect(typeof TCDynamoDBOptions).toBe(&#x27;object&#x27;);\n      expect(TCDynamoDBOptions.containerName).toEqual(`${containerName_prefix}-dynamodb`);\n      expect(TCDynamoDBOptions.ports).toEqual([\n        {\n          container: 8000,\n          host: 8000,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define MongoDB options&#x27;, async () =&gt; {\n      expect(TCMongoOptions).toBeDefined();\n      expect(TCMongoOptions).not.toBe(null);\n      expect(typeof TCMongoOptions).toBe(&#x27;object&#x27;);\n      expect(TCMongoOptions.containerName).toEqual(`${containerName_prefix}-mongo`);\n      expect(TCMongoOptions.ports).toEqual([\n        {\n          container: 27017,\n          host: 27017,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define MySql options&#x27;, async () =&gt; {\n      expect(TCMySqlOptions).toBeDefined();\n      expect(TCMySqlOptions).not.toBe(null);\n      expect(typeof TCMySqlOptions).toBe(&#x27;object&#x27;);\n      expect(TCMySqlOptions.containerName).toEqual(`${containerName_prefix}-mysql`);\n      expect(TCMySqlOptions.ports).toEqual([\n        {\n          container: 3306,\n          host: 3306,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define Postgres options&#x27;, async () =&gt; {\n      expect(TCPostgresOptions).toBeDefined();\n      expect(TCPostgresOptions).not.toBe(null);\n      expect(typeof TCPostgresOptions).toBe(&#x27;object&#x27;);\n      expect(TCPostgresOptions.containerName).toEqual(`${containerName_prefix}-postgres`);\n      expect(TCPostgresOptions.ports).toEqual([\n        {\n          container: 5432,\n          host: 5432,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define ElasticSearch options&#x27;, async () =&gt; {\n      expect(TCElasticSearchOptions).toBeDefined();\n      expect(TCElasticSearchOptions).not.toBe(null);\n      expect(typeof TCElasticSearchOptions).toBe(&#x27;object&#x27;);\n      expect(TCElasticSearchOptions.containerName).toEqual(`${containerName_prefix}-elasticsearch`);\n      expect(TCElasticSearchOptions.ports).toEqual([\n        {\n          container: 9200,\n          host: 9200,\n        },\n      ]);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;0f942094-870a-4c94-a755-63627b911cf8&quot;,&quot;parentUUID&quot;:&quot;5c887eb5-977e-4a72-bbd1-da842b7d1992&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Fixtures &gt; TestContainers options &gt; should be define Postgres options&quot;,&quot;title&quot;:&quot;Fixtures &gt; TestContainers options &gt; should be define Postgres options&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import {\n  appConfigBase,\n  manifest,\n  TCRedisOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n  TCDynamoDBOptions,\n} from &#x27;../fixtures&#x27;;\n\nconst containerName_prefix = &#x27;tresdoce-test-container&#x27;;\ndescribe(&#x27;Fixtures&#x27;, () =&gt; {\n  describe(&#x27;appConfigBase&#x27;, () =&gt; {\n    it(&#x27;should be return appBaseConfig&#x27;, async () =&gt; {\n      expect(appConfigBase).toBeDefined();\n      expect(appConfigBase).not.toBe(null);\n      expect(typeof appConfigBase).toBe(&#x27;object&#x27;);\n    });\n  });\n\n  describe(&#x27;manifest&#x27;, () =&gt; {\n    it(&#x27;should be return appBaseConfig&#x27;, async () =&gt; {\n      expect(manifest).toBeDefined();\n      expect(manifest).not.toBe(null);\n      expect(typeof manifest).toBe(&#x27;object&#x27;);\n    });\n  });\n\n  describe(&#x27;TestContainers options&#x27;, () =&gt; {\n    it(&#x27;should be define Redis options&#x27;, async () =&gt; {\n      expect(TCRedisOptions).toBeDefined();\n      expect(TCRedisOptions).not.toBe(null);\n      expect(typeof TCRedisOptions).toBe(&#x27;object&#x27;);\n      expect(TCRedisOptions.containerName).toEqual(`${containerName_prefix}-redis`);\n      expect(TCRedisOptions.ports).toEqual([\n        {\n          container: 6379,\n          host: 6379,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define DynamoDB options&#x27;, async () =&gt; {\n      expect(TCDynamoDBOptions).toBeDefined();\n      expect(TCDynamoDBOptions).not.toBe(null);\n      expect(typeof TCDynamoDBOptions).toBe(&#x27;object&#x27;);\n      expect(TCDynamoDBOptions.containerName).toEqual(`${containerName_prefix}-dynamodb`);\n      expect(TCDynamoDBOptions.ports).toEqual([\n        {\n          container: 8000,\n          host: 8000,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define MongoDB options&#x27;, async () =&gt; {\n      expect(TCMongoOptions).toBeDefined();\n      expect(TCMongoOptions).not.toBe(null);\n      expect(typeof TCMongoOptions).toBe(&#x27;object&#x27;);\n      expect(TCMongoOptions.containerName).toEqual(`${containerName_prefix}-mongo`);\n      expect(TCMongoOptions.ports).toEqual([\n        {\n          container: 27017,\n          host: 27017,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define MySql options&#x27;, async () =&gt; {\n      expect(TCMySqlOptions).toBeDefined();\n      expect(TCMySqlOptions).not.toBe(null);\n      expect(typeof TCMySqlOptions).toBe(&#x27;object&#x27;);\n      expect(TCMySqlOptions.containerName).toEqual(`${containerName_prefix}-mysql`);\n      expect(TCMySqlOptions.ports).toEqual([\n        {\n          container: 3306,\n          host: 3306,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define Postgres options&#x27;, async () =&gt; {\n      expect(TCPostgresOptions).toBeDefined();\n      expect(TCPostgresOptions).not.toBe(null);\n      expect(typeof TCPostgresOptions).toBe(&#x27;object&#x27;);\n      expect(TCPostgresOptions.containerName).toEqual(`${containerName_prefix}-postgres`);\n      expect(TCPostgresOptions.ports).toEqual([\n        {\n          container: 5432,\n          host: 5432,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define ElasticSearch options&#x27;, async () =&gt; {\n      expect(TCElasticSearchOptions).toBeDefined();\n      expect(TCElasticSearchOptions).not.toBe(null);\n      expect(typeof TCElasticSearchOptions).toBe(&#x27;object&#x27;);\n      expect(TCElasticSearchOptions.containerName).toEqual(`${containerName_prefix}-elasticsearch`);\n      expect(TCElasticSearchOptions.ports).toEqual([\n        {\n          container: 9200,\n          host: 9200,\n        },\n      ]);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;fb532b82-fe0a-434a-b8e8-326fa5a1bac1&quot;,&quot;parentUUID&quot;:&quot;5c887eb5-977e-4a72-bbd1-da842b7d1992&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;Fixtures &gt; TestContainers options &gt; should be define ElasticSearch options&quot;,&quot;title&quot;:&quot;Fixtures &gt; TestContainers options &gt; should be define ElasticSearch options&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import {\n  appConfigBase,\n  manifest,\n  TCRedisOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n  TCDynamoDBOptions,\n} from &#x27;../fixtures&#x27;;\n\nconst containerName_prefix = &#x27;tresdoce-test-container&#x27;;\ndescribe(&#x27;Fixtures&#x27;, () =&gt; {\n  describe(&#x27;appConfigBase&#x27;, () =&gt; {\n    it(&#x27;should be return appBaseConfig&#x27;, async () =&gt; {\n      expect(appConfigBase).toBeDefined();\n      expect(appConfigBase).not.toBe(null);\n      expect(typeof appConfigBase).toBe(&#x27;object&#x27;);\n    });\n  });\n\n  describe(&#x27;manifest&#x27;, () =&gt; {\n    it(&#x27;should be return appBaseConfig&#x27;, async () =&gt; {\n      expect(manifest).toBeDefined();\n      expect(manifest).not.toBe(null);\n      expect(typeof manifest).toBe(&#x27;object&#x27;);\n    });\n  });\n\n  describe(&#x27;TestContainers options&#x27;, () =&gt; {\n    it(&#x27;should be define Redis options&#x27;, async () =&gt; {\n      expect(TCRedisOptions).toBeDefined();\n      expect(TCRedisOptions).not.toBe(null);\n      expect(typeof TCRedisOptions).toBe(&#x27;object&#x27;);\n      expect(TCRedisOptions.containerName).toEqual(`${containerName_prefix}-redis`);\n      expect(TCRedisOptions.ports).toEqual([\n        {\n          container: 6379,\n          host: 6379,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define DynamoDB options&#x27;, async () =&gt; {\n      expect(TCDynamoDBOptions).toBeDefined();\n      expect(TCDynamoDBOptions).not.toBe(null);\n      expect(typeof TCDynamoDBOptions).toBe(&#x27;object&#x27;);\n      expect(TCDynamoDBOptions.containerName).toEqual(`${containerName_prefix}-dynamodb`);\n      expect(TCDynamoDBOptions.ports).toEqual([\n        {\n          container: 8000,\n          host: 8000,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define MongoDB options&#x27;, async () =&gt; {\n      expect(TCMongoOptions).toBeDefined();\n      expect(TCMongoOptions).not.toBe(null);\n      expect(typeof TCMongoOptions).toBe(&#x27;object&#x27;);\n      expect(TCMongoOptions.containerName).toEqual(`${containerName_prefix}-mongo`);\n      expect(TCMongoOptions.ports).toEqual([\n        {\n          container: 27017,\n          host: 27017,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define MySql options&#x27;, async () =&gt; {\n      expect(TCMySqlOptions).toBeDefined();\n      expect(TCMySqlOptions).not.toBe(null);\n      expect(typeof TCMySqlOptions).toBe(&#x27;object&#x27;);\n      expect(TCMySqlOptions.containerName).toEqual(`${containerName_prefix}-mysql`);\n      expect(TCMySqlOptions.ports).toEqual([\n        {\n          container: 3306,\n          host: 3306,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define Postgres options&#x27;, async () =&gt; {\n      expect(TCPostgresOptions).toBeDefined();\n      expect(TCPostgresOptions).not.toBe(null);\n      expect(typeof TCPostgresOptions).toBe(&#x27;object&#x27;);\n      expect(TCPostgresOptions.containerName).toEqual(`${containerName_prefix}-postgres`);\n      expect(TCPostgresOptions.ports).toEqual([\n        {\n          container: 5432,\n          host: 5432,\n        },\n      ]);\n    });\n\n    it(&#x27;should be define ElasticSearch options&#x27;, async () =&gt; {\n      expect(TCElasticSearchOptions).toBeDefined();\n      expect(TCElasticSearchOptions).not.toBe(null);\n      expect(typeof TCElasticSearchOptions).toBe(&#x27;object&#x27;);\n      expect(TCElasticSearchOptions.containerName).toEqual(`${containerName_prefix}-elasticsearch`);\n      expect(TCElasticSearchOptions.ports).toEqual([\n        {\n          container: 9200,\n          host: 9200,\n        },\n      ]);\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;bf65b726-17de-49fe-a7ce-a000be64110d&quot;,&quot;parentUUID&quot;:&quot;5c887eb5-977e-4a72-bbd1-da842b7d1992&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;0cfdc5c7-f9da-46db-b066-f9bc9a67a9d1&quot;,&quot;f65528a0-d5e7-4213-821b-34d9039ba9b5&quot;,&quot;73b4d2ec-8510-4e44-87cf-a5d2d491f16b&quot;,&quot;31ef60f8-b865-4d54-bb8b-c8ec22064298&quot;,&quot;b0792a9d-2926-43f4-bbcd-fc24e344f8e9&quot;,&quot;fe42670a-928e-45bf-8e1a-c6a39235864f&quot;,&quot;77349436-b2d8-435d-af0f-3f7cb267f196&quot;,&quot;b0b03bab-cf81-4d06-9134-fb4d7f232d0e&quot;,&quot;6e6e80ab-2b5c-471d-afb6-9e3d862d63a6&quot;,&quot;8c50f53d-ada2-4453-80b6-1ebc5f357624&quot;,&quot;f2f82f28-d19d-4e35-84b5-dfb4b268e219&quot;,&quot;58c59965-2230-455b-aac6-f6e9c8390be8&quot;,&quot;14892eab-97d8-478e-856d-fb09e74e4725&quot;,&quot;43b6eaef-127d-4e2b-8b02-5b476ccbce9a&quot;,&quot;c81a7561-8a42-4dde-bd12-f9f8aaa8ea28&quot;,&quot;05e70c6a-cd45-4255-9555-c3777d48f844&quot;,&quot;87db4f60-8fcc-4ce4-8c7d-02987fe7b595&quot;,&quot;8ae81c01-88a0-4074-a57c-954e71775945&quot;,&quot;3196be4a-5e9f-4b04-acff-93bbf301e569&quot;,&quot;3e677838-456f-4149-ac2e-d331c8022496&quot;,&quot;d5783114-0707-43b5-ae96-0cf2bc222ce5&quot;,&quot;e8410c96-1b14-42d3-84c4-49b6227b9cbc&quot;,&quot;6faf5878-38f4-49de-8716-9c81c8c36fa8&quot;,&quot;e2272bb4-5554-426a-9793-91509d959b41&quot;,&quot;7e704cb3-4d1c-4bd9-a9c4-e2299cd2e349&quot;,&quot;64c4bd40-3cff-413d-9dd7-132f12072797&quot;,&quot;7bb0d898-47ae-4cfb-9670-a2b80d25ed35&quot;,&quot;0f942094-870a-4c94-a755-63627b911cf8&quot;,&quot;fb532b82-fe0a-434a-b8e8-326fa5a1bac1&quot;,&quot;bf65b726-17de-49fe-a7ce-a000be64110d&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:47631,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:5000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:5000},{&quot;uuid&quot;:&quot;5726034f-f995-4345-9633-6e94d9aae103&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/typeorm&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;a2e4d055-d321-4602-b965-3b9789fcfa9e&quot;,&quot;title&quot;:&quot;@tresdoce-nestjs-toolkit/typeorm&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;fullTitle&quot;:&quot;TypeOrm &gt; Postgres &gt; should be defined&quot;,&quot;title&quot;:&quot;TypeOrm &gt; Postgres &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:261,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport {\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  tcName,\n  testContainers,\n  fixturePostResponse,\n  fixtureUserArrayResponse,\n} from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { Repository } from &#x27;typeorm&#x27;;\n\nimport { TypeOrmClientModule } from &#x27;../typeorm/typeorm.module&#x27;;\nimport { Post } from &#x27;./utils/post.entity&#x27;;\nimport { User } from &#x27;./utils/user.entity&#x27;;\n\nimport { configPostgres, configMySql, configMongo } from &#x27;./utils&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TypeOrm&#x27;, () =&gt; {\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository&lt;Post&gt;;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, {\n        ...TCPostgresOptions,\n        containerName: `${tcName}-typeorm-postgres`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configPostgres],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([Post]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get(&#x27;PostRepository&#x27;);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it(&#x27;should be return an array of post&#x27;, async () =&gt; {\n      await repository.save([fixturePostResponse]);\n\n      const query = await repository.find();\n      expect(query).toEqual([fixturePostResponse]);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository&lt;Post&gt;;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        containerName: `${tcName}-typeorm-mysql`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configMySql],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([Post]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get(&#x27;PostRepository&#x27;);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it(&#x27;should be return an array of post&#x27;, async () =&gt; {\n      await repository.save([fixturePostResponse]);\n\n      const query = await repository.find();\n      expect(query).toEqual([fixturePostResponse]);\n    });\n  });\n\n  describe(&#x27;Mongo&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository&lt;User&gt;;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        containerName: `${tcName}-typeorm-mongo`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configMongo],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([User]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get(&#x27;UserRepository&#x27;);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it(&#x27;should be return an array of user&#x27;, async () =&gt; {\n      await repository.save(fixtureUserArrayResponse);\n\n      const query: User[] = await repository.find();\n      expect(query).toEqual(expect.any(Array));\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;dff8abee-e0d1-4ae7-a8fd-c63fb12097c6&quot;,&quot;parentUUID&quot;:&quot;a2e4d055-d321-4602-b965-3b9789fcfa9e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;TypeOrm &gt; Postgres &gt; should be return an array of post&quot;,&quot;title&quot;:&quot;TypeOrm &gt; Postgres &gt; should be return an array of post&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:70,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport {\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  tcName,\n  testContainers,\n  fixturePostResponse,\n  fixtureUserArrayResponse,\n} from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { Repository } from &#x27;typeorm&#x27;;\n\nimport { TypeOrmClientModule } from &#x27;../typeorm/typeorm.module&#x27;;\nimport { Post } from &#x27;./utils/post.entity&#x27;;\nimport { User } from &#x27;./utils/user.entity&#x27;;\n\nimport { configPostgres, configMySql, configMongo } from &#x27;./utils&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TypeOrm&#x27;, () =&gt; {\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository&lt;Post&gt;;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, {\n        ...TCPostgresOptions,\n        containerName: `${tcName}-typeorm-postgres`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configPostgres],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([Post]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get(&#x27;PostRepository&#x27;);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it(&#x27;should be return an array of post&#x27;, async () =&gt; {\n      await repository.save([fixturePostResponse]);\n\n      const query = await repository.find();\n      expect(query).toEqual([fixturePostResponse]);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository&lt;Post&gt;;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        containerName: `${tcName}-typeorm-mysql`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configMySql],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([Post]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get(&#x27;PostRepository&#x27;);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it(&#x27;should be return an array of post&#x27;, async () =&gt; {\n      await repository.save([fixturePostResponse]);\n\n      const query = await repository.find();\n      expect(query).toEqual([fixturePostResponse]);\n    });\n  });\n\n  describe(&#x27;Mongo&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository&lt;User&gt;;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        containerName: `${tcName}-typeorm-mongo`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configMongo],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([User]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get(&#x27;UserRepository&#x27;);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it(&#x27;should be return an array of user&#x27;, async () =&gt; {\n      await repository.save(fixtureUserArrayResponse);\n\n      const query: User[] = await repository.find();\n      expect(query).toEqual(expect.any(Array));\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;5101bac4-75a3-4223-85fa-9e1161e846d8&quot;,&quot;parentUUID&quot;:&quot;a2e4d055-d321-4602-b965-3b9789fcfa9e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;TypeOrm &gt; MySql &gt; should be defined&quot;,&quot;title&quot;:&quot;TypeOrm &gt; MySql &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:145,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport {\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  tcName,\n  testContainers,\n  fixturePostResponse,\n  fixtureUserArrayResponse,\n} from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { Repository } from &#x27;typeorm&#x27;;\n\nimport { TypeOrmClientModule } from &#x27;../typeorm/typeorm.module&#x27;;\nimport { Post } from &#x27;./utils/post.entity&#x27;;\nimport { User } from &#x27;./utils/user.entity&#x27;;\n\nimport { configPostgres, configMySql, configMongo } from &#x27;./utils&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TypeOrm&#x27;, () =&gt; {\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository&lt;Post&gt;;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, {\n        ...TCPostgresOptions,\n        containerName: `${tcName}-typeorm-postgres`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configPostgres],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([Post]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get(&#x27;PostRepository&#x27;);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it(&#x27;should be return an array of post&#x27;, async () =&gt; {\n      await repository.save([fixturePostResponse]);\n\n      const query = await repository.find();\n      expect(query).toEqual([fixturePostResponse]);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository&lt;Post&gt;;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        containerName: `${tcName}-typeorm-mysql`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configMySql],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([Post]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get(&#x27;PostRepository&#x27;);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it(&#x27;should be return an array of post&#x27;, async () =&gt; {\n      await repository.save([fixturePostResponse]);\n\n      const query = await repository.find();\n      expect(query).toEqual([fixturePostResponse]);\n    });\n  });\n\n  describe(&#x27;Mongo&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository&lt;User&gt;;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        containerName: `${tcName}-typeorm-mongo`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configMongo],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([User]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get(&#x27;UserRepository&#x27;);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it(&#x27;should be return an array of user&#x27;, async () =&gt; {\n      await repository.save(fixtureUserArrayResponse);\n\n      const query: User[] = await repository.find();\n      expect(query).toEqual(expect.any(Array));\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b0189dec-dbeb-4b1c-ba55-c945614c660f&quot;,&quot;parentUUID&quot;:&quot;a2e4d055-d321-4602-b965-3b9789fcfa9e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;TypeOrm &gt; MySql &gt; should be return an array of post&quot;,&quot;title&quot;:&quot;TypeOrm &gt; MySql &gt; should be return an array of post&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:59,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport {\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  tcName,\n  testContainers,\n  fixturePostResponse,\n  fixtureUserArrayResponse,\n} from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { Repository } from &#x27;typeorm&#x27;;\n\nimport { TypeOrmClientModule } from &#x27;../typeorm/typeorm.module&#x27;;\nimport { Post } from &#x27;./utils/post.entity&#x27;;\nimport { User } from &#x27;./utils/user.entity&#x27;;\n\nimport { configPostgres, configMySql, configMongo } from &#x27;./utils&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TypeOrm&#x27;, () =&gt; {\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository&lt;Post&gt;;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, {\n        ...TCPostgresOptions,\n        containerName: `${tcName}-typeorm-postgres`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configPostgres],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([Post]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get(&#x27;PostRepository&#x27;);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it(&#x27;should be return an array of post&#x27;, async () =&gt; {\n      await repository.save([fixturePostResponse]);\n\n      const query = await repository.find();\n      expect(query).toEqual([fixturePostResponse]);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository&lt;Post&gt;;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        containerName: `${tcName}-typeorm-mysql`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configMySql],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([Post]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get(&#x27;PostRepository&#x27;);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it(&#x27;should be return an array of post&#x27;, async () =&gt; {\n      await repository.save([fixturePostResponse]);\n\n      const query = await repository.find();\n      expect(query).toEqual([fixturePostResponse]);\n    });\n  });\n\n  describe(&#x27;Mongo&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository&lt;User&gt;;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        containerName: `${tcName}-typeorm-mongo`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configMongo],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([User]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get(&#x27;UserRepository&#x27;);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it(&#x27;should be return an array of user&#x27;, async () =&gt; {\n      await repository.save(fixtureUserArrayResponse);\n\n      const query: User[] = await repository.find();\n      expect(query).toEqual(expect.any(Array));\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a4511781-8d3e-4ec4-a992-8288612900fb&quot;,&quot;parentUUID&quot;:&quot;a2e4d055-d321-4602-b965-3b9789fcfa9e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;TypeOrm &gt; Mongo &gt; should be defined&quot;,&quot;title&quot;:&quot;TypeOrm &gt; Mongo &gt; should be defined&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2291,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport {\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  tcName,\n  testContainers,\n  fixturePostResponse,\n  fixtureUserArrayResponse,\n} from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { Repository } from &#x27;typeorm&#x27;;\n\nimport { TypeOrmClientModule } from &#x27;../typeorm/typeorm.module&#x27;;\nimport { Post } from &#x27;./utils/post.entity&#x27;;\nimport { User } from &#x27;./utils/user.entity&#x27;;\n\nimport { configPostgres, configMySql, configMongo } from &#x27;./utils&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TypeOrm&#x27;, () =&gt; {\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository&lt;Post&gt;;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, {\n        ...TCPostgresOptions,\n        containerName: `${tcName}-typeorm-postgres`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configPostgres],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([Post]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get(&#x27;PostRepository&#x27;);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it(&#x27;should be return an array of post&#x27;, async () =&gt; {\n      await repository.save([fixturePostResponse]);\n\n      const query = await repository.find();\n      expect(query).toEqual([fixturePostResponse]);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository&lt;Post&gt;;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        containerName: `${tcName}-typeorm-mysql`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configMySql],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([Post]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get(&#x27;PostRepository&#x27;);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it(&#x27;should be return an array of post&#x27;, async () =&gt; {\n      await repository.save([fixturePostResponse]);\n\n      const query = await repository.find();\n      expect(query).toEqual([fixturePostResponse]);\n    });\n  });\n\n  describe(&#x27;Mongo&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository&lt;User&gt;;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        containerName: `${tcName}-typeorm-mongo`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configMongo],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([User]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get(&#x27;UserRepository&#x27;);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it(&#x27;should be return an array of user&#x27;, async () =&gt; {\n      await repository.save(fixtureUserArrayResponse);\n\n      const query: User[] = await repository.find();\n      expect(query).toEqual(expect.any(Array));\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2a663144-8296-41a5-8289-d2ed3c67db75&quot;,&quot;parentUUID&quot;:&quot;a2e4d055-d321-4602-b965-3b9789fcfa9e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;fullTitle&quot;:&quot;TypeOrm &gt; Mongo &gt; should be return an array of user&quot;,&quot;title&quot;:&quot;TypeOrm &gt; Mongo &gt; should be return an array of user&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:45,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;import { INestApplication } from &#x27;@nestjs/common&#x27;;\nimport { ConfigModule } from &#x27;@nestjs/config&#x27;;\nimport { Test, TestingModule } from &#x27;@nestjs/testing&#x27;;\nimport {\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  tcName,\n  testContainers,\n  fixturePostResponse,\n  fixtureUserArrayResponse,\n} from &#x27;@tresdoce-nestjs-toolkit/test-utils&#x27;;\nimport { Repository } from &#x27;typeorm&#x27;;\n\nimport { TypeOrmClientModule } from &#x27;../typeorm/typeorm.module&#x27;;\nimport { Post } from &#x27;./utils/post.entity&#x27;;\nimport { User } from &#x27;./utils/user.entity&#x27;;\n\nimport { configPostgres, configMySql, configMongo } from &#x27;./utils&#x27;;\n\njest.setTimeout(70000);\ndescribe(&#x27;TypeOrm&#x27;, () =&gt; {\n  describe(&#x27;Postgres&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository&lt;Post&gt;;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;postgres:13&#x27;, {\n        ...TCPostgresOptions,\n        containerName: `${tcName}-typeorm-postgres`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configPostgres],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([Post]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get(&#x27;PostRepository&#x27;);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it(&#x27;should be return an array of post&#x27;, async () =&gt; {\n      await repository.save([fixturePostResponse]);\n\n      const query = await repository.find();\n      expect(query).toEqual([fixturePostResponse]);\n    });\n  });\n\n  describe(&#x27;MySql&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository&lt;Post&gt;;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mysql:5.7&#x27;, {\n        ...TCMySqlOptions,\n        containerName: `${tcName}-typeorm-mysql`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configMySql],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([Post]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get(&#x27;PostRepository&#x27;);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it(&#x27;should be return an array of post&#x27;, async () =&gt; {\n      await repository.save([fixturePostResponse]);\n\n      const query = await repository.find();\n      expect(query).toEqual([fixturePostResponse]);\n    });\n  });\n\n  describe(&#x27;Mongo&#x27;, () =&gt; {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository&lt;User&gt;;\n\n    beforeAll(async () =&gt; {\n      container = await new testContainers(&#x27;mongo:5.0&#x27;, {\n        ...TCMongoOptions,\n        containerName: `${tcName}-typeorm-mongo`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () =&gt; {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () =&gt; {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configMongo],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([User]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get(&#x27;UserRepository&#x27;);\n      await app.init();\n    });\n\n    afterEach(async () =&gt; {\n      await app.close();\n    });\n\n    it(&#x27;should be defined&#x27;, async () =&gt; {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it(&#x27;should be return an array of user&#x27;, async () =&gt; {\n      await repository.save(fixtureUserArrayResponse);\n\n      const query: User[] = await repository.find();\n      expect(query).toEqual(expect.any(Array));\n    });\n  });\n});\n&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;512c321f-c19f-418b-aab3-681304d9bb22&quot;,&quot;parentUUID&quot;:&quot;a2e4d055-d321-4602-b965-3b9789fcfa9e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;dff8abee-e0d1-4ae7-a8fd-c63fb12097c6&quot;,&quot;5101bac4-75a3-4223-85fa-9e1161e846d8&quot;,&quot;b0189dec-dbeb-4b1c-ba55-c945614c660f&quot;,&quot;a4511781-8d3e-4ec4-a992-8288612900fb&quot;,&quot;2a663144-8296-41a5-8289-d2ed3c67db75&quot;,&quot;512c321f-c19f-418b-aab3-681304d9bb22&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:2871,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:5000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:5000}]}" data-config="{&quot;reportFilename&quot;:&quot;index&quot;,&quot;reportDir&quot;:&quot;mochawesome-report&quot;,&quot;reportTitle&quot;:&quot;Tresdoce NestJS Toolkit&quot;,&quot;reportPageTitle&quot;:&quot;Tresdoce NestJS Toolkit - Test Reports&quot;,&quot;inline&quot;:false,&quot;inlineAssets&quot;:false,&quot;assetsDir&quot;:&quot;mochawesome-report/assets&quot;,&quot;cdn&quot;:false,&quot;charts&quot;:true,&quot;enableCharts&quot;:true,&quot;code&quot;:true,&quot;enableCode&quot;:true,&quot;autoOpen&quot;:false,&quot;overwrite&quot;:true,&quot;timestamp&quot;:false,&quot;ts&quot;:false,&quot;showPassed&quot;:true,&quot;showFailed&quot;:true,&quot;showPending&quot;:true,&quot;showSkipped&quot;:false,&quot;showHooks&quot;:&quot;failed&quot;,&quot;saveJson&quot;:false,&quot;saveHtml&quot;:true,&quot;dev&quot;:false,&quot;htmlFile&quot;:&quot;/Users/maximilianodelgado/Projects/Mex/tresdoce-nestjs-toolkit/mochawesome-report/index.html&quot;}"><div id="report"></div><script src="assets/app.js"></script></body></html>