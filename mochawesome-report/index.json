{
  "stats": {
    "suites": 13,
    "tests": 155,
    "passes": 155,
    "pending": 0,
    "failures": 0,
    "testsRegistered": 155,
    "passPercent": 100,
    "pendingPercent": 0,
    "other": 0,
    "hasOther": false,
    "skipped": 0,
    "hasSkipped": false,
    "start": "2023-05-03T12:59:18.946Z",
    "end": "2023-05-05T13:19:01.490Z",
    "duration": 173982544
  },
  "results": [
    {
      "uuid": "75292f1c-953c-4f5d-9511-a0ff51df03b0",
      "title": "@tresdoce-nestjs-toolkit/archetype",
      "fullFile": "",
      "file": "",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "b8d02835-1254-45b7-b274-580ef3b4bc49",
          "title": "@tresdoce-nestjs-toolkit/archetype",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "fullTitle": "Constants > should be return exclude to prefix global",
              "title": "Constants > should be return exclude to prefix global",
              "timedOut": false,
              "duration": 3,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { RequestMethod } from '@nestjs/common';\nimport { manifestControllerExcludes } from '../archetype/constants/archetype.constants';\n\ndescribe('Constants', () => {\n  it('should be return exclude to prefix global', async () => {\n    expect(manifestControllerExcludes).toEqual(expect.any(Array));\n    expect(manifestControllerExcludes).toMatchObject([\n      {\n        path: '/info',\n        method: RequestMethod.GET,\n      },\n    ]);\n  });\n});\n",
              "err": {},
              "uuid": "ff8814c4-28a1-4306-a0a9-aac2db2eb62a",
              "parentUUID": "b8d02835-1254-45b7-b274-580ef3b4bc49",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "ArchetypeService > should be defined",
              "title": "ArchetypeService > should be defined",
              "timedOut": false,
              "duration": 13,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { ConfigModule } from '@nestjs/config';\n\nimport { config, manifest } from '@tresdoce-nestjs-toolkit/test-utils';\n\nimport { ArchetypeModule } from '../archetype/archetype.module';\nimport { ArchetypeService } from '../archetype/services/archetype.service';\n\ndescribe('ArchetypeService', () => {\n  let service: ArchetypeService;\n  /*const archetypeService = {\n      readFile: jest.fn(() => manifest),\n      getArchetypeVersion: jest.fn(() => ({ archetypeVersion: manifest.archetypeVersion })),\n      getApplicationInfo: jest.fn(() => ({\n        name: manifest.name,\n        version: manifest.version,\n        description: manifest.description,\n        author: manifest.author,\n        repository: manifest.repository,\n        homepage: manifest.homepage,\n        dependencies: manifest.dependencies,\n        devDependencies: manifest.devDependencies,\n      })),\n      generateManifest: jest.fn(() => manifest),\n    };*/\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        ArchetypeModule,\n      ],\n      providers: [ArchetypeService],\n    }).compile();\n\n    service = module.get<ArchetypeService>(ArchetypeService);\n  });\n\n  it('should be defined', () => {\n    expect(service).toBeDefined();\n  });\n\n  it('should be read package file', async () => {\n    const packageFile = await service.readFile(__dirname, '../../package.json');\n    expect(packageFile).toBeDefined();\n    expect(packageFile).toEqual(expect.any(Object));\n  });\n\n  it('should be return archetype version', async () => {\n    service.readFile = jest.fn().mockImplementation(() => ({ version: manifest.archetypeVersion }));\n\n    expect(await service.getArchetypeVersion()).toEqual({\n      archetypeVersion: manifest.archetypeVersion,\n    });\n  });\n\n  it('should be return application info', async () => {\n    service.readFile = jest.fn().mockImplementation(() => ({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: manifest.dependencies,\n      devDependencies: manifest.devDependencies,\n    }));\n\n    expect(await service.getApplicationInfo()).toEqual({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: {\n        '@tresdoce-nestjs-toolkit/archetype': '0.0.1',\n        '@tresdoce-nestjs-toolkit/health': '0.0.1',\n        '@tresdoce-nestjs-toolkit/http-client': '0.0.1',\n        '@nestjs/class-transformer': '^0.4.0',\n        '@nestjs/class-validator': '^0.13.3',\n        '@nestjs/common': '^9.2.1',\n        '@nestjs/config': '^2.2.0',\n        '@nestjs/core': '^8.2.5',\n        '@nestjs/platform-express': '^8.2.5',\n        '@nestjs/swagger': '^5.1.5',\n      },\n      devDependencies: {\n        '@tresdoce-nestjs-toolkit/commons': '0.0.1',\n        '@nestjs/cli': '^9.1.8',\n        '@nestjs/schematics': '^9.1.0',\n        '@nestjs/testing': '^9.4.0',\n      },\n    });\n  });\n\n  it('should be return manifest', async () => {\n    service.getArchetypeVersion = jest.fn().mockImplementation(() => ({\n      archetypeVersion: manifest.archetypeVersion,\n    }));\n\n    service.getApplicationInfo = jest.fn().mockImplementation(() => ({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: manifest.dependencies,\n      devDependencies: manifest.devDependencies,\n    }));\n\n    expect(await service.generateManifest()).toEqual({ ...manifest });\n  });\n});\n",
              "err": {},
              "uuid": "64e83238-36ca-46ca-912e-747de812fb10",
              "parentUUID": "b8d02835-1254-45b7-b274-580ef3b4bc49",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "ArchetypeService > should be read package file",
              "title": "ArchetypeService > should be read package file",
              "timedOut": false,
              "duration": 5,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { ConfigModule } from '@nestjs/config';\n\nimport { config, manifest } from '@tresdoce-nestjs-toolkit/test-utils';\n\nimport { ArchetypeModule } from '../archetype/archetype.module';\nimport { ArchetypeService } from '../archetype/services/archetype.service';\n\ndescribe('ArchetypeService', () => {\n  let service: ArchetypeService;\n  /*const archetypeService = {\n      readFile: jest.fn(() => manifest),\n      getArchetypeVersion: jest.fn(() => ({ archetypeVersion: manifest.archetypeVersion })),\n      getApplicationInfo: jest.fn(() => ({\n        name: manifest.name,\n        version: manifest.version,\n        description: manifest.description,\n        author: manifest.author,\n        repository: manifest.repository,\n        homepage: manifest.homepage,\n        dependencies: manifest.dependencies,\n        devDependencies: manifest.devDependencies,\n      })),\n      generateManifest: jest.fn(() => manifest),\n    };*/\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        ArchetypeModule,\n      ],\n      providers: [ArchetypeService],\n    }).compile();\n\n    service = module.get<ArchetypeService>(ArchetypeService);\n  });\n\n  it('should be defined', () => {\n    expect(service).toBeDefined();\n  });\n\n  it('should be read package file', async () => {\n    const packageFile = await service.readFile(__dirname, '../../package.json');\n    expect(packageFile).toBeDefined();\n    expect(packageFile).toEqual(expect.any(Object));\n  });\n\n  it('should be return archetype version', async () => {\n    service.readFile = jest.fn().mockImplementation(() => ({ version: manifest.archetypeVersion }));\n\n    expect(await service.getArchetypeVersion()).toEqual({\n      archetypeVersion: manifest.archetypeVersion,\n    });\n  });\n\n  it('should be return application info', async () => {\n    service.readFile = jest.fn().mockImplementation(() => ({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: manifest.dependencies,\n      devDependencies: manifest.devDependencies,\n    }));\n\n    expect(await service.getApplicationInfo()).toEqual({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: {\n        '@tresdoce-nestjs-toolkit/archetype': '0.0.1',\n        '@tresdoce-nestjs-toolkit/health': '0.0.1',\n        '@tresdoce-nestjs-toolkit/http-client': '0.0.1',\n        '@nestjs/class-transformer': '^0.4.0',\n        '@nestjs/class-validator': '^0.13.3',\n        '@nestjs/common': '^9.2.1',\n        '@nestjs/config': '^2.2.0',\n        '@nestjs/core': '^8.2.5',\n        '@nestjs/platform-express': '^8.2.5',\n        '@nestjs/swagger': '^5.1.5',\n      },\n      devDependencies: {\n        '@tresdoce-nestjs-toolkit/commons': '0.0.1',\n        '@nestjs/cli': '^9.1.8',\n        '@nestjs/schematics': '^9.1.0',\n        '@nestjs/testing': '^9.4.0',\n      },\n    });\n  });\n\n  it('should be return manifest', async () => {\n    service.getArchetypeVersion = jest.fn().mockImplementation(() => ({\n      archetypeVersion: manifest.archetypeVersion,\n    }));\n\n    service.getApplicationInfo = jest.fn().mockImplementation(() => ({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: manifest.dependencies,\n      devDependencies: manifest.devDependencies,\n    }));\n\n    expect(await service.generateManifest()).toEqual({ ...manifest });\n  });\n});\n",
              "err": {},
              "uuid": "22b75286-0e8c-4e31-89ca-120ec6c6970a",
              "parentUUID": "b8d02835-1254-45b7-b274-580ef3b4bc49",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "ArchetypeService > should be return archetype version",
              "title": "ArchetypeService > should be return archetype version",
              "timedOut": false,
              "duration": 4,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { ConfigModule } from '@nestjs/config';\n\nimport { config, manifest } from '@tresdoce-nestjs-toolkit/test-utils';\n\nimport { ArchetypeModule } from '../archetype/archetype.module';\nimport { ArchetypeService } from '../archetype/services/archetype.service';\n\ndescribe('ArchetypeService', () => {\n  let service: ArchetypeService;\n  /*const archetypeService = {\n      readFile: jest.fn(() => manifest),\n      getArchetypeVersion: jest.fn(() => ({ archetypeVersion: manifest.archetypeVersion })),\n      getApplicationInfo: jest.fn(() => ({\n        name: manifest.name,\n        version: manifest.version,\n        description: manifest.description,\n        author: manifest.author,\n        repository: manifest.repository,\n        homepage: manifest.homepage,\n        dependencies: manifest.dependencies,\n        devDependencies: manifest.devDependencies,\n      })),\n      generateManifest: jest.fn(() => manifest),\n    };*/\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        ArchetypeModule,\n      ],\n      providers: [ArchetypeService],\n    }).compile();\n\n    service = module.get<ArchetypeService>(ArchetypeService);\n  });\n\n  it('should be defined', () => {\n    expect(service).toBeDefined();\n  });\n\n  it('should be read package file', async () => {\n    const packageFile = await service.readFile(__dirname, '../../package.json');\n    expect(packageFile).toBeDefined();\n    expect(packageFile).toEqual(expect.any(Object));\n  });\n\n  it('should be return archetype version', async () => {\n    service.readFile = jest.fn().mockImplementation(() => ({ version: manifest.archetypeVersion }));\n\n    expect(await service.getArchetypeVersion()).toEqual({\n      archetypeVersion: manifest.archetypeVersion,\n    });\n  });\n\n  it('should be return application info', async () => {\n    service.readFile = jest.fn().mockImplementation(() => ({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: manifest.dependencies,\n      devDependencies: manifest.devDependencies,\n    }));\n\n    expect(await service.getApplicationInfo()).toEqual({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: {\n        '@tresdoce-nestjs-toolkit/archetype': '0.0.1',\n        '@tresdoce-nestjs-toolkit/health': '0.0.1',\n        '@tresdoce-nestjs-toolkit/http-client': '0.0.1',\n        '@nestjs/class-transformer': '^0.4.0',\n        '@nestjs/class-validator': '^0.13.3',\n        '@nestjs/common': '^9.2.1',\n        '@nestjs/config': '^2.2.0',\n        '@nestjs/core': '^8.2.5',\n        '@nestjs/platform-express': '^8.2.5',\n        '@nestjs/swagger': '^5.1.5',\n      },\n      devDependencies: {\n        '@tresdoce-nestjs-toolkit/commons': '0.0.1',\n        '@nestjs/cli': '^9.1.8',\n        '@nestjs/schematics': '^9.1.0',\n        '@nestjs/testing': '^9.4.0',\n      },\n    });\n  });\n\n  it('should be return manifest', async () => {\n    service.getArchetypeVersion = jest.fn().mockImplementation(() => ({\n      archetypeVersion: manifest.archetypeVersion,\n    }));\n\n    service.getApplicationInfo = jest.fn().mockImplementation(() => ({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: manifest.dependencies,\n      devDependencies: manifest.devDependencies,\n    }));\n\n    expect(await service.generateManifest()).toEqual({ ...manifest });\n  });\n});\n",
              "err": {},
              "uuid": "562055ca-7c34-4ec7-9f64-1a91ba135be5",
              "parentUUID": "b8d02835-1254-45b7-b274-580ef3b4bc49",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "ArchetypeService > should be return application info",
              "title": "ArchetypeService > should be return application info",
              "timedOut": false,
              "duration": 4,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { ConfigModule } from '@nestjs/config';\n\nimport { config, manifest } from '@tresdoce-nestjs-toolkit/test-utils';\n\nimport { ArchetypeModule } from '../archetype/archetype.module';\nimport { ArchetypeService } from '../archetype/services/archetype.service';\n\ndescribe('ArchetypeService', () => {\n  let service: ArchetypeService;\n  /*const archetypeService = {\n      readFile: jest.fn(() => manifest),\n      getArchetypeVersion: jest.fn(() => ({ archetypeVersion: manifest.archetypeVersion })),\n      getApplicationInfo: jest.fn(() => ({\n        name: manifest.name,\n        version: manifest.version,\n        description: manifest.description,\n        author: manifest.author,\n        repository: manifest.repository,\n        homepage: manifest.homepage,\n        dependencies: manifest.dependencies,\n        devDependencies: manifest.devDependencies,\n      })),\n      generateManifest: jest.fn(() => manifest),\n    };*/\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        ArchetypeModule,\n      ],\n      providers: [ArchetypeService],\n    }).compile();\n\n    service = module.get<ArchetypeService>(ArchetypeService);\n  });\n\n  it('should be defined', () => {\n    expect(service).toBeDefined();\n  });\n\n  it('should be read package file', async () => {\n    const packageFile = await service.readFile(__dirname, '../../package.json');\n    expect(packageFile).toBeDefined();\n    expect(packageFile).toEqual(expect.any(Object));\n  });\n\n  it('should be return archetype version', async () => {\n    service.readFile = jest.fn().mockImplementation(() => ({ version: manifest.archetypeVersion }));\n\n    expect(await service.getArchetypeVersion()).toEqual({\n      archetypeVersion: manifest.archetypeVersion,\n    });\n  });\n\n  it('should be return application info', async () => {\n    service.readFile = jest.fn().mockImplementation(() => ({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: manifest.dependencies,\n      devDependencies: manifest.devDependencies,\n    }));\n\n    expect(await service.getApplicationInfo()).toEqual({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: {\n        '@tresdoce-nestjs-toolkit/archetype': '0.0.1',\n        '@tresdoce-nestjs-toolkit/health': '0.0.1',\n        '@tresdoce-nestjs-toolkit/http-client': '0.0.1',\n        '@nestjs/class-transformer': '^0.4.0',\n        '@nestjs/class-validator': '^0.13.3',\n        '@nestjs/common': '^9.2.1',\n        '@nestjs/config': '^2.2.0',\n        '@nestjs/core': '^8.2.5',\n        '@nestjs/platform-express': '^8.2.5',\n        '@nestjs/swagger': '^5.1.5',\n      },\n      devDependencies: {\n        '@tresdoce-nestjs-toolkit/commons': '0.0.1',\n        '@nestjs/cli': '^9.1.8',\n        '@nestjs/schematics': '^9.1.0',\n        '@nestjs/testing': '^9.4.0',\n      },\n    });\n  });\n\n  it('should be return manifest', async () => {\n    service.getArchetypeVersion = jest.fn().mockImplementation(() => ({\n      archetypeVersion: manifest.archetypeVersion,\n    }));\n\n    service.getApplicationInfo = jest.fn().mockImplementation(() => ({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: manifest.dependencies,\n      devDependencies: manifest.devDependencies,\n    }));\n\n    expect(await service.generateManifest()).toEqual({ ...manifest });\n  });\n});\n",
              "err": {},
              "uuid": "e37f224c-673c-4d74-9282-aea6b54fe043",
              "parentUUID": "b8d02835-1254-45b7-b274-580ef3b4bc49",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "ArchetypeService > should be return manifest",
              "title": "ArchetypeService > should be return manifest",
              "timedOut": false,
              "duration": 3,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { ConfigModule } from '@nestjs/config';\n\nimport { config, manifest } from '@tresdoce-nestjs-toolkit/test-utils';\n\nimport { ArchetypeModule } from '../archetype/archetype.module';\nimport { ArchetypeService } from '../archetype/services/archetype.service';\n\ndescribe('ArchetypeService', () => {\n  let service: ArchetypeService;\n  /*const archetypeService = {\n      readFile: jest.fn(() => manifest),\n      getArchetypeVersion: jest.fn(() => ({ archetypeVersion: manifest.archetypeVersion })),\n      getApplicationInfo: jest.fn(() => ({\n        name: manifest.name,\n        version: manifest.version,\n        description: manifest.description,\n        author: manifest.author,\n        repository: manifest.repository,\n        homepage: manifest.homepage,\n        dependencies: manifest.dependencies,\n        devDependencies: manifest.devDependencies,\n      })),\n      generateManifest: jest.fn(() => manifest),\n    };*/\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        ArchetypeModule,\n      ],\n      providers: [ArchetypeService],\n    }).compile();\n\n    service = module.get<ArchetypeService>(ArchetypeService);\n  });\n\n  it('should be defined', () => {\n    expect(service).toBeDefined();\n  });\n\n  it('should be read package file', async () => {\n    const packageFile = await service.readFile(__dirname, '../../package.json');\n    expect(packageFile).toBeDefined();\n    expect(packageFile).toEqual(expect.any(Object));\n  });\n\n  it('should be return archetype version', async () => {\n    service.readFile = jest.fn().mockImplementation(() => ({ version: manifest.archetypeVersion }));\n\n    expect(await service.getArchetypeVersion()).toEqual({\n      archetypeVersion: manifest.archetypeVersion,\n    });\n  });\n\n  it('should be return application info', async () => {\n    service.readFile = jest.fn().mockImplementation(() => ({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: manifest.dependencies,\n      devDependencies: manifest.devDependencies,\n    }));\n\n    expect(await service.getApplicationInfo()).toEqual({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: {\n        '@tresdoce-nestjs-toolkit/archetype': '0.0.1',\n        '@tresdoce-nestjs-toolkit/health': '0.0.1',\n        '@tresdoce-nestjs-toolkit/http-client': '0.0.1',\n        '@nestjs/class-transformer': '^0.4.0',\n        '@nestjs/class-validator': '^0.13.3',\n        '@nestjs/common': '^9.2.1',\n        '@nestjs/config': '^2.2.0',\n        '@nestjs/core': '^8.2.5',\n        '@nestjs/platform-express': '^8.2.5',\n        '@nestjs/swagger': '^5.1.5',\n      },\n      devDependencies: {\n        '@tresdoce-nestjs-toolkit/commons': '0.0.1',\n        '@nestjs/cli': '^9.1.8',\n        '@nestjs/schematics': '^9.1.0',\n        '@nestjs/testing': '^9.4.0',\n      },\n    });\n  });\n\n  it('should be return manifest', async () => {\n    service.getArchetypeVersion = jest.fn().mockImplementation(() => ({\n      archetypeVersion: manifest.archetypeVersion,\n    }));\n\n    service.getApplicationInfo = jest.fn().mockImplementation(() => ({\n      apiPrefix: manifest.apiPrefix,\n      name: manifest.name,\n      version: manifest.version,\n      description: manifest.description,\n      author: manifest.author,\n      repository: manifest.repository,\n      homepage: manifest.homepage,\n      dependencies: manifest.dependencies,\n      devDependencies: manifest.devDependencies,\n    }));\n\n    expect(await service.generateManifest()).toEqual({ ...manifest });\n  });\n});\n",
              "err": {},
              "uuid": "abda106f-1bb2-457b-bd44-8679a51e6e1e",
              "parentUUID": "b8d02835-1254-45b7-b274-580ef3b4bc49",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "ArchetypeModule > should be define",
              "title": "ArchetypeModule > should be define",
              "timedOut": false,
              "duration": 176,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { INestApplication } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\n\nimport { ArchetypeModule } from '../archetype/archetype.module';\n\ndescribe('ArchetypeModule', () => {\n  let app: INestApplication;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        ArchetypeModule,\n      ],\n    }).compile();\n\n    app = module.createNestApplication();\n    await app.init();\n  });\n\n  it('should be define', async () => {\n    expect(app).toBeDefined();\n  });\n});\n",
              "err": {},
              "uuid": "1589982f-89e3-408b-9c27-ac6218a19536",
              "parentUUID": "b8d02835-1254-45b7-b274-580ef3b4bc49",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "ArchetypeController > should be defined",
              "title": "ArchetypeController > should be defined",
              "timedOut": false,
              "duration": 15,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { ConfigModule } from '@nestjs/config';\n\nimport { config, manifest } from '@tresdoce-nestjs-toolkit/test-utils';\n\nimport { ArchetypeModule } from '../archetype/archetype.module';\nimport { ArchetypeController } from '../archetype/controllers/archetype.controller';\nimport { ArchetypeService } from '../archetype/services/archetype.service';\n\ndescribe('ArchetypeController', () => {\n  let controller: ArchetypeController;\n  const archetypeService = {\n    generateManifest: () => manifest,\n  };\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        ArchetypeModule,\n      ],\n      controllers: [ArchetypeController],\n      providers: [ArchetypeService],\n    })\n      .overrideProvider(ArchetypeService)\n      .useValue(archetypeService)\n      .compile();\n\n    controller = module.get<ArchetypeController>(ArchetypeController);\n  });\n\n  it('should be defined', () => {\n    expect(controller).toBeDefined();\n  });\n\n  it('should be return manifest json', async () => {\n    expect(await controller.getArchetypeInfo()).toBeDefined();\n    expect(await controller.getArchetypeInfo()).toEqual(manifest);\n  });\n});\n",
              "err": {},
              "uuid": "84630f0a-3aa5-487f-8ebb-bf998274d0a4",
              "parentUUID": "b8d02835-1254-45b7-b274-580ef3b4bc49",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "ArchetypeController > should be return manifest json",
              "title": "ArchetypeController > should be return manifest json",
              "timedOut": false,
              "duration": 10,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { ConfigModule } from '@nestjs/config';\n\nimport { config, manifest } from '@tresdoce-nestjs-toolkit/test-utils';\n\nimport { ArchetypeModule } from '../archetype/archetype.module';\nimport { ArchetypeController } from '../archetype/controllers/archetype.controller';\nimport { ArchetypeService } from '../archetype/services/archetype.service';\n\ndescribe('ArchetypeController', () => {\n  let controller: ArchetypeController;\n  const archetypeService = {\n    generateManifest: () => manifest,\n  };\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        ArchetypeModule,\n      ],\n      controllers: [ArchetypeController],\n      providers: [ArchetypeService],\n    })\n      .overrideProvider(ArchetypeService)\n      .useValue(archetypeService)\n      .compile();\n\n    controller = module.get<ArchetypeController>(ArchetypeController);\n  });\n\n  it('should be defined', () => {\n    expect(controller).toBeDefined();\n  });\n\n  it('should be return manifest json', async () => {\n    expect(await controller.getArchetypeInfo()).toBeDefined();\n    expect(await controller.getArchetypeInfo()).toEqual(manifest);\n  });\n});\n",
              "err": {},
              "uuid": "8b30e9c1-b1a1-4d9e-87e6-9cfefb180c08",
              "parentUUID": "b8d02835-1254-45b7-b274-580ef3b4bc49",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "ff8814c4-28a1-4306-a0a9-aac2db2eb62a",
            "64e83238-36ca-46ca-912e-747de812fb10",
            "22b75286-0e8c-4e31-89ca-120ec6c6970a",
            "562055ca-7c34-4ec7-9f64-1a91ba135be5",
            "e37f224c-673c-4d74-9282-aea6b54fe043",
            "abda106f-1bb2-457b-bd44-8679a51e6e1e",
            "1589982f-89e3-408b-9c27-ac6218a19536",
            "84630f0a-3aa5-487f-8ebb-bf998274d0a4",
            "8b30e9c1-b1a1-4d9e-87e6-9cfefb180c08"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 233,
          "root": false,
          "rootEmpty": false,
          "_timeout": 5000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 5000
    },
    {
      "uuid": "52a2b92b-6964-4091-a0f7-a550e5f41e5b",
      "title": "@tresdoce-nestjs-toolkit/camunda",
      "fullFile": "",
      "file": "",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "e06016ae-c05f-45a2-b550-df0909725a04",
          "title": "@tresdoce-nestjs-toolkit/camunda",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "fullTitle": "CamundaModule > should be defined",
              "title": "CamundaModule > should be defined",
              "timedOut": false,
              "duration": 177,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { INestApplication } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport { CamundaModule } from '../camunda/camunda.module';\nimport { dynamicConfig, tcName, testContainers } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { Subscription } from '../camunda/decorators/camunda.decorator';\nimport { CamundaTaskConnector } from '../camunda/providers/camunda.provider';\n\ndescribe('CamundaModule', () => {\n  let app: INestApplication;\n  let container: testContainers;\n\n  beforeAll(async () => {\n    container = await new testContainers('camunda/camunda-bpm-platform:7.17.0', {\n      ports: [\n        {\n          container: 8080,\n          host: 8080,\n        },\n      ],\n      containerName: `${tcName}-camunda-bpm`,\n      reuse: true,\n    });\n    await container.start();\n  });\n\n  afterAll(async () => {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () => {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              camunda: {\n                baseUrl: 'http://localhost:8080/engine-rest',\n              },\n            }),\n          ],\n        }),\n        CamundaModule,\n      ],\n    }).compile();\n\n    app = moduleFixture.createNestApplication();\n    app.connectMicroservice({\n      strategy: app.get(CamundaTaskConnector),\n    });\n    await app.startAllMicroservices();\n    await app.init();\n  });\n\n  it('should be defined', () => {\n    expect(app).toBeDefined();\n  });\n\n  it('should be Subscription decorator is defined with options', async () => {\n    const decorator = Subscription('test-topic', { lockDuration: 500 });\n    console.log(decorator);\n    expect(decorator).toBeDefined();\n  });\n});\n",
              "err": {},
              "uuid": "d003e42c-3476-4e59-a224-b05989e3a999",
              "parentUUID": "e06016ae-c05f-45a2-b550-df0909725a04",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "CamundaModule > should be Subscription decorator is defined with options",
              "title": "CamundaModule > should be Subscription decorator is defined with options",
              "timedOut": false,
              "duration": 9,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { INestApplication } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport { CamundaModule } from '../camunda/camunda.module';\nimport { dynamicConfig, tcName, testContainers } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { Subscription } from '../camunda/decorators/camunda.decorator';\nimport { CamundaTaskConnector } from '../camunda/providers/camunda.provider';\n\ndescribe('CamundaModule', () => {\n  let app: INestApplication;\n  let container: testContainers;\n\n  beforeAll(async () => {\n    container = await new testContainers('camunda/camunda-bpm-platform:7.17.0', {\n      ports: [\n        {\n          container: 8080,\n          host: 8080,\n        },\n      ],\n      containerName: `${tcName}-camunda-bpm`,\n      reuse: true,\n    });\n    await container.start();\n  });\n\n  afterAll(async () => {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () => {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              camunda: {\n                baseUrl: 'http://localhost:8080/engine-rest',\n              },\n            }),\n          ],\n        }),\n        CamundaModule,\n      ],\n    }).compile();\n\n    app = moduleFixture.createNestApplication();\n    app.connectMicroservice({\n      strategy: app.get(CamundaTaskConnector),\n    });\n    await app.startAllMicroservices();\n    await app.init();\n  });\n\n  it('should be defined', () => {\n    expect(app).toBeDefined();\n  });\n\n  it('should be Subscription decorator is defined with options', async () => {\n    const decorator = Subscription('test-topic', { lockDuration: 500 });\n    console.log(decorator);\n    expect(decorator).toBeDefined();\n  });\n});\n",
              "err": {},
              "uuid": "3509395e-b7dc-4f4e-9790-711f4c8c9da2",
              "parentUUID": "e06016ae-c05f-45a2-b550-df0909725a04",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "d003e42c-3476-4e59-a224-b05989e3a999",
            "3509395e-b7dc-4f4e-9790-711f4c8c9da2"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 186,
          "root": false,
          "rootEmpty": false,
          "_timeout": 5000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 5000
    },
    {
      "uuid": "9134f974-0456-4760-b66e-9bab6a0072f6",
      "title": "@tresdoce-nestjs-toolkit/commons",
      "fullFile": "",
      "file": "",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "05f0e9f7-549a-4cae-9195-4f50b743658c",
          "title": "@tresdoce-nestjs-toolkit/commons",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "fullTitle": "build-config > should be return jest config is build",
              "title": "build-config > should be return jest config is build",
              "timedOut": false,
              "duration": 3,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { buildConfig } from '../index';\ndescribe('build-config', () => {\n  const INIT_ENVS = process.env;\n\n  beforeEach(() => {\n    jest.resetModules();\n    process.env = { ...INIT_ENVS };\n  });\n\n  afterAll(() => {\n    process.env = INIT_ENVS;\n  });\n\n  it('should be return jest config is build', () => {\n    process.env.NODE_ENV = 'build';\n    const config = buildConfig({ output: {}, optimization: {} });\n    expect(config).not.toBe(null);\n    expect(typeof config).toBe('object');\n    expect(config).toBeDefined();\n    expect(config.mode).toEqual('production');\n  });\n\n  it('should be return jest config not is build', () => {\n    process.env.NODE_ENV = 'dev';\n    const config = buildConfig({ output: {}, optimization: {} });\n    expect(config).not.toBe(null);\n    expect(typeof config).toBe('object');\n    expect(config).toBeDefined();\n    expect(config.mode).toEqual('none');\n  });\n});\n",
              "err": {},
              "uuid": "c6966595-2662-4fac-abb4-c256a2c1a8dc",
              "parentUUID": "05f0e9f7-549a-4cae-9195-4f50b743658c",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "build-config > should be return jest config not is build",
              "title": "build-config > should be return jest config not is build",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { buildConfig } from '../index';\ndescribe('build-config', () => {\n  const INIT_ENVS = process.env;\n\n  beforeEach(() => {\n    jest.resetModules();\n    process.env = { ...INIT_ENVS };\n  });\n\n  afterAll(() => {\n    process.env = INIT_ENVS;\n  });\n\n  it('should be return jest config is build', () => {\n    process.env.NODE_ENV = 'build';\n    const config = buildConfig({ output: {}, optimization: {} });\n    expect(config).not.toBe(null);\n    expect(typeof config).toBe('object');\n    expect(config).toBeDefined();\n    expect(config.mode).toEqual('production');\n  });\n\n  it('should be return jest config not is build', () => {\n    process.env.NODE_ENV = 'dev';\n    const config = buildConfig({ output: {}, optimization: {} });\n    expect(config).not.toBe(null);\n    expect(typeof config).toBe('object');\n    expect(config).toBeDefined();\n    expect(config.mode).toEqual('none');\n  });\n});\n",
              "err": {},
              "uuid": "d7a8aadf-6a65-47a7-a0d1-6599072eeb23",
              "parentUUID": "05f0e9f7-549a-4cae-9195-4f50b743658c",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "testing-library > should be return jest config",
              "title": "testing-library > should be return jest config",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { jestConfig } from '../index';\n\ndescribe('testing-library', () => {\n  it('should be return jest config', () => {\n    const config = jestConfig();\n    expect(config).not.toBe(null);\n    expect(typeof config).toBe('object');\n    expect(config).toBeDefined();\n  });\n});\n",
              "err": {},
              "uuid": "7d07e3f4-48ac-4308-8c17-34e45868689a",
              "parentUUID": "05f0e9f7-549a-4cae-9195-4f50b743658c",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "eslint-config > should be return jest config",
              "title": "eslint-config > should be return jest config",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { eslintConfig } from '../index';\ndescribe('eslint-config', () => {\n  it('should be return jest config', () => {\n    const config = eslintConfig();\n    expect(config).not.toBe(null);\n    expect(typeof config).toBe('object');\n    expect(config).toBeDefined();\n  });\n});\n",
              "err": {},
              "uuid": "03544d79-00c1-4c54-88f3-2357f75aa579",
              "parentUUID": "05f0e9f7-549a-4cae-9195-4f50b743658c",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "c6966595-2662-4fac-abb4-c256a2c1a8dc",
            "d7a8aadf-6a65-47a7-a0d1-6599072eeb23",
            "7d07e3f4-48ac-4308-8c17-34e45868689a",
            "03544d79-00c1-4c54-88f3-2357f75aa579"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 8,
          "root": false,
          "rootEmpty": false,
          "_timeout": 5000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 5000
    },
    {
      "uuid": "a5a6f14a-90ec-410c-8361-f8188348a5e7",
      "title": "@tresdoce-nestjs-toolkit/core",
      "fullFile": "",
      "file": "",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "fef2c576-2dad-42e2-94b3-6609a1a5ea47",
          "title": "@tresdoce-nestjs-toolkit/core",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "fullTitle": "commons > with env context > should be return commons exclude paths with context",
              "title": "commons > with env context > should be return commons exclude paths with context",
              "timedOut": false,
              "duration": 3,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { corePathsExcludes, excludePaths } from '../index';\nimport { RequestMethod } from '@nestjs/common';\n\ndescribe('commons', () => {\n  describe('with env context', () => {\n    beforeEach(() => {\n      process.env.CONTEXT = 'v1/api-test';\n    });\n\n    it('should be return commons exclude paths with context', () => {\n      expect(corePathsExcludes()).not.toBe(null);\n      expect(corePathsExcludes()).toBeDefined();\n      expect(corePathsExcludes()).toBeInstanceOf(Array);\n\n      expect(corePathsExcludes()).toContainObject({\n        path: `/v1/api-test/health/liveness`,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: `/v1/api-test/health/readiness`,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: `/v1/api-test/info`,\n        method: RequestMethod.GET,\n      });\n    });\n\n    it('should be return array of exclude paths with context', () => {\n      expect(excludePaths()).not.toBe(null);\n      expect(excludePaths()).toBeDefined();\n      expect(excludePaths()).toBeInstanceOf(Array);\n      expect(excludePaths()).toEqual([\n        `/v1/api-test/health/liveness`,\n        `/v1/api-test/health/readiness`,\n        `/v1/api-test/info`,\n      ]);\n    });\n  });\n\n  describe('without env context', () => {\n    beforeEach(() => {\n      process.env.CONTEXT = '';\n    });\n\n    it('should be return commons exclude paths without context', () => {\n      expect(corePathsExcludes()).not.toBe(null);\n      expect(corePathsExcludes()).toBeDefined();\n      expect(corePathsExcludes()).toBeInstanceOf(Array);\n\n      expect(corePathsExcludes()).toContainObject({\n        path: '/health/liveness',\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: '/health/readiness',\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: '/info',\n        method: RequestMethod.GET,\n      });\n    });\n\n    it('should be return array of exclude paths without context', () => {\n      expect(excludePaths()).not.toBe(null);\n      expect(excludePaths()).toBeDefined();\n      expect(excludePaths()).toBeInstanceOf(Array);\n      expect(excludePaths()).toEqual(['/health/liveness', '/health/readiness', '/info']);\n    });\n  });\n});\n",
              "err": {},
              "uuid": "6daa302e-8e35-4483-8363-a6a8a03eeab2",
              "parentUUID": "fef2c576-2dad-42e2-94b3-6609a1a5ea47",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "commons > with env context > should be return array of exclude paths with context",
              "title": "commons > with env context > should be return array of exclude paths with context",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { corePathsExcludes, excludePaths } from '../index';\nimport { RequestMethod } from '@nestjs/common';\n\ndescribe('commons', () => {\n  describe('with env context', () => {\n    beforeEach(() => {\n      process.env.CONTEXT = 'v1/api-test';\n    });\n\n    it('should be return commons exclude paths with context', () => {\n      expect(corePathsExcludes()).not.toBe(null);\n      expect(corePathsExcludes()).toBeDefined();\n      expect(corePathsExcludes()).toBeInstanceOf(Array);\n\n      expect(corePathsExcludes()).toContainObject({\n        path: `/v1/api-test/health/liveness`,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: `/v1/api-test/health/readiness`,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: `/v1/api-test/info`,\n        method: RequestMethod.GET,\n      });\n    });\n\n    it('should be return array of exclude paths with context', () => {\n      expect(excludePaths()).not.toBe(null);\n      expect(excludePaths()).toBeDefined();\n      expect(excludePaths()).toBeInstanceOf(Array);\n      expect(excludePaths()).toEqual([\n        `/v1/api-test/health/liveness`,\n        `/v1/api-test/health/readiness`,\n        `/v1/api-test/info`,\n      ]);\n    });\n  });\n\n  describe('without env context', () => {\n    beforeEach(() => {\n      process.env.CONTEXT = '';\n    });\n\n    it('should be return commons exclude paths without context', () => {\n      expect(corePathsExcludes()).not.toBe(null);\n      expect(corePathsExcludes()).toBeDefined();\n      expect(corePathsExcludes()).toBeInstanceOf(Array);\n\n      expect(corePathsExcludes()).toContainObject({\n        path: '/health/liveness',\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: '/health/readiness',\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: '/info',\n        method: RequestMethod.GET,\n      });\n    });\n\n    it('should be return array of exclude paths without context', () => {\n      expect(excludePaths()).not.toBe(null);\n      expect(excludePaths()).toBeDefined();\n      expect(excludePaths()).toBeInstanceOf(Array);\n      expect(excludePaths()).toEqual(['/health/liveness', '/health/readiness', '/info']);\n    });\n  });\n});\n",
              "err": {},
              "uuid": "50ce86c0-93fd-4b5e-9e4f-b660e6e4fa59",
              "parentUUID": "fef2c576-2dad-42e2-94b3-6609a1a5ea47",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "commons > without env context > should be return commons exclude paths without context",
              "title": "commons > without env context > should be return commons exclude paths without context",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { corePathsExcludes, excludePaths } from '../index';\nimport { RequestMethod } from '@nestjs/common';\n\ndescribe('commons', () => {\n  describe('with env context', () => {\n    beforeEach(() => {\n      process.env.CONTEXT = 'v1/api-test';\n    });\n\n    it('should be return commons exclude paths with context', () => {\n      expect(corePathsExcludes()).not.toBe(null);\n      expect(corePathsExcludes()).toBeDefined();\n      expect(corePathsExcludes()).toBeInstanceOf(Array);\n\n      expect(corePathsExcludes()).toContainObject({\n        path: `/v1/api-test/health/liveness`,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: `/v1/api-test/health/readiness`,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: `/v1/api-test/info`,\n        method: RequestMethod.GET,\n      });\n    });\n\n    it('should be return array of exclude paths with context', () => {\n      expect(excludePaths()).not.toBe(null);\n      expect(excludePaths()).toBeDefined();\n      expect(excludePaths()).toBeInstanceOf(Array);\n      expect(excludePaths()).toEqual([\n        `/v1/api-test/health/liveness`,\n        `/v1/api-test/health/readiness`,\n        `/v1/api-test/info`,\n      ]);\n    });\n  });\n\n  describe('without env context', () => {\n    beforeEach(() => {\n      process.env.CONTEXT = '';\n    });\n\n    it('should be return commons exclude paths without context', () => {\n      expect(corePathsExcludes()).not.toBe(null);\n      expect(corePathsExcludes()).toBeDefined();\n      expect(corePathsExcludes()).toBeInstanceOf(Array);\n\n      expect(corePathsExcludes()).toContainObject({\n        path: '/health/liveness',\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: '/health/readiness',\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: '/info',\n        method: RequestMethod.GET,\n      });\n    });\n\n    it('should be return array of exclude paths without context', () => {\n      expect(excludePaths()).not.toBe(null);\n      expect(excludePaths()).toBeDefined();\n      expect(excludePaths()).toBeInstanceOf(Array);\n      expect(excludePaths()).toEqual(['/health/liveness', '/health/readiness', '/info']);\n    });\n  });\n});\n",
              "err": {},
              "uuid": "ae75257c-1768-4b33-8cb2-834ff2d0edea",
              "parentUUID": "fef2c576-2dad-42e2-94b3-6609a1a5ea47",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "commons > without env context > should be return array of exclude paths without context",
              "title": "commons > without env context > should be return array of exclude paths without context",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { corePathsExcludes, excludePaths } from '../index';\nimport { RequestMethod } from '@nestjs/common';\n\ndescribe('commons', () => {\n  describe('with env context', () => {\n    beforeEach(() => {\n      process.env.CONTEXT = 'v1/api-test';\n    });\n\n    it('should be return commons exclude paths with context', () => {\n      expect(corePathsExcludes()).not.toBe(null);\n      expect(corePathsExcludes()).toBeDefined();\n      expect(corePathsExcludes()).toBeInstanceOf(Array);\n\n      expect(corePathsExcludes()).toContainObject({\n        path: `/v1/api-test/health/liveness`,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: `/v1/api-test/health/readiness`,\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: `/v1/api-test/info`,\n        method: RequestMethod.GET,\n      });\n    });\n\n    it('should be return array of exclude paths with context', () => {\n      expect(excludePaths()).not.toBe(null);\n      expect(excludePaths()).toBeDefined();\n      expect(excludePaths()).toBeInstanceOf(Array);\n      expect(excludePaths()).toEqual([\n        `/v1/api-test/health/liveness`,\n        `/v1/api-test/health/readiness`,\n        `/v1/api-test/info`,\n      ]);\n    });\n  });\n\n  describe('without env context', () => {\n    beforeEach(() => {\n      process.env.CONTEXT = '';\n    });\n\n    it('should be return commons exclude paths without context', () => {\n      expect(corePathsExcludes()).not.toBe(null);\n      expect(corePathsExcludes()).toBeDefined();\n      expect(corePathsExcludes()).toBeInstanceOf(Array);\n\n      expect(corePathsExcludes()).toContainObject({\n        path: '/health/liveness',\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: '/health/readiness',\n        method: RequestMethod.GET,\n      });\n\n      expect(corePathsExcludes()).toContainObject({\n        path: '/info',\n        method: RequestMethod.GET,\n      });\n    });\n\n    it('should be return array of exclude paths without context', () => {\n      expect(excludePaths()).not.toBe(null);\n      expect(excludePaths()).toBeDefined();\n      expect(excludePaths()).toBeInstanceOf(Array);\n      expect(excludePaths()).toEqual(['/health/liveness', '/health/readiness', '/info']);\n    });\n  });\n});\n",
              "err": {},
              "uuid": "4abe6383-1f72-498a-8448-8a9190a1f0e7",
              "parentUUID": "fef2c576-2dad-42e2-94b3-6609a1a5ea47",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "Public decorator > should be defined",
              "title": "Public decorator > should be defined",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Roles, ROLES_KEY } from '../index';\n\ndescribe('Public decorator', () => {\n  it('should be defined', async () => {\n    expect(Roles('admin')).toBeDefined();\n    expect(Roles('admin', 'user')).toBeDefined();\n  });\n\n  it('should be return key', async () => {\n    expect(ROLES_KEY).toBe('roles');\n  });\n});\n",
              "err": {},
              "uuid": "7a0f4151-ecc7-4cf7-8b32-bd9b87eca063",
              "parentUUID": "fef2c576-2dad-42e2-94b3-6609a1a5ea47",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "Public decorator > should be return key",
              "title": "Public decorator > should be return key",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Roles, ROLES_KEY } from '../index';\n\ndescribe('Public decorator', () => {\n  it('should be defined', async () => {\n    expect(Roles('admin')).toBeDefined();\n    expect(Roles('admin', 'user')).toBeDefined();\n  });\n\n  it('should be return key', async () => {\n    expect(ROLES_KEY).toBe('roles');\n  });\n});\n",
              "err": {},
              "uuid": "4b90b66a-df5b-48b8-957e-58a6949bc4b8",
              "parentUUID": "fef2c576-2dad-42e2-94b3-6609a1a5ea47",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "Public decorator > should be defined",
              "title": "Public decorator > should be defined",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Public, IS_PUBLIC_KEY } from '../index';\n\ndescribe('Public decorator', () => {\n  it('should be defined', async () => {\n    expect(Public()).toBeDefined();\n  });\n\n  it('should be return key', async () => {\n    expect(IS_PUBLIC_KEY).toBe('isPublic');\n  });\n});\n",
              "err": {},
              "uuid": "ad1c44ad-7412-4267-b3c7-c15ff8f2cbc3",
              "parentUUID": "fef2c576-2dad-42e2-94b3-6609a1a5ea47",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "Public decorator > should be return key",
              "title": "Public decorator > should be return key",
              "timedOut": false,
              "duration": 0,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Public, IS_PUBLIC_KEY } from '../index';\n\ndescribe('Public decorator', () => {\n  it('should be defined', async () => {\n    expect(Public()).toBeDefined();\n  });\n\n  it('should be return key', async () => {\n    expect(IS_PUBLIC_KEY).toBe('isPublic');\n  });\n});\n",
              "err": {},
              "uuid": "949edea5-1ced-4839-891b-aeac31ae36b7",
              "parentUUID": "fef2c576-2dad-42e2-94b3-6609a1a5ea47",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "https-certificate > should be return https certificate config",
              "title": "https-certificate > should be return https certificate config",
              "timedOut": false,
              "duration": 3,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { setHttpsOptions } from '../index';\nimport * as path from 'path';\ndescribe('https-certificate', () => {\n  it('should be return https certificate config', () => {\n    const crtPath = path.resolve(__dirname, './utils/localhost.crt');\n    const keyPath = path.resolve(__dirname, './utils/localhost.key');\n\n    const config = setHttpsOptions(crtPath, keyPath);\n    expect(typeof config).toBe('object');\n    expect(config).toBeDefined();\n    expect(config.cert).not.toEqual('');\n    expect(config.key).not.toEqual('');\n  });\n\n  it('should be return https certificate config empty', () => {\n    const crtPath = path.resolve(__dirname, './utils/my-localhost.crt');\n    const keyPath = path.resolve(__dirname, './utils/my-localhost.key');\n\n    const config = setHttpsOptions(crtPath, keyPath);\n    expect(typeof config).toBe('object');\n    expect(config).toBeDefined();\n    expect(config.cert).toEqual('');\n    expect(config.key).toEqual('');\n  });\n});\n",
              "err": {},
              "uuid": "9e7033d8-59fe-40fb-98eb-44b076262584",
              "parentUUID": "fef2c576-2dad-42e2-94b3-6609a1a5ea47",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "https-certificate > should be return https certificate config empty",
              "title": "https-certificate > should be return https certificate config empty",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { setHttpsOptions } from '../index';\nimport * as path from 'path';\ndescribe('https-certificate', () => {\n  it('should be return https certificate config', () => {\n    const crtPath = path.resolve(__dirname, './utils/localhost.crt');\n    const keyPath = path.resolve(__dirname, './utils/localhost.key');\n\n    const config = setHttpsOptions(crtPath, keyPath);\n    expect(typeof config).toBe('object');\n    expect(config).toBeDefined();\n    expect(config.cert).not.toEqual('');\n    expect(config.key).not.toEqual('');\n  });\n\n  it('should be return https certificate config empty', () => {\n    const crtPath = path.resolve(__dirname, './utils/my-localhost.crt');\n    const keyPath = path.resolve(__dirname, './utils/my-localhost.key');\n\n    const config = setHttpsOptions(crtPath, keyPath);\n    expect(typeof config).toBe('object');\n    expect(config).toBeDefined();\n    expect(config.cert).toEqual('');\n    expect(config.key).toEqual('');\n  });\n});\n",
              "err": {},
              "uuid": "bbb4123e-e315-4e2f-b1e2-1694c5440f11",
              "parentUUID": "fef2c576-2dad-42e2-94b3-6609a1a5ea47",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "6daa302e-8e35-4483-8363-a6a8a03eeab2",
            "50ce86c0-93fd-4b5e-9e4f-b660e6e4fa59",
            "ae75257c-1768-4b33-8cb2-834ff2d0edea",
            "4abe6383-1f72-498a-8448-8a9190a1f0e7",
            "7a0f4151-ecc7-4cf7-8b32-bd9b87eca063",
            "4b90b66a-df5b-48b8-957e-58a6949bc4b8",
            "ad1c44ad-7412-4267-b3c7-c15ff8f2cbc3",
            "949edea5-1ced-4839-891b-aeac31ae36b7",
            "9e7033d8-59fe-40fb-98eb-44b076262584",
            "bbb4123e-e315-4e2f-b1e2-1694c5440f11"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 16,
          "root": false,
          "rootEmpty": false,
          "_timeout": 5000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 5000
    },
    {
      "uuid": "6825bf87-3a9b-40e7-a2c5-d7c55a170c94",
      "title": "@tresdoce-nestjs-toolkit/elk",
      "fullFile": "",
      "file": "",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "75f69b88-729b-4c0f-b415-5d527cb20391",
          "title": "@tresdoce-nestjs-toolkit/elk",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "fullTitle": "ElkModule > should be defined",
              "title": "ElkModule > should be defined",
              "timedOut": false,
              "duration": 1353,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { HttpException, INestApplication } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport {\n  dynamicConfig,\n  fixtureUserResponse,\n  TCElasticSearchOptions,\n  tcName,\n  testContainers,\n} from '@tresdoce-nestjs-toolkit/test-utils';\nimport { Observable, of, throwError } from 'rxjs';\nimport { HttpConnection } from '@elastic/elasticsearch';\nimport { URL } from 'url';\n\nimport { ElkModule } from '../elk/elk.module';\nimport { ElkInterceptor } from '../elk/interceptors/elk.interceptor';\nimport { ElkService } from '../elk/services/elk.service';\n\nlet executionContext: any = {\n  switchToHttp: jest.fn(() => ({\n    getRequest: () => ({\n      path: '/test',\n      method: 'GET',\n      params: {},\n      query: {},\n      body: {},\n      headers: {\n        'Content-Type': 'application/json',\n        apiKey: 'abcdefg12345',\n      },\n    }),\n    getResponse: () => ({\n      getHeaders: jest.fn().mockReturnValue({\n        'Content-Type': 'application/json',\n        my_header: 'test-header',\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() => 'http'),\n  getClass: jest.fn(() => 'testController'),\n  getHandler: jest.fn(() => 'handlerElk'),\n};\n\nlet executionContextParams: any = {\n  switchToHttp: jest.fn(() => ({\n    getRequest: () => ({\n      path: '/test',\n      method: 'GET',\n      params: { name: 'juan' },\n      query: { name: 'juan' },\n      body: { name: 'juan' },\n      headers: {\n        'Content-Type': 'application/json',\n        apiKey: 'abcdefg12345',\n      },\n    }),\n    getResponse: () => ({\n      getHeaders: jest.fn().mockReturnValue({\n        'Content-Type': 'application/json',\n        my_header: 'test-header',\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() => 'http'),\n  getClass: jest.fn(() => 'testController'),\n  getHandler: jest.fn(() => 'handlerElk'),\n};\n\n/*const callHandler: any = {\n  handle: jest.fn(() => ({\n    pipe: jest.fn(() => ({\n      tap: jest.fn(() => ({\n        next: jest.fn(),\n        error: jest.fn(),\n      })),\n    })),\n  })),\n};*/\n\njest.setTimeout(70000);\ndescribe('ElkModule', () => {\n  let app: INestApplication;\n  let elkService: ElkService;\n  let interceptor: ElkInterceptor<any>;\n  let container: testContainers;\n\n  beforeAll(async () => {\n    //'elasticsearch:8.3.3'\n    //docker.elastic.co/elasticsearch/elasticsearch:8.3.3\n\n    container = await new testContainers('elasticsearch:8.3.3', {\n      ...TCElasticSearchOptions,\n      containerName: `${tcName}-elasticsearch-interceptor`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () => {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () => {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              elasticsearch: {\n                name: 'test-elk-index',\n                node: {\n                  url: new URL(`http://${container.getHost()}:9200`),\n                },\n                maxRetries: 10,\n                requestTimeout: 60000,\n                sniffOnStart: true,\n                Connection: HttpConnection,\n              },\n            }),\n          ],\n        }),\n        ElkModule,\n      ],\n    }).compile();\n    app = moduleFixture.createNestApplication();\n    interceptor = new ElkInterceptor(app.get<ElkService>(ElkService));\n    app.useGlobalInterceptors(interceptor);\n    elkService = moduleFixture.get<ElkService>(ElkService);\n    await app.init();\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', () => {\n    expect(app).toBeDefined();\n  });\n\n  describe('ElkInterceptor', () => {\n    it('should be an ElkInterceptor instance to be defined', async () => {\n      expect(new ElkInterceptor(elkService)).toBeDefined();\n    });\n\n    it('should be create document in elasticsearch when return success string', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of('this is a test')),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return success object', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of([fixtureUserResponse])),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return success with parameters', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of([fixtureUserResponse])),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContextParams, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return exception', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const error = new Error(`User #$1 not found`);\n\n      const callHandler: any = {\n        handle: jest.fn(() => throwError(error)),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () => {},\n        error: (error) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n\n    it('should be create document in elasticsearch when return exception http', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const error = new HttpException('not found', 404);\n\n      const callHandler: any = {\n        handle: jest.fn(() => throwError(error)),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () => {},\n        error: (error) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n  });\n\n  describe('ElkModule - Register', () => {\n    let app: INestApplication;\n    let elkService: ElkService;\n    let interceptor: ElkInterceptor<any>;\n\n    beforeEach(async () => {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ElkModule.register({\n            name: 'test-elk-index',\n            node: {\n              url: new URL(`http://${container.getHost()}:9200`),\n            },\n            maxRetries: 10,\n            requestTimeout: 60000,\n            sniffOnStart: true,\n            Connection: HttpConnection,\n          }),\n        ],\n      }).compile();\n      app = moduleFixture.createNestApplication();\n      interceptor = new ElkInterceptor(app.get<ElkService>(ElkService));\n      app.useGlobalInterceptors(interceptor);\n      elkService = moduleFixture.get<ElkService>(ElkService);\n      await app.init();\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be defined', () => {\n      expect(app).toBeDefined();\n    });\n  });\n});\n",
              "err": {},
              "uuid": "8dc6dac1-0415-48e0-b158-3f2293573a9a",
              "parentUUID": "75f69b88-729b-4c0f-b415-5d527cb20391",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "ElkModule > ElkInterceptor > should be an ElkInterceptor instance to be defined",
              "title": "ElkModule > ElkInterceptor > should be an ElkInterceptor instance to be defined",
              "timedOut": false,
              "duration": 1009,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { HttpException, INestApplication } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport {\n  dynamicConfig,\n  fixtureUserResponse,\n  TCElasticSearchOptions,\n  tcName,\n  testContainers,\n} from '@tresdoce-nestjs-toolkit/test-utils';\nimport { Observable, of, throwError } from 'rxjs';\nimport { HttpConnection } from '@elastic/elasticsearch';\nimport { URL } from 'url';\n\nimport { ElkModule } from '../elk/elk.module';\nimport { ElkInterceptor } from '../elk/interceptors/elk.interceptor';\nimport { ElkService } from '../elk/services/elk.service';\n\nlet executionContext: any = {\n  switchToHttp: jest.fn(() => ({\n    getRequest: () => ({\n      path: '/test',\n      method: 'GET',\n      params: {},\n      query: {},\n      body: {},\n      headers: {\n        'Content-Type': 'application/json',\n        apiKey: 'abcdefg12345',\n      },\n    }),\n    getResponse: () => ({\n      getHeaders: jest.fn().mockReturnValue({\n        'Content-Type': 'application/json',\n        my_header: 'test-header',\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() => 'http'),\n  getClass: jest.fn(() => 'testController'),\n  getHandler: jest.fn(() => 'handlerElk'),\n};\n\nlet executionContextParams: any = {\n  switchToHttp: jest.fn(() => ({\n    getRequest: () => ({\n      path: '/test',\n      method: 'GET',\n      params: { name: 'juan' },\n      query: { name: 'juan' },\n      body: { name: 'juan' },\n      headers: {\n        'Content-Type': 'application/json',\n        apiKey: 'abcdefg12345',\n      },\n    }),\n    getResponse: () => ({\n      getHeaders: jest.fn().mockReturnValue({\n        'Content-Type': 'application/json',\n        my_header: 'test-header',\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() => 'http'),\n  getClass: jest.fn(() => 'testController'),\n  getHandler: jest.fn(() => 'handlerElk'),\n};\n\n/*const callHandler: any = {\n  handle: jest.fn(() => ({\n    pipe: jest.fn(() => ({\n      tap: jest.fn(() => ({\n        next: jest.fn(),\n        error: jest.fn(),\n      })),\n    })),\n  })),\n};*/\n\njest.setTimeout(70000);\ndescribe('ElkModule', () => {\n  let app: INestApplication;\n  let elkService: ElkService;\n  let interceptor: ElkInterceptor<any>;\n  let container: testContainers;\n\n  beforeAll(async () => {\n    //'elasticsearch:8.3.3'\n    //docker.elastic.co/elasticsearch/elasticsearch:8.3.3\n\n    container = await new testContainers('elasticsearch:8.3.3', {\n      ...TCElasticSearchOptions,\n      containerName: `${tcName}-elasticsearch-interceptor`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () => {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () => {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              elasticsearch: {\n                name: 'test-elk-index',\n                node: {\n                  url: new URL(`http://${container.getHost()}:9200`),\n                },\n                maxRetries: 10,\n                requestTimeout: 60000,\n                sniffOnStart: true,\n                Connection: HttpConnection,\n              },\n            }),\n          ],\n        }),\n        ElkModule,\n      ],\n    }).compile();\n    app = moduleFixture.createNestApplication();\n    interceptor = new ElkInterceptor(app.get<ElkService>(ElkService));\n    app.useGlobalInterceptors(interceptor);\n    elkService = moduleFixture.get<ElkService>(ElkService);\n    await app.init();\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', () => {\n    expect(app).toBeDefined();\n  });\n\n  describe('ElkInterceptor', () => {\n    it('should be an ElkInterceptor instance to be defined', async () => {\n      expect(new ElkInterceptor(elkService)).toBeDefined();\n    });\n\n    it('should be create document in elasticsearch when return success string', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of('this is a test')),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return success object', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of([fixtureUserResponse])),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return success with parameters', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of([fixtureUserResponse])),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContextParams, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return exception', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const error = new Error(`User #$1 not found`);\n\n      const callHandler: any = {\n        handle: jest.fn(() => throwError(error)),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () => {},\n        error: (error) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n\n    it('should be create document in elasticsearch when return exception http', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const error = new HttpException('not found', 404);\n\n      const callHandler: any = {\n        handle: jest.fn(() => throwError(error)),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () => {},\n        error: (error) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n  });\n\n  describe('ElkModule - Register', () => {\n    let app: INestApplication;\n    let elkService: ElkService;\n    let interceptor: ElkInterceptor<any>;\n\n    beforeEach(async () => {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ElkModule.register({\n            name: 'test-elk-index',\n            node: {\n              url: new URL(`http://${container.getHost()}:9200`),\n            },\n            maxRetries: 10,\n            requestTimeout: 60000,\n            sniffOnStart: true,\n            Connection: HttpConnection,\n          }),\n        ],\n      }).compile();\n      app = moduleFixture.createNestApplication();\n      interceptor = new ElkInterceptor(app.get<ElkService>(ElkService));\n      app.useGlobalInterceptors(interceptor);\n      elkService = moduleFixture.get<ElkService>(ElkService);\n      await app.init();\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be defined', () => {\n      expect(app).toBeDefined();\n    });\n  });\n});\n",
              "err": {},
              "uuid": "35994cbb-1ced-492b-acec-73db2b57cc1b",
              "parentUUID": "75f69b88-729b-4c0f-b415-5d527cb20391",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "ElkModule > ElkInterceptor > should be create document in elasticsearch when return success string",
              "title": "ElkModule > ElkInterceptor > should be create document in elasticsearch when return success string",
              "timedOut": false,
              "duration": 1018,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { HttpException, INestApplication } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport {\n  dynamicConfig,\n  fixtureUserResponse,\n  TCElasticSearchOptions,\n  tcName,\n  testContainers,\n} from '@tresdoce-nestjs-toolkit/test-utils';\nimport { Observable, of, throwError } from 'rxjs';\nimport { HttpConnection } from '@elastic/elasticsearch';\nimport { URL } from 'url';\n\nimport { ElkModule } from '../elk/elk.module';\nimport { ElkInterceptor } from '../elk/interceptors/elk.interceptor';\nimport { ElkService } from '../elk/services/elk.service';\n\nlet executionContext: any = {\n  switchToHttp: jest.fn(() => ({\n    getRequest: () => ({\n      path: '/test',\n      method: 'GET',\n      params: {},\n      query: {},\n      body: {},\n      headers: {\n        'Content-Type': 'application/json',\n        apiKey: 'abcdefg12345',\n      },\n    }),\n    getResponse: () => ({\n      getHeaders: jest.fn().mockReturnValue({\n        'Content-Type': 'application/json',\n        my_header: 'test-header',\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() => 'http'),\n  getClass: jest.fn(() => 'testController'),\n  getHandler: jest.fn(() => 'handlerElk'),\n};\n\nlet executionContextParams: any = {\n  switchToHttp: jest.fn(() => ({\n    getRequest: () => ({\n      path: '/test',\n      method: 'GET',\n      params: { name: 'juan' },\n      query: { name: 'juan' },\n      body: { name: 'juan' },\n      headers: {\n        'Content-Type': 'application/json',\n        apiKey: 'abcdefg12345',\n      },\n    }),\n    getResponse: () => ({\n      getHeaders: jest.fn().mockReturnValue({\n        'Content-Type': 'application/json',\n        my_header: 'test-header',\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() => 'http'),\n  getClass: jest.fn(() => 'testController'),\n  getHandler: jest.fn(() => 'handlerElk'),\n};\n\n/*const callHandler: any = {\n  handle: jest.fn(() => ({\n    pipe: jest.fn(() => ({\n      tap: jest.fn(() => ({\n        next: jest.fn(),\n        error: jest.fn(),\n      })),\n    })),\n  })),\n};*/\n\njest.setTimeout(70000);\ndescribe('ElkModule', () => {\n  let app: INestApplication;\n  let elkService: ElkService;\n  let interceptor: ElkInterceptor<any>;\n  let container: testContainers;\n\n  beforeAll(async () => {\n    //'elasticsearch:8.3.3'\n    //docker.elastic.co/elasticsearch/elasticsearch:8.3.3\n\n    container = await new testContainers('elasticsearch:8.3.3', {\n      ...TCElasticSearchOptions,\n      containerName: `${tcName}-elasticsearch-interceptor`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () => {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () => {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              elasticsearch: {\n                name: 'test-elk-index',\n                node: {\n                  url: new URL(`http://${container.getHost()}:9200`),\n                },\n                maxRetries: 10,\n                requestTimeout: 60000,\n                sniffOnStart: true,\n                Connection: HttpConnection,\n              },\n            }),\n          ],\n        }),\n        ElkModule,\n      ],\n    }).compile();\n    app = moduleFixture.createNestApplication();\n    interceptor = new ElkInterceptor(app.get<ElkService>(ElkService));\n    app.useGlobalInterceptors(interceptor);\n    elkService = moduleFixture.get<ElkService>(ElkService);\n    await app.init();\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', () => {\n    expect(app).toBeDefined();\n  });\n\n  describe('ElkInterceptor', () => {\n    it('should be an ElkInterceptor instance to be defined', async () => {\n      expect(new ElkInterceptor(elkService)).toBeDefined();\n    });\n\n    it('should be create document in elasticsearch when return success string', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of('this is a test')),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return success object', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of([fixtureUserResponse])),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return success with parameters', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of([fixtureUserResponse])),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContextParams, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return exception', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const error = new Error(`User #$1 not found`);\n\n      const callHandler: any = {\n        handle: jest.fn(() => throwError(error)),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () => {},\n        error: (error) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n\n    it('should be create document in elasticsearch when return exception http', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const error = new HttpException('not found', 404);\n\n      const callHandler: any = {\n        handle: jest.fn(() => throwError(error)),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () => {},\n        error: (error) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n  });\n\n  describe('ElkModule - Register', () => {\n    let app: INestApplication;\n    let elkService: ElkService;\n    let interceptor: ElkInterceptor<any>;\n\n    beforeEach(async () => {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ElkModule.register({\n            name: 'test-elk-index',\n            node: {\n              url: new URL(`http://${container.getHost()}:9200`),\n            },\n            maxRetries: 10,\n            requestTimeout: 60000,\n            sniffOnStart: true,\n            Connection: HttpConnection,\n          }),\n        ],\n      }).compile();\n      app = moduleFixture.createNestApplication();\n      interceptor = new ElkInterceptor(app.get<ElkService>(ElkService));\n      app.useGlobalInterceptors(interceptor);\n      elkService = moduleFixture.get<ElkService>(ElkService);\n      await app.init();\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be defined', () => {\n      expect(app).toBeDefined();\n    });\n  });\n});\n",
              "err": {},
              "uuid": "c681ce2b-0d0b-492f-9b1c-f8c18c89a411",
              "parentUUID": "75f69b88-729b-4c0f-b415-5d527cb20391",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "ElkModule > ElkInterceptor > should be create document in elasticsearch when return success object",
              "title": "ElkModule > ElkInterceptor > should be create document in elasticsearch when return success object",
              "timedOut": false,
              "duration": 1011,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { HttpException, INestApplication } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport {\n  dynamicConfig,\n  fixtureUserResponse,\n  TCElasticSearchOptions,\n  tcName,\n  testContainers,\n} from '@tresdoce-nestjs-toolkit/test-utils';\nimport { Observable, of, throwError } from 'rxjs';\nimport { HttpConnection } from '@elastic/elasticsearch';\nimport { URL } from 'url';\n\nimport { ElkModule } from '../elk/elk.module';\nimport { ElkInterceptor } from '../elk/interceptors/elk.interceptor';\nimport { ElkService } from '../elk/services/elk.service';\n\nlet executionContext: any = {\n  switchToHttp: jest.fn(() => ({\n    getRequest: () => ({\n      path: '/test',\n      method: 'GET',\n      params: {},\n      query: {},\n      body: {},\n      headers: {\n        'Content-Type': 'application/json',\n        apiKey: 'abcdefg12345',\n      },\n    }),\n    getResponse: () => ({\n      getHeaders: jest.fn().mockReturnValue({\n        'Content-Type': 'application/json',\n        my_header: 'test-header',\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() => 'http'),\n  getClass: jest.fn(() => 'testController'),\n  getHandler: jest.fn(() => 'handlerElk'),\n};\n\nlet executionContextParams: any = {\n  switchToHttp: jest.fn(() => ({\n    getRequest: () => ({\n      path: '/test',\n      method: 'GET',\n      params: { name: 'juan' },\n      query: { name: 'juan' },\n      body: { name: 'juan' },\n      headers: {\n        'Content-Type': 'application/json',\n        apiKey: 'abcdefg12345',\n      },\n    }),\n    getResponse: () => ({\n      getHeaders: jest.fn().mockReturnValue({\n        'Content-Type': 'application/json',\n        my_header: 'test-header',\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() => 'http'),\n  getClass: jest.fn(() => 'testController'),\n  getHandler: jest.fn(() => 'handlerElk'),\n};\n\n/*const callHandler: any = {\n  handle: jest.fn(() => ({\n    pipe: jest.fn(() => ({\n      tap: jest.fn(() => ({\n        next: jest.fn(),\n        error: jest.fn(),\n      })),\n    })),\n  })),\n};*/\n\njest.setTimeout(70000);\ndescribe('ElkModule', () => {\n  let app: INestApplication;\n  let elkService: ElkService;\n  let interceptor: ElkInterceptor<any>;\n  let container: testContainers;\n\n  beforeAll(async () => {\n    //'elasticsearch:8.3.3'\n    //docker.elastic.co/elasticsearch/elasticsearch:8.3.3\n\n    container = await new testContainers('elasticsearch:8.3.3', {\n      ...TCElasticSearchOptions,\n      containerName: `${tcName}-elasticsearch-interceptor`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () => {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () => {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              elasticsearch: {\n                name: 'test-elk-index',\n                node: {\n                  url: new URL(`http://${container.getHost()}:9200`),\n                },\n                maxRetries: 10,\n                requestTimeout: 60000,\n                sniffOnStart: true,\n                Connection: HttpConnection,\n              },\n            }),\n          ],\n        }),\n        ElkModule,\n      ],\n    }).compile();\n    app = moduleFixture.createNestApplication();\n    interceptor = new ElkInterceptor(app.get<ElkService>(ElkService));\n    app.useGlobalInterceptors(interceptor);\n    elkService = moduleFixture.get<ElkService>(ElkService);\n    await app.init();\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', () => {\n    expect(app).toBeDefined();\n  });\n\n  describe('ElkInterceptor', () => {\n    it('should be an ElkInterceptor instance to be defined', async () => {\n      expect(new ElkInterceptor(elkService)).toBeDefined();\n    });\n\n    it('should be create document in elasticsearch when return success string', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of('this is a test')),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return success object', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of([fixtureUserResponse])),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return success with parameters', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of([fixtureUserResponse])),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContextParams, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return exception', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const error = new Error(`User #$1 not found`);\n\n      const callHandler: any = {\n        handle: jest.fn(() => throwError(error)),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () => {},\n        error: (error) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n\n    it('should be create document in elasticsearch when return exception http', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const error = new HttpException('not found', 404);\n\n      const callHandler: any = {\n        handle: jest.fn(() => throwError(error)),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () => {},\n        error: (error) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n  });\n\n  describe('ElkModule - Register', () => {\n    let app: INestApplication;\n    let elkService: ElkService;\n    let interceptor: ElkInterceptor<any>;\n\n    beforeEach(async () => {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ElkModule.register({\n            name: 'test-elk-index',\n            node: {\n              url: new URL(`http://${container.getHost()}:9200`),\n            },\n            maxRetries: 10,\n            requestTimeout: 60000,\n            sniffOnStart: true,\n            Connection: HttpConnection,\n          }),\n        ],\n      }).compile();\n      app = moduleFixture.createNestApplication();\n      interceptor = new ElkInterceptor(app.get<ElkService>(ElkService));\n      app.useGlobalInterceptors(interceptor);\n      elkService = moduleFixture.get<ElkService>(ElkService);\n      await app.init();\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be defined', () => {\n      expect(app).toBeDefined();\n    });\n  });\n});\n",
              "err": {},
              "uuid": "491352ef-7f86-49af-b237-627f3b1dea8c",
              "parentUUID": "75f69b88-729b-4c0f-b415-5d527cb20391",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "ElkModule > ElkInterceptor > should be create document in elasticsearch when return success with parameters",
              "title": "ElkModule > ElkInterceptor > should be create document in elasticsearch when return success with parameters",
              "timedOut": false,
              "duration": 1010,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { HttpException, INestApplication } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport {\n  dynamicConfig,\n  fixtureUserResponse,\n  TCElasticSearchOptions,\n  tcName,\n  testContainers,\n} from '@tresdoce-nestjs-toolkit/test-utils';\nimport { Observable, of, throwError } from 'rxjs';\nimport { HttpConnection } from '@elastic/elasticsearch';\nimport { URL } from 'url';\n\nimport { ElkModule } from '../elk/elk.module';\nimport { ElkInterceptor } from '../elk/interceptors/elk.interceptor';\nimport { ElkService } from '../elk/services/elk.service';\n\nlet executionContext: any = {\n  switchToHttp: jest.fn(() => ({\n    getRequest: () => ({\n      path: '/test',\n      method: 'GET',\n      params: {},\n      query: {},\n      body: {},\n      headers: {\n        'Content-Type': 'application/json',\n        apiKey: 'abcdefg12345',\n      },\n    }),\n    getResponse: () => ({\n      getHeaders: jest.fn().mockReturnValue({\n        'Content-Type': 'application/json',\n        my_header: 'test-header',\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() => 'http'),\n  getClass: jest.fn(() => 'testController'),\n  getHandler: jest.fn(() => 'handlerElk'),\n};\n\nlet executionContextParams: any = {\n  switchToHttp: jest.fn(() => ({\n    getRequest: () => ({\n      path: '/test',\n      method: 'GET',\n      params: { name: 'juan' },\n      query: { name: 'juan' },\n      body: { name: 'juan' },\n      headers: {\n        'Content-Type': 'application/json',\n        apiKey: 'abcdefg12345',\n      },\n    }),\n    getResponse: () => ({\n      getHeaders: jest.fn().mockReturnValue({\n        'Content-Type': 'application/json',\n        my_header: 'test-header',\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() => 'http'),\n  getClass: jest.fn(() => 'testController'),\n  getHandler: jest.fn(() => 'handlerElk'),\n};\n\n/*const callHandler: any = {\n  handle: jest.fn(() => ({\n    pipe: jest.fn(() => ({\n      tap: jest.fn(() => ({\n        next: jest.fn(),\n        error: jest.fn(),\n      })),\n    })),\n  })),\n};*/\n\njest.setTimeout(70000);\ndescribe('ElkModule', () => {\n  let app: INestApplication;\n  let elkService: ElkService;\n  let interceptor: ElkInterceptor<any>;\n  let container: testContainers;\n\n  beforeAll(async () => {\n    //'elasticsearch:8.3.3'\n    //docker.elastic.co/elasticsearch/elasticsearch:8.3.3\n\n    container = await new testContainers('elasticsearch:8.3.3', {\n      ...TCElasticSearchOptions,\n      containerName: `${tcName}-elasticsearch-interceptor`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () => {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () => {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              elasticsearch: {\n                name: 'test-elk-index',\n                node: {\n                  url: new URL(`http://${container.getHost()}:9200`),\n                },\n                maxRetries: 10,\n                requestTimeout: 60000,\n                sniffOnStart: true,\n                Connection: HttpConnection,\n              },\n            }),\n          ],\n        }),\n        ElkModule,\n      ],\n    }).compile();\n    app = moduleFixture.createNestApplication();\n    interceptor = new ElkInterceptor(app.get<ElkService>(ElkService));\n    app.useGlobalInterceptors(interceptor);\n    elkService = moduleFixture.get<ElkService>(ElkService);\n    await app.init();\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', () => {\n    expect(app).toBeDefined();\n  });\n\n  describe('ElkInterceptor', () => {\n    it('should be an ElkInterceptor instance to be defined', async () => {\n      expect(new ElkInterceptor(elkService)).toBeDefined();\n    });\n\n    it('should be create document in elasticsearch when return success string', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of('this is a test')),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return success object', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of([fixtureUserResponse])),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return success with parameters', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of([fixtureUserResponse])),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContextParams, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return exception', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const error = new Error(`User #$1 not found`);\n\n      const callHandler: any = {\n        handle: jest.fn(() => throwError(error)),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () => {},\n        error: (error) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n\n    it('should be create document in elasticsearch when return exception http', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const error = new HttpException('not found', 404);\n\n      const callHandler: any = {\n        handle: jest.fn(() => throwError(error)),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () => {},\n        error: (error) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n  });\n\n  describe('ElkModule - Register', () => {\n    let app: INestApplication;\n    let elkService: ElkService;\n    let interceptor: ElkInterceptor<any>;\n\n    beforeEach(async () => {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ElkModule.register({\n            name: 'test-elk-index',\n            node: {\n              url: new URL(`http://${container.getHost()}:9200`),\n            },\n            maxRetries: 10,\n            requestTimeout: 60000,\n            sniffOnStart: true,\n            Connection: HttpConnection,\n          }),\n        ],\n      }).compile();\n      app = moduleFixture.createNestApplication();\n      interceptor = new ElkInterceptor(app.get<ElkService>(ElkService));\n      app.useGlobalInterceptors(interceptor);\n      elkService = moduleFixture.get<ElkService>(ElkService);\n      await app.init();\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be defined', () => {\n      expect(app).toBeDefined();\n    });\n  });\n});\n",
              "err": {},
              "uuid": "6797888f-7622-40e8-9f07-046b874f810b",
              "parentUUID": "75f69b88-729b-4c0f-b415-5d527cb20391",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "ElkModule > ElkInterceptor > should be create document in elasticsearch when return exception",
              "title": "ElkModule > ElkInterceptor > should be create document in elasticsearch when return exception",
              "timedOut": false,
              "duration": 1010,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { HttpException, INestApplication } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport {\n  dynamicConfig,\n  fixtureUserResponse,\n  TCElasticSearchOptions,\n  tcName,\n  testContainers,\n} from '@tresdoce-nestjs-toolkit/test-utils';\nimport { Observable, of, throwError } from 'rxjs';\nimport { HttpConnection } from '@elastic/elasticsearch';\nimport { URL } from 'url';\n\nimport { ElkModule } from '../elk/elk.module';\nimport { ElkInterceptor } from '../elk/interceptors/elk.interceptor';\nimport { ElkService } from '../elk/services/elk.service';\n\nlet executionContext: any = {\n  switchToHttp: jest.fn(() => ({\n    getRequest: () => ({\n      path: '/test',\n      method: 'GET',\n      params: {},\n      query: {},\n      body: {},\n      headers: {\n        'Content-Type': 'application/json',\n        apiKey: 'abcdefg12345',\n      },\n    }),\n    getResponse: () => ({\n      getHeaders: jest.fn().mockReturnValue({\n        'Content-Type': 'application/json',\n        my_header: 'test-header',\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() => 'http'),\n  getClass: jest.fn(() => 'testController'),\n  getHandler: jest.fn(() => 'handlerElk'),\n};\n\nlet executionContextParams: any = {\n  switchToHttp: jest.fn(() => ({\n    getRequest: () => ({\n      path: '/test',\n      method: 'GET',\n      params: { name: 'juan' },\n      query: { name: 'juan' },\n      body: { name: 'juan' },\n      headers: {\n        'Content-Type': 'application/json',\n        apiKey: 'abcdefg12345',\n      },\n    }),\n    getResponse: () => ({\n      getHeaders: jest.fn().mockReturnValue({\n        'Content-Type': 'application/json',\n        my_header: 'test-header',\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() => 'http'),\n  getClass: jest.fn(() => 'testController'),\n  getHandler: jest.fn(() => 'handlerElk'),\n};\n\n/*const callHandler: any = {\n  handle: jest.fn(() => ({\n    pipe: jest.fn(() => ({\n      tap: jest.fn(() => ({\n        next: jest.fn(),\n        error: jest.fn(),\n      })),\n    })),\n  })),\n};*/\n\njest.setTimeout(70000);\ndescribe('ElkModule', () => {\n  let app: INestApplication;\n  let elkService: ElkService;\n  let interceptor: ElkInterceptor<any>;\n  let container: testContainers;\n\n  beforeAll(async () => {\n    //'elasticsearch:8.3.3'\n    //docker.elastic.co/elasticsearch/elasticsearch:8.3.3\n\n    container = await new testContainers('elasticsearch:8.3.3', {\n      ...TCElasticSearchOptions,\n      containerName: `${tcName}-elasticsearch-interceptor`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () => {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () => {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              elasticsearch: {\n                name: 'test-elk-index',\n                node: {\n                  url: new URL(`http://${container.getHost()}:9200`),\n                },\n                maxRetries: 10,\n                requestTimeout: 60000,\n                sniffOnStart: true,\n                Connection: HttpConnection,\n              },\n            }),\n          ],\n        }),\n        ElkModule,\n      ],\n    }).compile();\n    app = moduleFixture.createNestApplication();\n    interceptor = new ElkInterceptor(app.get<ElkService>(ElkService));\n    app.useGlobalInterceptors(interceptor);\n    elkService = moduleFixture.get<ElkService>(ElkService);\n    await app.init();\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', () => {\n    expect(app).toBeDefined();\n  });\n\n  describe('ElkInterceptor', () => {\n    it('should be an ElkInterceptor instance to be defined', async () => {\n      expect(new ElkInterceptor(elkService)).toBeDefined();\n    });\n\n    it('should be create document in elasticsearch when return success string', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of('this is a test')),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return success object', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of([fixtureUserResponse])),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return success with parameters', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of([fixtureUserResponse])),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContextParams, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return exception', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const error = new Error(`User #$1 not found`);\n\n      const callHandler: any = {\n        handle: jest.fn(() => throwError(error)),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () => {},\n        error: (error) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n\n    it('should be create document in elasticsearch when return exception http', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const error = new HttpException('not found', 404);\n\n      const callHandler: any = {\n        handle: jest.fn(() => throwError(error)),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () => {},\n        error: (error) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n  });\n\n  describe('ElkModule - Register', () => {\n    let app: INestApplication;\n    let elkService: ElkService;\n    let interceptor: ElkInterceptor<any>;\n\n    beforeEach(async () => {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ElkModule.register({\n            name: 'test-elk-index',\n            node: {\n              url: new URL(`http://${container.getHost()}:9200`),\n            },\n            maxRetries: 10,\n            requestTimeout: 60000,\n            sniffOnStart: true,\n            Connection: HttpConnection,\n          }),\n        ],\n      }).compile();\n      app = moduleFixture.createNestApplication();\n      interceptor = new ElkInterceptor(app.get<ElkService>(ElkService));\n      app.useGlobalInterceptors(interceptor);\n      elkService = moduleFixture.get<ElkService>(ElkService);\n      await app.init();\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be defined', () => {\n      expect(app).toBeDefined();\n    });\n  });\n});\n",
              "err": {},
              "uuid": "362bf64a-49fe-482b-b083-82cff019d127",
              "parentUUID": "75f69b88-729b-4c0f-b415-5d527cb20391",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "ElkModule > ElkInterceptor > should be create document in elasticsearch when return exception http",
              "title": "ElkModule > ElkInterceptor > should be create document in elasticsearch when return exception http",
              "timedOut": false,
              "duration": 1008,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { HttpException, INestApplication } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport {\n  dynamicConfig,\n  fixtureUserResponse,\n  TCElasticSearchOptions,\n  tcName,\n  testContainers,\n} from '@tresdoce-nestjs-toolkit/test-utils';\nimport { Observable, of, throwError } from 'rxjs';\nimport { HttpConnection } from '@elastic/elasticsearch';\nimport { URL } from 'url';\n\nimport { ElkModule } from '../elk/elk.module';\nimport { ElkInterceptor } from '../elk/interceptors/elk.interceptor';\nimport { ElkService } from '../elk/services/elk.service';\n\nlet executionContext: any = {\n  switchToHttp: jest.fn(() => ({\n    getRequest: () => ({\n      path: '/test',\n      method: 'GET',\n      params: {},\n      query: {},\n      body: {},\n      headers: {\n        'Content-Type': 'application/json',\n        apiKey: 'abcdefg12345',\n      },\n    }),\n    getResponse: () => ({\n      getHeaders: jest.fn().mockReturnValue({\n        'Content-Type': 'application/json',\n        my_header: 'test-header',\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() => 'http'),\n  getClass: jest.fn(() => 'testController'),\n  getHandler: jest.fn(() => 'handlerElk'),\n};\n\nlet executionContextParams: any = {\n  switchToHttp: jest.fn(() => ({\n    getRequest: () => ({\n      path: '/test',\n      method: 'GET',\n      params: { name: 'juan' },\n      query: { name: 'juan' },\n      body: { name: 'juan' },\n      headers: {\n        'Content-Type': 'application/json',\n        apiKey: 'abcdefg12345',\n      },\n    }),\n    getResponse: () => ({\n      getHeaders: jest.fn().mockReturnValue({\n        'Content-Type': 'application/json',\n        my_header: 'test-header',\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() => 'http'),\n  getClass: jest.fn(() => 'testController'),\n  getHandler: jest.fn(() => 'handlerElk'),\n};\n\n/*const callHandler: any = {\n  handle: jest.fn(() => ({\n    pipe: jest.fn(() => ({\n      tap: jest.fn(() => ({\n        next: jest.fn(),\n        error: jest.fn(),\n      })),\n    })),\n  })),\n};*/\n\njest.setTimeout(70000);\ndescribe('ElkModule', () => {\n  let app: INestApplication;\n  let elkService: ElkService;\n  let interceptor: ElkInterceptor<any>;\n  let container: testContainers;\n\n  beforeAll(async () => {\n    //'elasticsearch:8.3.3'\n    //docker.elastic.co/elasticsearch/elasticsearch:8.3.3\n\n    container = await new testContainers('elasticsearch:8.3.3', {\n      ...TCElasticSearchOptions,\n      containerName: `${tcName}-elasticsearch-interceptor`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () => {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () => {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              elasticsearch: {\n                name: 'test-elk-index',\n                node: {\n                  url: new URL(`http://${container.getHost()}:9200`),\n                },\n                maxRetries: 10,\n                requestTimeout: 60000,\n                sniffOnStart: true,\n                Connection: HttpConnection,\n              },\n            }),\n          ],\n        }),\n        ElkModule,\n      ],\n    }).compile();\n    app = moduleFixture.createNestApplication();\n    interceptor = new ElkInterceptor(app.get<ElkService>(ElkService));\n    app.useGlobalInterceptors(interceptor);\n    elkService = moduleFixture.get<ElkService>(ElkService);\n    await app.init();\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', () => {\n    expect(app).toBeDefined();\n  });\n\n  describe('ElkInterceptor', () => {\n    it('should be an ElkInterceptor instance to be defined', async () => {\n      expect(new ElkInterceptor(elkService)).toBeDefined();\n    });\n\n    it('should be create document in elasticsearch when return success string', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of('this is a test')),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return success object', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of([fixtureUserResponse])),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return success with parameters', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of([fixtureUserResponse])),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContextParams, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return exception', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const error = new Error(`User #$1 not found`);\n\n      const callHandler: any = {\n        handle: jest.fn(() => throwError(error)),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () => {},\n        error: (error) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n\n    it('should be create document in elasticsearch when return exception http', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const error = new HttpException('not found', 404);\n\n      const callHandler: any = {\n        handle: jest.fn(() => throwError(error)),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () => {},\n        error: (error) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n  });\n\n  describe('ElkModule - Register', () => {\n    let app: INestApplication;\n    let elkService: ElkService;\n    let interceptor: ElkInterceptor<any>;\n\n    beforeEach(async () => {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ElkModule.register({\n            name: 'test-elk-index',\n            node: {\n              url: new URL(`http://${container.getHost()}:9200`),\n            },\n            maxRetries: 10,\n            requestTimeout: 60000,\n            sniffOnStart: true,\n            Connection: HttpConnection,\n          }),\n        ],\n      }).compile();\n      app = moduleFixture.createNestApplication();\n      interceptor = new ElkInterceptor(app.get<ElkService>(ElkService));\n      app.useGlobalInterceptors(interceptor);\n      elkService = moduleFixture.get<ElkService>(ElkService);\n      await app.init();\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be defined', () => {\n      expect(app).toBeDefined();\n    });\n  });\n});\n",
              "err": {},
              "uuid": "84bc7e3a-f7a4-4ea6-9dbe-7890edb8b263",
              "parentUUID": "75f69b88-729b-4c0f-b415-5d527cb20391",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "ElkModule > ElkModule - Register > should be defined",
              "title": "ElkModule > ElkModule - Register > should be defined",
              "timedOut": false,
              "duration": 1032,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { HttpException, INestApplication } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport {\n  dynamicConfig,\n  fixtureUserResponse,\n  TCElasticSearchOptions,\n  tcName,\n  testContainers,\n} from '@tresdoce-nestjs-toolkit/test-utils';\nimport { Observable, of, throwError } from 'rxjs';\nimport { HttpConnection } from '@elastic/elasticsearch';\nimport { URL } from 'url';\n\nimport { ElkModule } from '../elk/elk.module';\nimport { ElkInterceptor } from '../elk/interceptors/elk.interceptor';\nimport { ElkService } from '../elk/services/elk.service';\n\nlet executionContext: any = {\n  switchToHttp: jest.fn(() => ({\n    getRequest: () => ({\n      path: '/test',\n      method: 'GET',\n      params: {},\n      query: {},\n      body: {},\n      headers: {\n        'Content-Type': 'application/json',\n        apiKey: 'abcdefg12345',\n      },\n    }),\n    getResponse: () => ({\n      getHeaders: jest.fn().mockReturnValue({\n        'Content-Type': 'application/json',\n        my_header: 'test-header',\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() => 'http'),\n  getClass: jest.fn(() => 'testController'),\n  getHandler: jest.fn(() => 'handlerElk'),\n};\n\nlet executionContextParams: any = {\n  switchToHttp: jest.fn(() => ({\n    getRequest: () => ({\n      path: '/test',\n      method: 'GET',\n      params: { name: 'juan' },\n      query: { name: 'juan' },\n      body: { name: 'juan' },\n      headers: {\n        'Content-Type': 'application/json',\n        apiKey: 'abcdefg12345',\n      },\n    }),\n    getResponse: () => ({\n      getHeaders: jest.fn().mockReturnValue({\n        'Content-Type': 'application/json',\n        my_header: 'test-header',\n      }),\n      json: [fixtureUserResponse],\n    }),\n  })),\n  getType: jest.fn(() => 'http'),\n  getClass: jest.fn(() => 'testController'),\n  getHandler: jest.fn(() => 'handlerElk'),\n};\n\n/*const callHandler: any = {\n  handle: jest.fn(() => ({\n    pipe: jest.fn(() => ({\n      tap: jest.fn(() => ({\n        next: jest.fn(),\n        error: jest.fn(),\n      })),\n    })),\n  })),\n};*/\n\njest.setTimeout(70000);\ndescribe('ElkModule', () => {\n  let app: INestApplication;\n  let elkService: ElkService;\n  let interceptor: ElkInterceptor<any>;\n  let container: testContainers;\n\n  beforeAll(async () => {\n    //'elasticsearch:8.3.3'\n    //docker.elastic.co/elasticsearch/elasticsearch:8.3.3\n\n    container = await new testContainers('elasticsearch:8.3.3', {\n      ...TCElasticSearchOptions,\n      containerName: `${tcName}-elasticsearch-interceptor`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () => {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () => {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [\n            dynamicConfig({\n              elasticsearch: {\n                name: 'test-elk-index',\n                node: {\n                  url: new URL(`http://${container.getHost()}:9200`),\n                },\n                maxRetries: 10,\n                requestTimeout: 60000,\n                sniffOnStart: true,\n                Connection: HttpConnection,\n              },\n            }),\n          ],\n        }),\n        ElkModule,\n      ],\n    }).compile();\n    app = moduleFixture.createNestApplication();\n    interceptor = new ElkInterceptor(app.get<ElkService>(ElkService));\n    app.useGlobalInterceptors(interceptor);\n    elkService = moduleFixture.get<ElkService>(ElkService);\n    await app.init();\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', () => {\n    expect(app).toBeDefined();\n  });\n\n  describe('ElkInterceptor', () => {\n    it('should be an ElkInterceptor instance to be defined', async () => {\n      expect(new ElkInterceptor(elkService)).toBeDefined();\n    });\n\n    it('should be create document in elasticsearch when return success string', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of('this is a test')),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return success object', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of([fixtureUserResponse])),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, response, false);\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContext,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return success with parameters', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const callHandler: any = {\n        handle: jest.fn(() => of([fixtureUserResponse])),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContextParams, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: (response) => {\n          elkService.serializeResponseInterceptor(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n          expect(interceptorServiceSpy).toBeCalledWith(\n            timeRequest,\n            executionContextParams,\n            response,\n            false,\n          );\n        },\n        error: () => {},\n      });\n    });\n\n    it('should be create document in elasticsearch when return exception', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const error = new Error(`User #$1 not found`);\n\n      const callHandler: any = {\n        handle: jest.fn(() => throwError(error)),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () => {},\n        error: (error) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n\n    it('should be create document in elasticsearch when return exception http', async () => {\n      const interceptorServiceSpy = jest.spyOn(elkService, 'serializeResponseInterceptor');\n      const timeRequest = Date.now();\n\n      const error = new HttpException('not found', 404);\n\n      const callHandler: any = {\n        handle: jest.fn(() => throwError(error)),\n      };\n\n      const obs: Observable<any> = interceptor.intercept(executionContext, callHandler);\n      expect(callHandler.handle).toBeCalledTimes(1);\n\n      obs.subscribe({\n        next: () => {},\n        error: (error) => {\n          elkService.serializeResponseInterceptor(timeRequest, executionContext, error, true);\n          expect(interceptorServiceSpy).toBeCalledWith(timeRequest, executionContext, error, true);\n        },\n      });\n    });\n  });\n\n  describe('ElkModule - Register', () => {\n    let app: INestApplication;\n    let elkService: ElkService;\n    let interceptor: ElkInterceptor<any>;\n\n    beforeEach(async () => {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ElkModule.register({\n            name: 'test-elk-index',\n            node: {\n              url: new URL(`http://${container.getHost()}:9200`),\n            },\n            maxRetries: 10,\n            requestTimeout: 60000,\n            sniffOnStart: true,\n            Connection: HttpConnection,\n          }),\n        ],\n      }).compile();\n      app = moduleFixture.createNestApplication();\n      interceptor = new ElkInterceptor(app.get<ElkService>(ElkService));\n      app.useGlobalInterceptors(interceptor);\n      elkService = moduleFixture.get<ElkService>(ElkService);\n      await app.init();\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be defined', () => {\n      expect(app).toBeDefined();\n    });\n  });\n});\n",
              "err": {},
              "uuid": "b993c3e1-8a86-470d-8171-6750642b856e",
              "parentUUID": "75f69b88-729b-4c0f-b415-5d527cb20391",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "8dc6dac1-0415-48e0-b158-3f2293573a9a",
            "35994cbb-1ced-492b-acec-73db2b57cc1b",
            "c681ce2b-0d0b-492f-9b1c-f8c18c89a411",
            "491352ef-7f86-49af-b237-627f3b1dea8c",
            "6797888f-7622-40e8-9f07-046b874f810b",
            "362bf64a-49fe-482b-b083-82cff019d127",
            "84bc7e3a-f7a4-4ea6-9dbe-7890edb8b263",
            "b993c3e1-8a86-470d-8171-6750642b856e"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 8451,
          "root": false,
          "rootEmpty": false,
          "_timeout": 5000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 5000
    },
    {
      "uuid": "7a309b9f-81ec-44db-a70c-34772ca802df",
      "title": "@tresdoce-nestjs-toolkit/filters",
      "fullFile": "",
      "file": "",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "4e0fc067-c8de-4af8-9096-d112fd14f523",
          "title": "@tresdoce-nestjs-toolkit/filters",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "fullTitle": "filters > code exception > should map a regular code exception",
              "title": "filters > code exception > should map a regular code exception",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "b4acf2f5-90db-4855-92ff-eb793179824e",
              "parentUUID": "4e0fc067-c8de-4af8-9096-d112fd14f523",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > default Http exceptions > should map default exception when thrown with not parameters",
              "title": "filters > default Http exceptions > should map default exception when thrown with not parameters",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "9e419ce0-bee9-49af-933f-d1c43ac36606",
              "parentUUID": "4e0fc067-c8de-4af8-9096-d112fd14f523",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > default Http exceptions > should map default exception when thrown with error details",
              "title": "filters > default Http exceptions > should map default exception when thrown with error details",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "b65b96d1-61ec-423c-a772-f9a71b8b412e",
              "parentUUID": "4e0fc067-c8de-4af8-9096-d112fd14f523",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > default Http exceptions > should map default exception when thrown with error details and description",
              "title": "filters > default Http exceptions > should map default exception when thrown with error details and description",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "2ae5669d-9ef1-4c66-9b2a-88ff43f1237e",
              "parentUUID": "4e0fc067-c8de-4af8-9096-d112fd14f523",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > default Http exceptions > the generic HttpException > should map HttpException response when called with a string",
              "title": "filters > default Http exceptions > the generic HttpException > should map HttpException response when called with a string",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "1a0873b3-9a92-41c0-a365-2d11ce793409",
              "parentUUID": "4e0fc067-c8de-4af8-9096-d112fd14f523",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > default Http exceptions > the generic HttpException > should map HttpException response when called with an object",
              "title": "filters > default Http exceptions > the generic HttpException > should map HttpException response when called with an object",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "f861e391-3d0f-4b4a-a790-6af316fc7177",
              "parentUUID": "4e0fc067-c8de-4af8-9096-d112fd14f523",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > default Http exceptions > the generic HttpException > should map HttpException response when called with an object with empty message",
              "title": "filters > default Http exceptions > the generic HttpException > should map HttpException response when called with an object with empty message",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "7ddfd827-e22b-4bc1-a375-a0e7348850dd",
              "parentUUID": "4e0fc067-c8de-4af8-9096-d112fd14f523",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > default Http exceptions > the generic HttpException > should map HttpException response when called with an array",
              "title": "filters > default Http exceptions > the generic HttpException > should map HttpException response when called with an array",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "962c9544-619d-4a6a-8958-847b1c8e0c53",
              "parentUUID": "4e0fc067-c8de-4af8-9096-d112fd14f523",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > default Http exceptions > should map HttpException response when called with an object",
              "title": "filters > default Http exceptions > should map HttpException response when called with an object",
              "timedOut": false,
              "duration": 0,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "b4d5699c-de68-402b-8118-daddf80b1bde",
              "parentUUID": "4e0fc067-c8de-4af8-9096-d112fd14f523",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > when used outside a module > should map default exception when thrown with not parameters",
              "title": "filters > when used outside a module > should map default exception when thrown with not parameters",
              "timedOut": false,
              "duration": 0,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "ea8688aa-e22d-43bb-8339-d3797d01f6a5",
              "parentUUID": "4e0fc067-c8de-4af8-9096-d112fd14f523",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "filters > configuration is defined with values > should be return application info",
              "title": "filters > configuration is defined with values > should be return application info",
              "timedOut": false,
              "duration": 0,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { BadRequestException, ForbiddenException, HttpException, HttpStatus } from '@nestjs/common';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { ExceptionsFilter, PROBLEM_CONTENT_TYPE, IErrorDetail, IProblemDetail } from '../';\n\nconst mockJson = jest.fn();\n\nconst mockStatus = jest.fn().mockImplementation(() => ({\n  json: mockJson,\n}));\n\nconst mockType = jest.fn().mockImplementation(() => ({\n  status: mockStatus,\n}));\n\nconst mockGetResponse = jest.fn().mockImplementation(() => ({\n  type: mockType,\n}));\n\nconst mockUrl = jest.fn().mockImplementation(() => ({\n  url: mockJson,\n}));\n\nconst mockGetRequest = jest.fn().mockImplementation(() => ({\n  type: mockUrl,\n}));\n\nconst mockHttpArgumentsHost = jest.fn().mockImplementation(() => ({\n  getResponse: mockGetResponse,\n  getRequest: mockGetRequest,\n}));\n\nconst mockArgumentsHost = {\n  switchToHttp: mockHttpArgumentsHost,\n  getArgByIndex: jest.fn(),\n  getArgs: jest.fn(),\n  getType: jest.fn(),\n  switchToRpc: jest.fn(),\n  switchToWs: jest.fn(),\n};\n\ndescribe('filters', () => {\n  describe('code exception', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map a regular code exception', () => {\n      const status = HttpStatus.INTERNAL_SERVER_ERROR;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n      try {\n        const linea: any = undefined;\n        linea.split('');\n      } catch (error) {\n        filter.catch(error, mockArgumentsHost);\n        assertResponse(status, expectation);\n      }\n    });\n  });\n\n  describe('default Http exceptions', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        status,\n        code: HttpStatus[status],\n        detail: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    it('should map default exception when thrown with error details and description', () => {\n      const status = HttpStatus.FORBIDDEN;\n      const message = 'passing?';\n      const details = 'not pass!';\n\n      const expectation: IProblemDetail = {\n        message,\n        detail: details,\n        status,\n        code: HttpStatus[status],\n      };\n      filter.catch(new ForbiddenException(message, details), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n\n    describe('the generic HttpException', () => {\n      it('should map HttpException response when called with a string', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const message = 'Not passing';\n\n        const expectation: IProblemDetail = {\n          message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(message, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: 'some message',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an object with empty message', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject: IErrorDetail = {\n          message: '',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.message,\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n        assertResponse(status, expectation);\n      });\n\n      it('should map HttpException response when called with an array', () => {\n        const status = HttpStatus.SEE_OTHER;\n        const errorObject = {\n          message: ['some message', 'some message 2'],\n          error: 'Bad Request',\n        };\n\n        const expectation: IProblemDetail = {\n          message: errorObject.error,\n          detail: [{ message: errorObject.message[0] }, { message: errorObject.message[1] }],\n          status,\n          code: HttpStatus[status],\n        };\n\n        filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n        assertResponse(status, expectation);\n      });\n    });\n\n    it('should map HttpException response when called with an object', () => {\n      const errorObject: IErrorDetail = {\n        message: 'some message',\n        error: {\n          instance: 'instance',\n          type: 'some-problem-detail',\n        },\n      };\n\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: errorObject.message,\n        detail: errorObject.error,\n        status,\n        instance: errorObject.error.instance,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new HttpException(errorObject, status), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('when used outside a module', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n    it('should map default exception when thrown with not parameters', () => {\n      const status = HttpStatus.BAD_REQUEST;\n      const expectation: IProblemDetail = {\n        message: HttpStatus[status],\n        status,\n        code: HttpStatus[status],\n      };\n\n      filter.catch(new BadRequestException(), mockArgumentsHost);\n\n      assertResponse(status, expectation);\n    });\n  });\n\n  describe('configuration is defined with values', () => {\n    const appConfig = config();\n    const filter = new ExceptionsFilter(appConfig);\n\n    it('should be return application info', async () => {\n      expect(appConfig.project.apiPrefix).toEqual('API-TEST');\n    });\n\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n\n    assertResponse(status, expectation);\n  });\n\n  describe('configuration is undefined', () => {\n    const appConfig = undefined;\n    const filter = new ExceptionsFilter(appConfig);\n    const status = HttpStatus.BAD_REQUEST;\n    const expectation: IProblemDetail = {\n      message: HttpStatus[status],\n      status,\n      code: HttpStatus[status],\n    };\n\n    filter.catch(new BadRequestException(), mockArgumentsHost);\n    assertResponse(status, expectation);\n  });\n});\n\nfunction assertResponse(expectedStatus: number, expectedJson: IProblemDetail) {\n  expect(mockType).toHaveBeenCalledWith(PROBLEM_CONTENT_TYPE);\n  expect(mockStatus).toHaveBeenCalledWith(expectedStatus);\n}\n",
              "err": {},
              "uuid": "7ffa0cd7-e6c3-42b0-a005-211c7d123570",
              "parentUUID": "4e0fc067-c8de-4af8-9096-d112fd14f523",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "error.utils > should be return code in string",
              "title": "error.utils > should be return code in string",
              "timedOut": false,
              "duration": 7,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { getCode } from '../';\nimport { HttpStatus } from '@nestjs/common';\n\ndescribe('error.utils', () => {\n  it('should be return code in string', () => {\n    const code = getCode(HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR]);\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n\n  it('should be return code in string obj', () => {\n    const code = getCode({ error: HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR] });\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n\n  it('should be return code in string', () => {\n    const code = getCode({ error: HttpStatus['TEST_ERROR'] });\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n});\n",
              "err": {},
              "uuid": "9cac9cc4-8442-4cb7-9609-d75010cf1cc3",
              "parentUUID": "4e0fc067-c8de-4af8-9096-d112fd14f523",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "error.utils > should be return code in string obj",
              "title": "error.utils > should be return code in string obj",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { getCode } from '../';\nimport { HttpStatus } from '@nestjs/common';\n\ndescribe('error.utils', () => {\n  it('should be return code in string', () => {\n    const code = getCode(HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR]);\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n\n  it('should be return code in string obj', () => {\n    const code = getCode({ error: HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR] });\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n\n  it('should be return code in string', () => {\n    const code = getCode({ error: HttpStatus['TEST_ERROR'] });\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n});\n",
              "err": {},
              "uuid": "cda3d17c-c490-49ad-8210-4219d997e1ef",
              "parentUUID": "4e0fc067-c8de-4af8-9096-d112fd14f523",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "error.utils > should be return code in string",
              "title": "error.utils > should be return code in string",
              "timedOut": false,
              "duration": 0,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { getCode } from '../';\nimport { HttpStatus } from '@nestjs/common';\n\ndescribe('error.utils', () => {\n  it('should be return code in string', () => {\n    const code = getCode(HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR]);\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n\n  it('should be return code in string obj', () => {\n    const code = getCode({ error: HttpStatus[HttpStatus.INTERNAL_SERVER_ERROR] });\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n\n  it('should be return code in string', () => {\n    const code = getCode({ error: HttpStatus['TEST_ERROR'] });\n    expect(code).toEqual('INTERNAL_SERVER_ERROR');\n  });\n});\n",
              "err": {},
              "uuid": "4d2a0693-b16f-4044-a686-52d906f42aa8",
              "parentUUID": "4e0fc067-c8de-4af8-9096-d112fd14f523",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "b4acf2f5-90db-4855-92ff-eb793179824e",
            "9e419ce0-bee9-49af-933f-d1c43ac36606",
            "b65b96d1-61ec-423c-a772-f9a71b8b412e",
            "2ae5669d-9ef1-4c66-9b2a-88ff43f1237e",
            "1a0873b3-9a92-41c0-a365-2d11ce793409",
            "f861e391-3d0f-4b4a-a790-6af316fc7177",
            "7ddfd827-e22b-4bc1-a375-a0e7348850dd",
            "962c9544-619d-4a6a-8958-847b1c8e0c53",
            "b4d5699c-de68-402b-8118-daddf80b1bde",
            "ea8688aa-e22d-43bb-8339-d3797d01f6a5",
            "7ffa0cd7-e6c3-42b0-a005-211c7d123570",
            "9cac9cc4-8442-4cb7-9609-d75010cf1cc3",
            "cda3d17c-c490-49ad-8210-4219d997e1ef",
            "4d2a0693-b16f-4044-a686-52d906f42aa8"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 17,
          "root": false,
          "rootEmpty": false,
          "_timeout": 5000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 5000
    },
    {
      "uuid": "9f431b87-f9ff-49f2-92b7-967e4b57409c",
      "title": "@tresdoce-nestjs-toolkit/health",
      "fullFile": "",
      "file": "",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "cb2d6453-56ce-4c60-bd04-f382477fd87a",
          "title": "@tresdoce-nestjs-toolkit/health",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "fullTitle": "Health > Ready controller - extend config > should be defined with extend config",
              "title": "Health > Ready controller - extend config > should be defined with extend config",
              "timedOut": false,
              "duration": 763,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { HttpModule } from '@nestjs/axios';\nimport {\n  HealthCheckService,\n  HttpHealthIndicator,\n  TerminusModule,\n  TypeOrmHealthIndicator,\n  MicroserviceHealthIndicator,\n} from '@nestjs/terminus';\n\nimport { ReadinessController } from '../health/controllers/readiness.controller';\nimport { CONFIG_OPTIONS } from '../health/constants';\n\nconst mockedConfig = {\n  services: {\n    myService: {\n      url: 'http://localhost:8082',\n      timeout: 3000,\n    },\n    demoApi: {\n      url: 'https://nestjs-starter.up.railway.app',\n      timeout: 3000,\n      healthPath: '/v1/health/liveness',\n    },\n  },\n  database: {\n    typeorm: {\n      type: 'postgres',\n    },\n  },\n  redis: {\n    host: 'localhost',\n    port: 6379,\n  },\n  elasticsearch: {\n    name: 'test-app',\n    node: 'http://localhost:9200',\n  },\n  camunda: {\n    baseUrl: 'http://localhost:8080/engine-rest',\n  },\n};\n\nconst mockExpectReadiness = {\n  status: 'ok',\n  info: {\n    myService: {\n      status: 'up',\n    },\n    typeOrm: {\n      status: 'up',\n    },\n    redis: {\n      status: 'up',\n    },\n    elasticsearch: {\n      status: 'up',\n    },\n    camunda: {\n      status: 'up',\n    },\n  },\n  error: {},\n  details: {\n    myService: {\n      status: 'up',\n    },\n    typeOrm: {\n      status: 'up',\n    },\n    redis: {\n      status: 'up',\n    },\n    elasticsearch: {\n      status: 'up',\n    },\n    camunda: {\n      status: 'up',\n    },\n  },\n};\n\nconst mockExpectReadinessDown = {\n  myService: {\n    status: 'down',\n    message: 'connect ECONNREFUSED 127.0.0.1:8082',\n  },\n};\n\nconst simpleConfig = {\n  services: {\n    myService: { url: 'http://localhost:8082' },\n  },\n};\n\ndescribe('Health', () => {\n  describe('Ready controller - extend config', () => {\n    let controller: ReadinessController;\n    let health: HealthCheckService;\n    let http: HttpHealthIndicator;\n    let typeOrm: TypeOrmHealthIndicator;\n    let redis: MicroserviceHealthIndicator;\n\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [TerminusModule, HttpModule],\n        controllers: [ReadinessController],\n        providers: [\n          {\n            provide: CONFIG_OPTIONS,\n            useValue: mockedConfig,\n          },\n        ],\n      }).compile();\n\n      controller = module.get<ReadinessController>(ReadinessController);\n      health = await module.resolve<HealthCheckService>(HealthCheckService);\n      http = await module.resolve<HttpHealthIndicator>(HttpHealthIndicator as any);\n      typeOrm = await module.resolve<TypeOrmHealthIndicator>(TypeOrmHealthIndicator);\n      redis = await module.resolve<MicroserviceHealthIndicator>(MicroserviceHealthIndicator);\n    });\n\n    it('should be defined with extend config', () => {\n      expect(controller).toBeDefined();\n    });\n\n    it('should be return up services with extend config', async () => {\n      http.pingCheck = jest.fn().mockImplementation(() => mockExpectReadiness.info);\n      typeOrm.pingCheck = jest.fn().mockImplementation(() => mockExpectReadiness.info);\n      redis.pingCheck = jest.fn().mockImplementation(() => mockExpectReadiness.info);\n      health.check = jest.fn().mockImplementation(() => mockExpectReadiness);\n\n      const readinessData = await controller.check();\n      expect(readinessData).toEqual(mockExpectReadiness);\n    });\n  });\n\n  describe('Ready controller - simple config', () => {\n    let controller: ReadinessController;\n    let health: HealthCheckService;\n    let http: HttpHealthIndicator;\n    let typeOrm: TypeOrmHealthIndicator;\n    let redis: MicroserviceHealthIndicator;\n\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [TerminusModule, HttpModule],\n        controllers: [ReadinessController],\n        providers: [\n          {\n            provide: CONFIG_OPTIONS,\n            useValue: simpleConfig,\n          },\n        ],\n      }).compile();\n\n      controller = module.get<ReadinessController>(ReadinessController);\n      health = await module.resolve<HealthCheckService>(HealthCheckService);\n      http = await module.resolve<HttpHealthIndicator>(HttpHealthIndicator as any);\n      typeOrm = await module.resolve<TypeOrmHealthIndicator>(TypeOrmHealthIndicator);\n      redis = await module.resolve<MicroserviceHealthIndicator>(MicroserviceHealthIndicator);\n    });\n\n    it('should be defined with simple config', () => {\n      expect(controller).toBeDefined();\n    });\n\n    it('should be return up services with simple config', async () => {\n      http.pingCheck = jest.fn().mockImplementation(() => mockExpectReadiness.info);\n      typeOrm.pingCheck = jest.fn().mockImplementation(() => mockExpectReadiness.info);\n      redis.pingCheck = jest.fn().mockImplementation(() => mockExpectReadiness.info);\n      health.check = jest.fn().mockImplementation(() => mockExpectReadiness);\n\n      const readinessData = await controller.check();\n      expect(readinessData).toEqual(mockExpectReadiness);\n    });\n  });\n});\n",
              "err": {},
              "uuid": "e16002b4-8452-459d-bc34-c8de7786309a",
              "parentUUID": "cb2d6453-56ce-4c60-bd04-f382477fd87a",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "Health > Ready controller - extend config > should be return up services with extend config",
              "title": "Health > Ready controller - extend config > should be return up services with extend config",
              "timedOut": false,
              "duration": 6,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { HttpModule } from '@nestjs/axios';\nimport {\n  HealthCheckService,\n  HttpHealthIndicator,\n  TerminusModule,\n  TypeOrmHealthIndicator,\n  MicroserviceHealthIndicator,\n} from '@nestjs/terminus';\n\nimport { ReadinessController } from '../health/controllers/readiness.controller';\nimport { CONFIG_OPTIONS } from '../health/constants';\n\nconst mockedConfig = {\n  services: {\n    myService: {\n      url: 'http://localhost:8082',\n      timeout: 3000,\n    },\n    demoApi: {\n      url: 'https://nestjs-starter.up.railway.app',\n      timeout: 3000,\n      healthPath: '/v1/health/liveness',\n    },\n  },\n  database: {\n    typeorm: {\n      type: 'postgres',\n    },\n  },\n  redis: {\n    host: 'localhost',\n    port: 6379,\n  },\n  elasticsearch: {\n    name: 'test-app',\n    node: 'http://localhost:9200',\n  },\n  camunda: {\n    baseUrl: 'http://localhost:8080/engine-rest',\n  },\n};\n\nconst mockExpectReadiness = {\n  status: 'ok',\n  info: {\n    myService: {\n      status: 'up',\n    },\n    typeOrm: {\n      status: 'up',\n    },\n    redis: {\n      status: 'up',\n    },\n    elasticsearch: {\n      status: 'up',\n    },\n    camunda: {\n      status: 'up',\n    },\n  },\n  error: {},\n  details: {\n    myService: {\n      status: 'up',\n    },\n    typeOrm: {\n      status: 'up',\n    },\n    redis: {\n      status: 'up',\n    },\n    elasticsearch: {\n      status: 'up',\n    },\n    camunda: {\n      status: 'up',\n    },\n  },\n};\n\nconst mockExpectReadinessDown = {\n  myService: {\n    status: 'down',\n    message: 'connect ECONNREFUSED 127.0.0.1:8082',\n  },\n};\n\nconst simpleConfig = {\n  services: {\n    myService: { url: 'http://localhost:8082' },\n  },\n};\n\ndescribe('Health', () => {\n  describe('Ready controller - extend config', () => {\n    let controller: ReadinessController;\n    let health: HealthCheckService;\n    let http: HttpHealthIndicator;\n    let typeOrm: TypeOrmHealthIndicator;\n    let redis: MicroserviceHealthIndicator;\n\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [TerminusModule, HttpModule],\n        controllers: [ReadinessController],\n        providers: [\n          {\n            provide: CONFIG_OPTIONS,\n            useValue: mockedConfig,\n          },\n        ],\n      }).compile();\n\n      controller = module.get<ReadinessController>(ReadinessController);\n      health = await module.resolve<HealthCheckService>(HealthCheckService);\n      http = await module.resolve<HttpHealthIndicator>(HttpHealthIndicator as any);\n      typeOrm = await module.resolve<TypeOrmHealthIndicator>(TypeOrmHealthIndicator);\n      redis = await module.resolve<MicroserviceHealthIndicator>(MicroserviceHealthIndicator);\n    });\n\n    it('should be defined with extend config', () => {\n      expect(controller).toBeDefined();\n    });\n\n    it('should be return up services with extend config', async () => {\n      http.pingCheck = jest.fn().mockImplementation(() => mockExpectReadiness.info);\n      typeOrm.pingCheck = jest.fn().mockImplementation(() => mockExpectReadiness.info);\n      redis.pingCheck = jest.fn().mockImplementation(() => mockExpectReadiness.info);\n      health.check = jest.fn().mockImplementation(() => mockExpectReadiness);\n\n      const readinessData = await controller.check();\n      expect(readinessData).toEqual(mockExpectReadiness);\n    });\n  });\n\n  describe('Ready controller - simple config', () => {\n    let controller: ReadinessController;\n    let health: HealthCheckService;\n    let http: HttpHealthIndicator;\n    let typeOrm: TypeOrmHealthIndicator;\n    let redis: MicroserviceHealthIndicator;\n\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [TerminusModule, HttpModule],\n        controllers: [ReadinessController],\n        providers: [\n          {\n            provide: CONFIG_OPTIONS,\n            useValue: simpleConfig,\n          },\n        ],\n      }).compile();\n\n      controller = module.get<ReadinessController>(ReadinessController);\n      health = await module.resolve<HealthCheckService>(HealthCheckService);\n      http = await module.resolve<HttpHealthIndicator>(HttpHealthIndicator as any);\n      typeOrm = await module.resolve<TypeOrmHealthIndicator>(TypeOrmHealthIndicator);\n      redis = await module.resolve<MicroserviceHealthIndicator>(MicroserviceHealthIndicator);\n    });\n\n    it('should be defined with simple config', () => {\n      expect(controller).toBeDefined();\n    });\n\n    it('should be return up services with simple config', async () => {\n      http.pingCheck = jest.fn().mockImplementation(() => mockExpectReadiness.info);\n      typeOrm.pingCheck = jest.fn().mockImplementation(() => mockExpectReadiness.info);\n      redis.pingCheck = jest.fn().mockImplementation(() => mockExpectReadiness.info);\n      health.check = jest.fn().mockImplementation(() => mockExpectReadiness);\n\n      const readinessData = await controller.check();\n      expect(readinessData).toEqual(mockExpectReadiness);\n    });\n  });\n});\n",
              "err": {},
              "uuid": "f98ed6d1-8348-468b-ae68-4c067c8d1ac3",
              "parentUUID": "cb2d6453-56ce-4c60-bd04-f382477fd87a",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "Health > Ready controller - simple config > should be defined with simple config",
              "title": "Health > Ready controller - simple config > should be defined with simple config",
              "timedOut": false,
              "duration": 5,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { HttpModule } from '@nestjs/axios';\nimport {\n  HealthCheckService,\n  HttpHealthIndicator,\n  TerminusModule,\n  TypeOrmHealthIndicator,\n  MicroserviceHealthIndicator,\n} from '@nestjs/terminus';\n\nimport { ReadinessController } from '../health/controllers/readiness.controller';\nimport { CONFIG_OPTIONS } from '../health/constants';\n\nconst mockedConfig = {\n  services: {\n    myService: {\n      url: 'http://localhost:8082',\n      timeout: 3000,\n    },\n    demoApi: {\n      url: 'https://nestjs-starter.up.railway.app',\n      timeout: 3000,\n      healthPath: '/v1/health/liveness',\n    },\n  },\n  database: {\n    typeorm: {\n      type: 'postgres',\n    },\n  },\n  redis: {\n    host: 'localhost',\n    port: 6379,\n  },\n  elasticsearch: {\n    name: 'test-app',\n    node: 'http://localhost:9200',\n  },\n  camunda: {\n    baseUrl: 'http://localhost:8080/engine-rest',\n  },\n};\n\nconst mockExpectReadiness = {\n  status: 'ok',\n  info: {\n    myService: {\n      status: 'up',\n    },\n    typeOrm: {\n      status: 'up',\n    },\n    redis: {\n      status: 'up',\n    },\n    elasticsearch: {\n      status: 'up',\n    },\n    camunda: {\n      status: 'up',\n    },\n  },\n  error: {},\n  details: {\n    myService: {\n      status: 'up',\n    },\n    typeOrm: {\n      status: 'up',\n    },\n    redis: {\n      status: 'up',\n    },\n    elasticsearch: {\n      status: 'up',\n    },\n    camunda: {\n      status: 'up',\n    },\n  },\n};\n\nconst mockExpectReadinessDown = {\n  myService: {\n    status: 'down',\n    message: 'connect ECONNREFUSED 127.0.0.1:8082',\n  },\n};\n\nconst simpleConfig = {\n  services: {\n    myService: { url: 'http://localhost:8082' },\n  },\n};\n\ndescribe('Health', () => {\n  describe('Ready controller - extend config', () => {\n    let controller: ReadinessController;\n    let health: HealthCheckService;\n    let http: HttpHealthIndicator;\n    let typeOrm: TypeOrmHealthIndicator;\n    let redis: MicroserviceHealthIndicator;\n\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [TerminusModule, HttpModule],\n        controllers: [ReadinessController],\n        providers: [\n          {\n            provide: CONFIG_OPTIONS,\n            useValue: mockedConfig,\n          },\n        ],\n      }).compile();\n\n      controller = module.get<ReadinessController>(ReadinessController);\n      health = await module.resolve<HealthCheckService>(HealthCheckService);\n      http = await module.resolve<HttpHealthIndicator>(HttpHealthIndicator as any);\n      typeOrm = await module.resolve<TypeOrmHealthIndicator>(TypeOrmHealthIndicator);\n      redis = await module.resolve<MicroserviceHealthIndicator>(MicroserviceHealthIndicator);\n    });\n\n    it('should be defined with extend config', () => {\n      expect(controller).toBeDefined();\n    });\n\n    it('should be return up services with extend config', async () => {\n      http.pingCheck = jest.fn().mockImplementation(() => mockExpectReadiness.info);\n      typeOrm.pingCheck = jest.fn().mockImplementation(() => mockExpectReadiness.info);\n      redis.pingCheck = jest.fn().mockImplementation(() => mockExpectReadiness.info);\n      health.check = jest.fn().mockImplementation(() => mockExpectReadiness);\n\n      const readinessData = await controller.check();\n      expect(readinessData).toEqual(mockExpectReadiness);\n    });\n  });\n\n  describe('Ready controller - simple config', () => {\n    let controller: ReadinessController;\n    let health: HealthCheckService;\n    let http: HttpHealthIndicator;\n    let typeOrm: TypeOrmHealthIndicator;\n    let redis: MicroserviceHealthIndicator;\n\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [TerminusModule, HttpModule],\n        controllers: [ReadinessController],\n        providers: [\n          {\n            provide: CONFIG_OPTIONS,\n            useValue: simpleConfig,\n          },\n        ],\n      }).compile();\n\n      controller = module.get<ReadinessController>(ReadinessController);\n      health = await module.resolve<HealthCheckService>(HealthCheckService);\n      http = await module.resolve<HttpHealthIndicator>(HttpHealthIndicator as any);\n      typeOrm = await module.resolve<TypeOrmHealthIndicator>(TypeOrmHealthIndicator);\n      redis = await module.resolve<MicroserviceHealthIndicator>(MicroserviceHealthIndicator);\n    });\n\n    it('should be defined with simple config', () => {\n      expect(controller).toBeDefined();\n    });\n\n    it('should be return up services with simple config', async () => {\n      http.pingCheck = jest.fn().mockImplementation(() => mockExpectReadiness.info);\n      typeOrm.pingCheck = jest.fn().mockImplementation(() => mockExpectReadiness.info);\n      redis.pingCheck = jest.fn().mockImplementation(() => mockExpectReadiness.info);\n      health.check = jest.fn().mockImplementation(() => mockExpectReadiness);\n\n      const readinessData = await controller.check();\n      expect(readinessData).toEqual(mockExpectReadiness);\n    });\n  });\n});\n",
              "err": {},
              "uuid": "3eb85d7b-dc99-4629-b52d-b8c6c9733284",
              "parentUUID": "cb2d6453-56ce-4c60-bd04-f382477fd87a",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "Health > Ready controller - simple config > should be return up services with simple config",
              "title": "Health > Ready controller - simple config > should be return up services with simple config",
              "timedOut": false,
              "duration": 4,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { HttpModule } from '@nestjs/axios';\nimport {\n  HealthCheckService,\n  HttpHealthIndicator,\n  TerminusModule,\n  TypeOrmHealthIndicator,\n  MicroserviceHealthIndicator,\n} from '@nestjs/terminus';\n\nimport { ReadinessController } from '../health/controllers/readiness.controller';\nimport { CONFIG_OPTIONS } from '../health/constants';\n\nconst mockedConfig = {\n  services: {\n    myService: {\n      url: 'http://localhost:8082',\n      timeout: 3000,\n    },\n    demoApi: {\n      url: 'https://nestjs-starter.up.railway.app',\n      timeout: 3000,\n      healthPath: '/v1/health/liveness',\n    },\n  },\n  database: {\n    typeorm: {\n      type: 'postgres',\n    },\n  },\n  redis: {\n    host: 'localhost',\n    port: 6379,\n  },\n  elasticsearch: {\n    name: 'test-app',\n    node: 'http://localhost:9200',\n  },\n  camunda: {\n    baseUrl: 'http://localhost:8080/engine-rest',\n  },\n};\n\nconst mockExpectReadiness = {\n  status: 'ok',\n  info: {\n    myService: {\n      status: 'up',\n    },\n    typeOrm: {\n      status: 'up',\n    },\n    redis: {\n      status: 'up',\n    },\n    elasticsearch: {\n      status: 'up',\n    },\n    camunda: {\n      status: 'up',\n    },\n  },\n  error: {},\n  details: {\n    myService: {\n      status: 'up',\n    },\n    typeOrm: {\n      status: 'up',\n    },\n    redis: {\n      status: 'up',\n    },\n    elasticsearch: {\n      status: 'up',\n    },\n    camunda: {\n      status: 'up',\n    },\n  },\n};\n\nconst mockExpectReadinessDown = {\n  myService: {\n    status: 'down',\n    message: 'connect ECONNREFUSED 127.0.0.1:8082',\n  },\n};\n\nconst simpleConfig = {\n  services: {\n    myService: { url: 'http://localhost:8082' },\n  },\n};\n\ndescribe('Health', () => {\n  describe('Ready controller - extend config', () => {\n    let controller: ReadinessController;\n    let health: HealthCheckService;\n    let http: HttpHealthIndicator;\n    let typeOrm: TypeOrmHealthIndicator;\n    let redis: MicroserviceHealthIndicator;\n\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [TerminusModule, HttpModule],\n        controllers: [ReadinessController],\n        providers: [\n          {\n            provide: CONFIG_OPTIONS,\n            useValue: mockedConfig,\n          },\n        ],\n      }).compile();\n\n      controller = module.get<ReadinessController>(ReadinessController);\n      health = await module.resolve<HealthCheckService>(HealthCheckService);\n      http = await module.resolve<HttpHealthIndicator>(HttpHealthIndicator as any);\n      typeOrm = await module.resolve<TypeOrmHealthIndicator>(TypeOrmHealthIndicator);\n      redis = await module.resolve<MicroserviceHealthIndicator>(MicroserviceHealthIndicator);\n    });\n\n    it('should be defined with extend config', () => {\n      expect(controller).toBeDefined();\n    });\n\n    it('should be return up services with extend config', async () => {\n      http.pingCheck = jest.fn().mockImplementation(() => mockExpectReadiness.info);\n      typeOrm.pingCheck = jest.fn().mockImplementation(() => mockExpectReadiness.info);\n      redis.pingCheck = jest.fn().mockImplementation(() => mockExpectReadiness.info);\n      health.check = jest.fn().mockImplementation(() => mockExpectReadiness);\n\n      const readinessData = await controller.check();\n      expect(readinessData).toEqual(mockExpectReadiness);\n    });\n  });\n\n  describe('Ready controller - simple config', () => {\n    let controller: ReadinessController;\n    let health: HealthCheckService;\n    let http: HttpHealthIndicator;\n    let typeOrm: TypeOrmHealthIndicator;\n    let redis: MicroserviceHealthIndicator;\n\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [TerminusModule, HttpModule],\n        controllers: [ReadinessController],\n        providers: [\n          {\n            provide: CONFIG_OPTIONS,\n            useValue: simpleConfig,\n          },\n        ],\n      }).compile();\n\n      controller = module.get<ReadinessController>(ReadinessController);\n      health = await module.resolve<HealthCheckService>(HealthCheckService);\n      http = await module.resolve<HttpHealthIndicator>(HttpHealthIndicator as any);\n      typeOrm = await module.resolve<TypeOrmHealthIndicator>(TypeOrmHealthIndicator);\n      redis = await module.resolve<MicroserviceHealthIndicator>(MicroserviceHealthIndicator);\n    });\n\n    it('should be defined with simple config', () => {\n      expect(controller).toBeDefined();\n    });\n\n    it('should be return up services with simple config', async () => {\n      http.pingCheck = jest.fn().mockImplementation(() => mockExpectReadiness.info);\n      typeOrm.pingCheck = jest.fn().mockImplementation(() => mockExpectReadiness.info);\n      redis.pingCheck = jest.fn().mockImplementation(() => mockExpectReadiness.info);\n      health.check = jest.fn().mockImplementation(() => mockExpectReadiness);\n\n      const readinessData = await controller.check();\n      expect(readinessData).toEqual(mockExpectReadiness);\n    });\n  });\n});\n",
              "err": {},
              "uuid": "6faf44be-0201-4a9b-949d-78f77e75958b",
              "parentUUID": "cb2d6453-56ce-4c60-bd04-f382477fd87a",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "HealthModule > should be define",
              "title": "HealthModule > should be define",
              "timedOut": false,
              "duration": 506,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { INestApplication } from '@nestjs/common';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { ConfigModule } from '@nestjs/config';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\n\nimport { HealthModule } from '../health/health.module';\nimport { LivenessController } from '../health/controllers/liveness.controller';\nimport { ReadinessController } from '../health/controllers/readiness.controller';\n\ndescribe('HealthModule', () => {\n  let app: INestApplication;\n  let livenessController: LivenessController;\n  let readinessController: ReadinessController;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HealthModule,\n      ],\n    }).compile();\n\n    app = module.createNestApplication();\n    livenessController = module.get<LivenessController>(LivenessController);\n    readinessController = module.get<ReadinessController>(ReadinessController);\n    await app.init();\n  });\n\n  afterEach(async () => {\n    await Promise.all([app.close()]);\n  });\n\n  it('should be define', async () => {\n    expect(app).toBeDefined();\n  });\n\n  it('should be return status up', async () => {\n    expect(livenessController.getLiveness()).toEqual({ status: 'up' });\n  });\n\n  it('should be return readiness services', async () => {\n    const result = await readinessController.check();\n    expect(result).toHaveProperty('details');\n    expect(result).toHaveProperty('error');\n    expect(result).toHaveProperty('info');\n    expect(result).toHaveProperty('status');\n  });\n});\n",
              "err": {},
              "uuid": "3d01cbb9-57b1-46a2-a35e-24d78b23aa47",
              "parentUUID": "cb2d6453-56ce-4c60-bd04-f382477fd87a",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "HealthModule > should be return status up",
              "title": "HealthModule > should be return status up",
              "timedOut": false,
              "duration": 13,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { INestApplication } from '@nestjs/common';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { ConfigModule } from '@nestjs/config';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\n\nimport { HealthModule } from '../health/health.module';\nimport { LivenessController } from '../health/controllers/liveness.controller';\nimport { ReadinessController } from '../health/controllers/readiness.controller';\n\ndescribe('HealthModule', () => {\n  let app: INestApplication;\n  let livenessController: LivenessController;\n  let readinessController: ReadinessController;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HealthModule,\n      ],\n    }).compile();\n\n    app = module.createNestApplication();\n    livenessController = module.get<LivenessController>(LivenessController);\n    readinessController = module.get<ReadinessController>(ReadinessController);\n    await app.init();\n  });\n\n  afterEach(async () => {\n    await Promise.all([app.close()]);\n  });\n\n  it('should be define', async () => {\n    expect(app).toBeDefined();\n  });\n\n  it('should be return status up', async () => {\n    expect(livenessController.getLiveness()).toEqual({ status: 'up' });\n  });\n\n  it('should be return readiness services', async () => {\n    const result = await readinessController.check();\n    expect(result).toHaveProperty('details');\n    expect(result).toHaveProperty('error');\n    expect(result).toHaveProperty('info');\n    expect(result).toHaveProperty('status');\n  });\n});\n",
              "err": {},
              "uuid": "aab22efc-38b4-44a4-a650-c7431222cfb6",
              "parentUUID": "cb2d6453-56ce-4c60-bd04-f382477fd87a",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "HealthModule > should be return readiness services",
              "title": "HealthModule > should be return readiness services",
              "timedOut": false,
              "duration": 427,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { INestApplication } from '@nestjs/common';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { ConfigModule } from '@nestjs/config';\nimport { config } from '@tresdoce-nestjs-toolkit/test-utils';\n\nimport { HealthModule } from '../health/health.module';\nimport { LivenessController } from '../health/controllers/liveness.controller';\nimport { ReadinessController } from '../health/controllers/readiness.controller';\n\ndescribe('HealthModule', () => {\n  let app: INestApplication;\n  let livenessController: LivenessController;\n  let readinessController: ReadinessController;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HealthModule,\n      ],\n    }).compile();\n\n    app = module.createNestApplication();\n    livenessController = module.get<LivenessController>(LivenessController);\n    readinessController = module.get<ReadinessController>(ReadinessController);\n    await app.init();\n  });\n\n  afterEach(async () => {\n    await Promise.all([app.close()]);\n  });\n\n  it('should be define', async () => {\n    expect(app).toBeDefined();\n  });\n\n  it('should be return status up', async () => {\n    expect(livenessController.getLiveness()).toEqual({ status: 'up' });\n  });\n\n  it('should be return readiness services', async () => {\n    const result = await readinessController.check();\n    expect(result).toHaveProperty('details');\n    expect(result).toHaveProperty('error');\n    expect(result).toHaveProperty('info');\n    expect(result).toHaveProperty('status');\n  });\n});\n",
              "err": {},
              "uuid": "a5b9b8e7-69f7-4241-9799-476af3bd819c",
              "parentUUID": "cb2d6453-56ce-4c60-bd04-f382477fd87a",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "Health - Live controller > should be defined",
              "title": "Health - Live controller > should be defined",
              "timedOut": false,
              "duration": 10,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { LivenessController } from '../health/controllers/liveness.controller';\n\ndescribe('Health - Live controller', () => {\n  let controller: LivenessController;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      controllers: [LivenessController],\n    }).compile();\n\n    controller = module.get<LivenessController>(LivenessController);\n  });\n\n  it('should be defined', () => {\n    expect(controller).toBeDefined();\n  });\n\n  it('should be return up liveness', () => {\n    expect(controller.getLiveness()).toEqual({ status: 'up' });\n  });\n});\n",
              "err": {},
              "uuid": "e5af7378-76aa-47bd-8e2c-8678f5287c21",
              "parentUUID": "cb2d6453-56ce-4c60-bd04-f382477fd87a",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "Health - Live controller > should be return up liveness",
              "title": "Health - Live controller > should be return up liveness",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { LivenessController } from '../health/controllers/liveness.controller';\n\ndescribe('Health - Live controller', () => {\n  let controller: LivenessController;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      controllers: [LivenessController],\n    }).compile();\n\n    controller = module.get<LivenessController>(LivenessController);\n  });\n\n  it('should be defined', () => {\n    expect(controller).toBeDefined();\n  });\n\n  it('should be return up liveness', () => {\n    expect(controller.getLiveness()).toEqual({ status: 'up' });\n  });\n});\n",
              "err": {},
              "uuid": "2025b2bf-2c75-4001-bcb6-460717141069",
              "parentUUID": "cb2d6453-56ce-4c60-bd04-f382477fd87a",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "healthConstants > should be return exclude to prefix global",
              "title": "healthConstants > should be return exclude to prefix global",
              "timedOut": false,
              "duration": 3,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { RequestMethod } from '@nestjs/common';\nimport { controllersExcludes } from '../health/constants';\n\ndescribe('healthConstants', () => {\n  it('should be return exclude to prefix global', async () => {\n    expect(controllersExcludes).toEqual(expect.any(Array));\n    expect(controllersExcludes).toMatchObject([\n      {\n        path: '/health/liveness',\n        method: RequestMethod.GET,\n      },\n      {\n        path: '/health/readiness',\n        method: RequestMethod.GET,\n      },\n    ]);\n  });\n});\n",
              "err": {},
              "uuid": "40b4bc7a-027b-48a1-a38b-4e443d63702c",
              "parentUUID": "cb2d6453-56ce-4c60-bd04-f382477fd87a",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "e16002b4-8452-459d-bc34-c8de7786309a",
            "f98ed6d1-8348-468b-ae68-4c067c8d1ac3",
            "3eb85d7b-dc99-4629-b52d-b8c6c9733284",
            "6faf44be-0201-4a9b-949d-78f77e75958b",
            "3d01cbb9-57b1-46a2-a35e-24d78b23aa47",
            "aab22efc-38b4-44a4-a650-c7431222cfb6",
            "a5b9b8e7-69f7-4241-9799-476af3bd819c",
            "e5af7378-76aa-47bd-8e2c-8678f5287c21",
            "2025b2bf-2c75-4001-bcb6-460717141069",
            "40b4bc7a-027b-48a1-a38b-4e443d63702c"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 1739,
          "root": false,
          "rootEmpty": false,
          "_timeout": 5000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 5000
    },
    {
      "uuid": "10759335-075c-4edf-b9d1-64775e32ed88",
      "title": "@tresdoce-nestjs-toolkit/http-client",
      "fullFile": "",
      "file": "",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "e4e47e1f-5a40-4eb8-851c-7904e9c78814",
          "title": "@tresdoce-nestjs-toolkit/http-client",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "fullTitle": "HttpService > should be defined",
              "title": "HttpService > should be defined",
              "timedOut": false,
              "duration": 229,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { INestApplication } from '@nestjs/common';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { ConfigModule, ConfigService } from '@nestjs/config';\n\nimport { HttpClientService } from '../http/services/httpClient.service';\nimport { HttpClientModule } from '../http/httpClient.module';\nimport { config } from './utils';\n\nconst API_NESTJS_STARTER = 'https://jsonplaceholder.typicode.com';\n\nconst mockRequestBody = {\n  userId: 1,\n  id: 1,\n  title: 'sunt aut facere repellat provident occaecati excepturi optio reprehenderit',\n  body: 'quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto',\n};\n\ndescribe('HttpService', () => {\n  let app: INestApplication;\n  let service: HttpClientService;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HttpClientModule.registerAsync({\n          imports: [ConfigModule],\n          useFactory: async (configService: ConfigService) =>\n            configService.get('config.httpOptions'),\n          inject: [ConfigService],\n        }),\n      ],\n    }).compile();\n    app = module.createNestApplication();\n    await app.init;\n    service = module.get<HttpClientService>(HttpClientService);\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', () => {\n    expect(service).toBeDefined();\n    expect(service).toBeInstanceOf(HttpClientService);\n    expect(service.axiosRef).not.toBeNull();\n  });\n\n  it('should be return status 200 - request', async () => {\n    const { status, data } = await service.request({\n      url: `${API_NESTJS_STARTER}/posts`,\n      method: 'GET',\n    });\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it('should be return status 200 - get', async () => {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it('should be return status 201 - post', async () => {\n    const { status, data } = await service.post(`${API_NESTJS_STARTER}/posts`, {\n      data: mockRequestBody,\n    });\n    expect(status).toBe(201);\n    expect(data).toEqual({\n      ...mockRequestBody,\n      id: 101,\n    });\n  });\n\n  it('should be return status 200 - get by id', async () => {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts/1`);\n    expect(status).toBe(200);\n    expect(data).toEqual(mockRequestBody);\n  });\n\n  it('should be return status 200 - put', async () => {\n    const { status, data } = await service.put(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: 'mockito',\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: 'mockito' });\n  });\n\n  it('should be return status 200 - delete', async () => {\n    const { status, data } = await service.delete(`${API_NESTJS_STARTER}/posts/2`);\n    expect(status).toBe(200);\n    expect(data).toEqual({});\n  });\n\n  it('should be return status 200 - patch', async () => {\n    const { status, data } = await service.patch(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: 'mockito',\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: 'mockito' });\n  });\n\n  it('should be return status 200 - head', async () => {\n    const { status, headers } = await service.head(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(headers).toHaveProperty('etag');\n  });\n\n  it('should be return error', async () => {\n    try {\n      const { data } = await service.get(`${API_NESTJS_STARTER}/postss`);\n      expect(data).toBe(200);\n    } catch (error) {\n      expect(error.response.status).toBe(404);\n      expect(error.message).toBe('Request failed with status code 404');\n    }\n  });\n});\n",
              "err": {},
              "uuid": "01392ef8-c46d-416e-8b14-8b488a37891b",
              "parentUUID": "e4e47e1f-5a40-4eb8-851c-7904e9c78814",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "HttpService > should be return status 200 - request",
              "title": "HttpService > should be return status 200 - request",
              "timedOut": false,
              "duration": 328,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { INestApplication } from '@nestjs/common';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { ConfigModule, ConfigService } from '@nestjs/config';\n\nimport { HttpClientService } from '../http/services/httpClient.service';\nimport { HttpClientModule } from '../http/httpClient.module';\nimport { config } from './utils';\n\nconst API_NESTJS_STARTER = 'https://jsonplaceholder.typicode.com';\n\nconst mockRequestBody = {\n  userId: 1,\n  id: 1,\n  title: 'sunt aut facere repellat provident occaecati excepturi optio reprehenderit',\n  body: 'quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto',\n};\n\ndescribe('HttpService', () => {\n  let app: INestApplication;\n  let service: HttpClientService;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HttpClientModule.registerAsync({\n          imports: [ConfigModule],\n          useFactory: async (configService: ConfigService) =>\n            configService.get('config.httpOptions'),\n          inject: [ConfigService],\n        }),\n      ],\n    }).compile();\n    app = module.createNestApplication();\n    await app.init;\n    service = module.get<HttpClientService>(HttpClientService);\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', () => {\n    expect(service).toBeDefined();\n    expect(service).toBeInstanceOf(HttpClientService);\n    expect(service.axiosRef).not.toBeNull();\n  });\n\n  it('should be return status 200 - request', async () => {\n    const { status, data } = await service.request({\n      url: `${API_NESTJS_STARTER}/posts`,\n      method: 'GET',\n    });\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it('should be return status 200 - get', async () => {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it('should be return status 201 - post', async () => {\n    const { status, data } = await service.post(`${API_NESTJS_STARTER}/posts`, {\n      data: mockRequestBody,\n    });\n    expect(status).toBe(201);\n    expect(data).toEqual({\n      ...mockRequestBody,\n      id: 101,\n    });\n  });\n\n  it('should be return status 200 - get by id', async () => {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts/1`);\n    expect(status).toBe(200);\n    expect(data).toEqual(mockRequestBody);\n  });\n\n  it('should be return status 200 - put', async () => {\n    const { status, data } = await service.put(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: 'mockito',\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: 'mockito' });\n  });\n\n  it('should be return status 200 - delete', async () => {\n    const { status, data } = await service.delete(`${API_NESTJS_STARTER}/posts/2`);\n    expect(status).toBe(200);\n    expect(data).toEqual({});\n  });\n\n  it('should be return status 200 - patch', async () => {\n    const { status, data } = await service.patch(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: 'mockito',\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: 'mockito' });\n  });\n\n  it('should be return status 200 - head', async () => {\n    const { status, headers } = await service.head(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(headers).toHaveProperty('etag');\n  });\n\n  it('should be return error', async () => {\n    try {\n      const { data } = await service.get(`${API_NESTJS_STARTER}/postss`);\n      expect(data).toBe(200);\n    } catch (error) {\n      expect(error.response.status).toBe(404);\n      expect(error.message).toBe('Request failed with status code 404');\n    }\n  });\n});\n",
              "err": {},
              "uuid": "e15cdea4-97a4-4baf-9b9b-cf0cd24b13df",
              "parentUUID": "e4e47e1f-5a40-4eb8-851c-7904e9c78814",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "HttpService > should be return status 200 - get",
              "title": "HttpService > should be return status 200 - get",
              "timedOut": false,
              "duration": 94,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { INestApplication } from '@nestjs/common';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { ConfigModule, ConfigService } from '@nestjs/config';\n\nimport { HttpClientService } from '../http/services/httpClient.service';\nimport { HttpClientModule } from '../http/httpClient.module';\nimport { config } from './utils';\n\nconst API_NESTJS_STARTER = 'https://jsonplaceholder.typicode.com';\n\nconst mockRequestBody = {\n  userId: 1,\n  id: 1,\n  title: 'sunt aut facere repellat provident occaecati excepturi optio reprehenderit',\n  body: 'quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto',\n};\n\ndescribe('HttpService', () => {\n  let app: INestApplication;\n  let service: HttpClientService;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HttpClientModule.registerAsync({\n          imports: [ConfigModule],\n          useFactory: async (configService: ConfigService) =>\n            configService.get('config.httpOptions'),\n          inject: [ConfigService],\n        }),\n      ],\n    }).compile();\n    app = module.createNestApplication();\n    await app.init;\n    service = module.get<HttpClientService>(HttpClientService);\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', () => {\n    expect(service).toBeDefined();\n    expect(service).toBeInstanceOf(HttpClientService);\n    expect(service.axiosRef).not.toBeNull();\n  });\n\n  it('should be return status 200 - request', async () => {\n    const { status, data } = await service.request({\n      url: `${API_NESTJS_STARTER}/posts`,\n      method: 'GET',\n    });\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it('should be return status 200 - get', async () => {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it('should be return status 201 - post', async () => {\n    const { status, data } = await service.post(`${API_NESTJS_STARTER}/posts`, {\n      data: mockRequestBody,\n    });\n    expect(status).toBe(201);\n    expect(data).toEqual({\n      ...mockRequestBody,\n      id: 101,\n    });\n  });\n\n  it('should be return status 200 - get by id', async () => {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts/1`);\n    expect(status).toBe(200);\n    expect(data).toEqual(mockRequestBody);\n  });\n\n  it('should be return status 200 - put', async () => {\n    const { status, data } = await service.put(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: 'mockito',\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: 'mockito' });\n  });\n\n  it('should be return status 200 - delete', async () => {\n    const { status, data } = await service.delete(`${API_NESTJS_STARTER}/posts/2`);\n    expect(status).toBe(200);\n    expect(data).toEqual({});\n  });\n\n  it('should be return status 200 - patch', async () => {\n    const { status, data } = await service.patch(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: 'mockito',\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: 'mockito' });\n  });\n\n  it('should be return status 200 - head', async () => {\n    const { status, headers } = await service.head(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(headers).toHaveProperty('etag');\n  });\n\n  it('should be return error', async () => {\n    try {\n      const { data } = await service.get(`${API_NESTJS_STARTER}/postss`);\n      expect(data).toBe(200);\n    } catch (error) {\n      expect(error.response.status).toBe(404);\n      expect(error.message).toBe('Request failed with status code 404');\n    }\n  });\n});\n",
              "err": {},
              "uuid": "c4d6a6c7-e872-4647-b4f1-90aacb1421fd",
              "parentUUID": "e4e47e1f-5a40-4eb8-851c-7904e9c78814",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "HttpService > should be return status 201 - post",
              "title": "HttpService > should be return status 201 - post",
              "timedOut": false,
              "duration": 420,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { INestApplication } from '@nestjs/common';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { ConfigModule, ConfigService } from '@nestjs/config';\n\nimport { HttpClientService } from '../http/services/httpClient.service';\nimport { HttpClientModule } from '../http/httpClient.module';\nimport { config } from './utils';\n\nconst API_NESTJS_STARTER = 'https://jsonplaceholder.typicode.com';\n\nconst mockRequestBody = {\n  userId: 1,\n  id: 1,\n  title: 'sunt aut facere repellat provident occaecati excepturi optio reprehenderit',\n  body: 'quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto',\n};\n\ndescribe('HttpService', () => {\n  let app: INestApplication;\n  let service: HttpClientService;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HttpClientModule.registerAsync({\n          imports: [ConfigModule],\n          useFactory: async (configService: ConfigService) =>\n            configService.get('config.httpOptions'),\n          inject: [ConfigService],\n        }),\n      ],\n    }).compile();\n    app = module.createNestApplication();\n    await app.init;\n    service = module.get<HttpClientService>(HttpClientService);\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', () => {\n    expect(service).toBeDefined();\n    expect(service).toBeInstanceOf(HttpClientService);\n    expect(service.axiosRef).not.toBeNull();\n  });\n\n  it('should be return status 200 - request', async () => {\n    const { status, data } = await service.request({\n      url: `${API_NESTJS_STARTER}/posts`,\n      method: 'GET',\n    });\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it('should be return status 200 - get', async () => {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it('should be return status 201 - post', async () => {\n    const { status, data } = await service.post(`${API_NESTJS_STARTER}/posts`, {\n      data: mockRequestBody,\n    });\n    expect(status).toBe(201);\n    expect(data).toEqual({\n      ...mockRequestBody,\n      id: 101,\n    });\n  });\n\n  it('should be return status 200 - get by id', async () => {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts/1`);\n    expect(status).toBe(200);\n    expect(data).toEqual(mockRequestBody);\n  });\n\n  it('should be return status 200 - put', async () => {\n    const { status, data } = await service.put(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: 'mockito',\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: 'mockito' });\n  });\n\n  it('should be return status 200 - delete', async () => {\n    const { status, data } = await service.delete(`${API_NESTJS_STARTER}/posts/2`);\n    expect(status).toBe(200);\n    expect(data).toEqual({});\n  });\n\n  it('should be return status 200 - patch', async () => {\n    const { status, data } = await service.patch(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: 'mockito',\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: 'mockito' });\n  });\n\n  it('should be return status 200 - head', async () => {\n    const { status, headers } = await service.head(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(headers).toHaveProperty('etag');\n  });\n\n  it('should be return error', async () => {\n    try {\n      const { data } = await service.get(`${API_NESTJS_STARTER}/postss`);\n      expect(data).toBe(200);\n    } catch (error) {\n      expect(error.response.status).toBe(404);\n      expect(error.message).toBe('Request failed with status code 404');\n    }\n  });\n});\n",
              "err": {},
              "uuid": "a85e5925-a1d7-4537-9f67-78b1b6f4a9cf",
              "parentUUID": "e4e47e1f-5a40-4eb8-851c-7904e9c78814",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "HttpService > should be return status 200 - get by id",
              "title": "HttpService > should be return status 200 - get by id",
              "timedOut": false,
              "duration": 75,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { INestApplication } from '@nestjs/common';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { ConfigModule, ConfigService } from '@nestjs/config';\n\nimport { HttpClientService } from '../http/services/httpClient.service';\nimport { HttpClientModule } from '../http/httpClient.module';\nimport { config } from './utils';\n\nconst API_NESTJS_STARTER = 'https://jsonplaceholder.typicode.com';\n\nconst mockRequestBody = {\n  userId: 1,\n  id: 1,\n  title: 'sunt aut facere repellat provident occaecati excepturi optio reprehenderit',\n  body: 'quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto',\n};\n\ndescribe('HttpService', () => {\n  let app: INestApplication;\n  let service: HttpClientService;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HttpClientModule.registerAsync({\n          imports: [ConfigModule],\n          useFactory: async (configService: ConfigService) =>\n            configService.get('config.httpOptions'),\n          inject: [ConfigService],\n        }),\n      ],\n    }).compile();\n    app = module.createNestApplication();\n    await app.init;\n    service = module.get<HttpClientService>(HttpClientService);\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', () => {\n    expect(service).toBeDefined();\n    expect(service).toBeInstanceOf(HttpClientService);\n    expect(service.axiosRef).not.toBeNull();\n  });\n\n  it('should be return status 200 - request', async () => {\n    const { status, data } = await service.request({\n      url: `${API_NESTJS_STARTER}/posts`,\n      method: 'GET',\n    });\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it('should be return status 200 - get', async () => {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it('should be return status 201 - post', async () => {\n    const { status, data } = await service.post(`${API_NESTJS_STARTER}/posts`, {\n      data: mockRequestBody,\n    });\n    expect(status).toBe(201);\n    expect(data).toEqual({\n      ...mockRequestBody,\n      id: 101,\n    });\n  });\n\n  it('should be return status 200 - get by id', async () => {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts/1`);\n    expect(status).toBe(200);\n    expect(data).toEqual(mockRequestBody);\n  });\n\n  it('should be return status 200 - put', async () => {\n    const { status, data } = await service.put(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: 'mockito',\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: 'mockito' });\n  });\n\n  it('should be return status 200 - delete', async () => {\n    const { status, data } = await service.delete(`${API_NESTJS_STARTER}/posts/2`);\n    expect(status).toBe(200);\n    expect(data).toEqual({});\n  });\n\n  it('should be return status 200 - patch', async () => {\n    const { status, data } = await service.patch(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: 'mockito',\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: 'mockito' });\n  });\n\n  it('should be return status 200 - head', async () => {\n    const { status, headers } = await service.head(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(headers).toHaveProperty('etag');\n  });\n\n  it('should be return error', async () => {\n    try {\n      const { data } = await service.get(`${API_NESTJS_STARTER}/postss`);\n      expect(data).toBe(200);\n    } catch (error) {\n      expect(error.response.status).toBe(404);\n      expect(error.message).toBe('Request failed with status code 404');\n    }\n  });\n});\n",
              "err": {},
              "uuid": "cda2ffb3-7d7a-4bba-935a-aebf0151fac8",
              "parentUUID": "e4e47e1f-5a40-4eb8-851c-7904e9c78814",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "HttpService > should be return status 200 - put",
              "title": "HttpService > should be return status 200 - put",
              "timedOut": false,
              "duration": 426,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { INestApplication } from '@nestjs/common';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { ConfigModule, ConfigService } from '@nestjs/config';\n\nimport { HttpClientService } from '../http/services/httpClient.service';\nimport { HttpClientModule } from '../http/httpClient.module';\nimport { config } from './utils';\n\nconst API_NESTJS_STARTER = 'https://jsonplaceholder.typicode.com';\n\nconst mockRequestBody = {\n  userId: 1,\n  id: 1,\n  title: 'sunt aut facere repellat provident occaecati excepturi optio reprehenderit',\n  body: 'quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto',\n};\n\ndescribe('HttpService', () => {\n  let app: INestApplication;\n  let service: HttpClientService;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HttpClientModule.registerAsync({\n          imports: [ConfigModule],\n          useFactory: async (configService: ConfigService) =>\n            configService.get('config.httpOptions'),\n          inject: [ConfigService],\n        }),\n      ],\n    }).compile();\n    app = module.createNestApplication();\n    await app.init;\n    service = module.get<HttpClientService>(HttpClientService);\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', () => {\n    expect(service).toBeDefined();\n    expect(service).toBeInstanceOf(HttpClientService);\n    expect(service.axiosRef).not.toBeNull();\n  });\n\n  it('should be return status 200 - request', async () => {\n    const { status, data } = await service.request({\n      url: `${API_NESTJS_STARTER}/posts`,\n      method: 'GET',\n    });\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it('should be return status 200 - get', async () => {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it('should be return status 201 - post', async () => {\n    const { status, data } = await service.post(`${API_NESTJS_STARTER}/posts`, {\n      data: mockRequestBody,\n    });\n    expect(status).toBe(201);\n    expect(data).toEqual({\n      ...mockRequestBody,\n      id: 101,\n    });\n  });\n\n  it('should be return status 200 - get by id', async () => {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts/1`);\n    expect(status).toBe(200);\n    expect(data).toEqual(mockRequestBody);\n  });\n\n  it('should be return status 200 - put', async () => {\n    const { status, data } = await service.put(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: 'mockito',\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: 'mockito' });\n  });\n\n  it('should be return status 200 - delete', async () => {\n    const { status, data } = await service.delete(`${API_NESTJS_STARTER}/posts/2`);\n    expect(status).toBe(200);\n    expect(data).toEqual({});\n  });\n\n  it('should be return status 200 - patch', async () => {\n    const { status, data } = await service.patch(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: 'mockito',\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: 'mockito' });\n  });\n\n  it('should be return status 200 - head', async () => {\n    const { status, headers } = await service.head(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(headers).toHaveProperty('etag');\n  });\n\n  it('should be return error', async () => {\n    try {\n      const { data } = await service.get(`${API_NESTJS_STARTER}/postss`);\n      expect(data).toBe(200);\n    } catch (error) {\n      expect(error.response.status).toBe(404);\n      expect(error.message).toBe('Request failed with status code 404');\n    }\n  });\n});\n",
              "err": {},
              "uuid": "a988cb86-970c-49e0-b911-1b5f569dc634",
              "parentUUID": "e4e47e1f-5a40-4eb8-851c-7904e9c78814",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "HttpService > should be return status 200 - delete",
              "title": "HttpService > should be return status 200 - delete",
              "timedOut": false,
              "duration": 424,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { INestApplication } from '@nestjs/common';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { ConfigModule, ConfigService } from '@nestjs/config';\n\nimport { HttpClientService } from '../http/services/httpClient.service';\nimport { HttpClientModule } from '../http/httpClient.module';\nimport { config } from './utils';\n\nconst API_NESTJS_STARTER = 'https://jsonplaceholder.typicode.com';\n\nconst mockRequestBody = {\n  userId: 1,\n  id: 1,\n  title: 'sunt aut facere repellat provident occaecati excepturi optio reprehenderit',\n  body: 'quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto',\n};\n\ndescribe('HttpService', () => {\n  let app: INestApplication;\n  let service: HttpClientService;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HttpClientModule.registerAsync({\n          imports: [ConfigModule],\n          useFactory: async (configService: ConfigService) =>\n            configService.get('config.httpOptions'),\n          inject: [ConfigService],\n        }),\n      ],\n    }).compile();\n    app = module.createNestApplication();\n    await app.init;\n    service = module.get<HttpClientService>(HttpClientService);\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', () => {\n    expect(service).toBeDefined();\n    expect(service).toBeInstanceOf(HttpClientService);\n    expect(service.axiosRef).not.toBeNull();\n  });\n\n  it('should be return status 200 - request', async () => {\n    const { status, data } = await service.request({\n      url: `${API_NESTJS_STARTER}/posts`,\n      method: 'GET',\n    });\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it('should be return status 200 - get', async () => {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it('should be return status 201 - post', async () => {\n    const { status, data } = await service.post(`${API_NESTJS_STARTER}/posts`, {\n      data: mockRequestBody,\n    });\n    expect(status).toBe(201);\n    expect(data).toEqual({\n      ...mockRequestBody,\n      id: 101,\n    });\n  });\n\n  it('should be return status 200 - get by id', async () => {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts/1`);\n    expect(status).toBe(200);\n    expect(data).toEqual(mockRequestBody);\n  });\n\n  it('should be return status 200 - put', async () => {\n    const { status, data } = await service.put(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: 'mockito',\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: 'mockito' });\n  });\n\n  it('should be return status 200 - delete', async () => {\n    const { status, data } = await service.delete(`${API_NESTJS_STARTER}/posts/2`);\n    expect(status).toBe(200);\n    expect(data).toEqual({});\n  });\n\n  it('should be return status 200 - patch', async () => {\n    const { status, data } = await service.patch(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: 'mockito',\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: 'mockito' });\n  });\n\n  it('should be return status 200 - head', async () => {\n    const { status, headers } = await service.head(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(headers).toHaveProperty('etag');\n  });\n\n  it('should be return error', async () => {\n    try {\n      const { data } = await service.get(`${API_NESTJS_STARTER}/postss`);\n      expect(data).toBe(200);\n    } catch (error) {\n      expect(error.response.status).toBe(404);\n      expect(error.message).toBe('Request failed with status code 404');\n    }\n  });\n});\n",
              "err": {},
              "uuid": "8a13c851-7d44-4d50-bd09-f3f5093a8063",
              "parentUUID": "e4e47e1f-5a40-4eb8-851c-7904e9c78814",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "HttpService > should be return status 200 - patch",
              "title": "HttpService > should be return status 200 - patch",
              "timedOut": false,
              "duration": 644,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { INestApplication } from '@nestjs/common';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { ConfigModule, ConfigService } from '@nestjs/config';\n\nimport { HttpClientService } from '../http/services/httpClient.service';\nimport { HttpClientModule } from '../http/httpClient.module';\nimport { config } from './utils';\n\nconst API_NESTJS_STARTER = 'https://jsonplaceholder.typicode.com';\n\nconst mockRequestBody = {\n  userId: 1,\n  id: 1,\n  title: 'sunt aut facere repellat provident occaecati excepturi optio reprehenderit',\n  body: 'quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto',\n};\n\ndescribe('HttpService', () => {\n  let app: INestApplication;\n  let service: HttpClientService;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HttpClientModule.registerAsync({\n          imports: [ConfigModule],\n          useFactory: async (configService: ConfigService) =>\n            configService.get('config.httpOptions'),\n          inject: [ConfigService],\n        }),\n      ],\n    }).compile();\n    app = module.createNestApplication();\n    await app.init;\n    service = module.get<HttpClientService>(HttpClientService);\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', () => {\n    expect(service).toBeDefined();\n    expect(service).toBeInstanceOf(HttpClientService);\n    expect(service.axiosRef).not.toBeNull();\n  });\n\n  it('should be return status 200 - request', async () => {\n    const { status, data } = await service.request({\n      url: `${API_NESTJS_STARTER}/posts`,\n      method: 'GET',\n    });\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it('should be return status 200 - get', async () => {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it('should be return status 201 - post', async () => {\n    const { status, data } = await service.post(`${API_NESTJS_STARTER}/posts`, {\n      data: mockRequestBody,\n    });\n    expect(status).toBe(201);\n    expect(data).toEqual({\n      ...mockRequestBody,\n      id: 101,\n    });\n  });\n\n  it('should be return status 200 - get by id', async () => {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts/1`);\n    expect(status).toBe(200);\n    expect(data).toEqual(mockRequestBody);\n  });\n\n  it('should be return status 200 - put', async () => {\n    const { status, data } = await service.put(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: 'mockito',\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: 'mockito' });\n  });\n\n  it('should be return status 200 - delete', async () => {\n    const { status, data } = await service.delete(`${API_NESTJS_STARTER}/posts/2`);\n    expect(status).toBe(200);\n    expect(data).toEqual({});\n  });\n\n  it('should be return status 200 - patch', async () => {\n    const { status, data } = await service.patch(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: 'mockito',\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: 'mockito' });\n  });\n\n  it('should be return status 200 - head', async () => {\n    const { status, headers } = await service.head(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(headers).toHaveProperty('etag');\n  });\n\n  it('should be return error', async () => {\n    try {\n      const { data } = await service.get(`${API_NESTJS_STARTER}/postss`);\n      expect(data).toBe(200);\n    } catch (error) {\n      expect(error.response.status).toBe(404);\n      expect(error.message).toBe('Request failed with status code 404');\n    }\n  });\n});\n",
              "err": {},
              "uuid": "9aeecf01-166e-42b6-8087-dffad821d978",
              "parentUUID": "e4e47e1f-5a40-4eb8-851c-7904e9c78814",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "HttpService > should be return status 200 - head",
              "title": "HttpService > should be return status 200 - head",
              "timedOut": false,
              "duration": 81,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { INestApplication } from '@nestjs/common';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { ConfigModule, ConfigService } from '@nestjs/config';\n\nimport { HttpClientService } from '../http/services/httpClient.service';\nimport { HttpClientModule } from '../http/httpClient.module';\nimport { config } from './utils';\n\nconst API_NESTJS_STARTER = 'https://jsonplaceholder.typicode.com';\n\nconst mockRequestBody = {\n  userId: 1,\n  id: 1,\n  title: 'sunt aut facere repellat provident occaecati excepturi optio reprehenderit',\n  body: 'quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto',\n};\n\ndescribe('HttpService', () => {\n  let app: INestApplication;\n  let service: HttpClientService;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HttpClientModule.registerAsync({\n          imports: [ConfigModule],\n          useFactory: async (configService: ConfigService) =>\n            configService.get('config.httpOptions'),\n          inject: [ConfigService],\n        }),\n      ],\n    }).compile();\n    app = module.createNestApplication();\n    await app.init;\n    service = module.get<HttpClientService>(HttpClientService);\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', () => {\n    expect(service).toBeDefined();\n    expect(service).toBeInstanceOf(HttpClientService);\n    expect(service.axiosRef).not.toBeNull();\n  });\n\n  it('should be return status 200 - request', async () => {\n    const { status, data } = await service.request({\n      url: `${API_NESTJS_STARTER}/posts`,\n      method: 'GET',\n    });\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it('should be return status 200 - get', async () => {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it('should be return status 201 - post', async () => {\n    const { status, data } = await service.post(`${API_NESTJS_STARTER}/posts`, {\n      data: mockRequestBody,\n    });\n    expect(status).toBe(201);\n    expect(data).toEqual({\n      ...mockRequestBody,\n      id: 101,\n    });\n  });\n\n  it('should be return status 200 - get by id', async () => {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts/1`);\n    expect(status).toBe(200);\n    expect(data).toEqual(mockRequestBody);\n  });\n\n  it('should be return status 200 - put', async () => {\n    const { status, data } = await service.put(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: 'mockito',\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: 'mockito' });\n  });\n\n  it('should be return status 200 - delete', async () => {\n    const { status, data } = await service.delete(`${API_NESTJS_STARTER}/posts/2`);\n    expect(status).toBe(200);\n    expect(data).toEqual({});\n  });\n\n  it('should be return status 200 - patch', async () => {\n    const { status, data } = await service.patch(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: 'mockito',\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: 'mockito' });\n  });\n\n  it('should be return status 200 - head', async () => {\n    const { status, headers } = await service.head(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(headers).toHaveProperty('etag');\n  });\n\n  it('should be return error', async () => {\n    try {\n      const { data } = await service.get(`${API_NESTJS_STARTER}/postss`);\n      expect(data).toBe(200);\n    } catch (error) {\n      expect(error.response.status).toBe(404);\n      expect(error.message).toBe('Request failed with status code 404');\n    }\n  });\n});\n",
              "err": {},
              "uuid": "6892fae6-80a8-4cee-998e-4f0a2615acdf",
              "parentUUID": "e4e47e1f-5a40-4eb8-851c-7904e9c78814",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "HttpService > should be return error",
              "title": "HttpService > should be return error",
              "timedOut": false,
              "duration": 441,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { INestApplication } from '@nestjs/common';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { ConfigModule, ConfigService } from '@nestjs/config';\n\nimport { HttpClientService } from '../http/services/httpClient.service';\nimport { HttpClientModule } from '../http/httpClient.module';\nimport { config } from './utils';\n\nconst API_NESTJS_STARTER = 'https://jsonplaceholder.typicode.com';\n\nconst mockRequestBody = {\n  userId: 1,\n  id: 1,\n  title: 'sunt aut facere repellat provident occaecati excepturi optio reprehenderit',\n  body: 'quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto',\n};\n\ndescribe('HttpService', () => {\n  let app: INestApplication;\n  let service: HttpClientService;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HttpClientModule.registerAsync({\n          imports: [ConfigModule],\n          useFactory: async (configService: ConfigService) =>\n            configService.get('config.httpOptions'),\n          inject: [ConfigService],\n        }),\n      ],\n    }).compile();\n    app = module.createNestApplication();\n    await app.init;\n    service = module.get<HttpClientService>(HttpClientService);\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', () => {\n    expect(service).toBeDefined();\n    expect(service).toBeInstanceOf(HttpClientService);\n    expect(service.axiosRef).not.toBeNull();\n  });\n\n  it('should be return status 200 - request', async () => {\n    const { status, data } = await service.request({\n      url: `${API_NESTJS_STARTER}/posts`,\n      method: 'GET',\n    });\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it('should be return status 200 - get', async () => {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(data.length).toBeGreaterThan(0);\n  });\n\n  it('should be return status 201 - post', async () => {\n    const { status, data } = await service.post(`${API_NESTJS_STARTER}/posts`, {\n      data: mockRequestBody,\n    });\n    expect(status).toBe(201);\n    expect(data).toEqual({\n      ...mockRequestBody,\n      id: 101,\n    });\n  });\n\n  it('should be return status 200 - get by id', async () => {\n    const { status, data } = await service.get(`${API_NESTJS_STARTER}/posts/1`);\n    expect(status).toBe(200);\n    expect(data).toEqual(mockRequestBody);\n  });\n\n  it('should be return status 200 - put', async () => {\n    const { status, data } = await service.put(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: 'mockito',\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: 'mockito' });\n  });\n\n  it('should be return status 200 - delete', async () => {\n    const { status, data } = await service.delete(`${API_NESTJS_STARTER}/posts/2`);\n    expect(status).toBe(200);\n    expect(data).toEqual({});\n  });\n\n  it('should be return status 200 - patch', async () => {\n    const { status, data } = await service.patch(`${API_NESTJS_STARTER}/posts/1`, {\n      data: {\n        ...mockRequestBody,\n        title: 'mockito',\n      },\n    });\n    expect(status).toBe(200);\n    expect(data).toEqual({ ...mockRequestBody, id: 1, title: 'mockito' });\n  });\n\n  it('should be return status 200 - head', async () => {\n    const { status, headers } = await service.head(`${API_NESTJS_STARTER}/posts`);\n    expect(status).toBe(200);\n    expect(headers).toHaveProperty('etag');\n  });\n\n  it('should be return error', async () => {\n    try {\n      const { data } = await service.get(`${API_NESTJS_STARTER}/postss`);\n      expect(data).toBe(200);\n    } catch (error) {\n      expect(error.response.status).toBe(404);\n      expect(error.message).toBe('Request failed with status code 404');\n    }\n  });\n});\n",
              "err": {},
              "uuid": "da246b4d-93fb-4db3-84b6-513164062dc7",
              "parentUUID": "e4e47e1f-5a40-4eb8-851c-7904e9c78814",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "HttpInterceptor > should be defined",
              "title": "HttpInterceptor > should be defined",
              "timedOut": false,
              "duration": 75,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { INestApplication } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\n\nimport { HttpClientService } from '../http/services/httpClient.service';\nimport { HttpClientInterceptor } from '../http/interceptors/httpClient.interceptor';\nimport { HttpClientModule } from '../http/httpClient.module';\nimport { config } from './utils';\n\nconst executionContext: any = {\n  switchToHttp: jest.fn().mockReturnThis(),\n  getRequest: jest.fn().mockReturnThis(),\n  getResponse: jest.fn().mockReturnThis(),\n};\n\nconst callHandler: any = {\n  handle: jest.fn(),\n};\n\ndescribe('HttpInterceptor', () => {\n  let app: INestApplication;\n  let service: HttpClientService;\n  let interceptor: HttpClientInterceptor<any>;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HttpClientModule,\n      ],\n    }).compile();\n    app = module.createNestApplication();\n    await app.init;\n\n    service = module.get<HttpClientService>(HttpClientService);\n    interceptor = new HttpClientInterceptor(service);\n  });\n\n  it('should be defined', () => {\n    expect(interceptor).toBeDefined();\n  });\n\n  it('should be intercept and pass headers', async () => {\n    await interceptor.intercept(executionContext, callHandler);\n    expect(callHandler.handle).toBeCalledTimes(1);\n  });\n});\n",
              "err": {},
              "uuid": "6beb7206-8573-4edf-b6ee-dc8d2a273aaa",
              "parentUUID": "e4e47e1f-5a40-4eb8-851c-7904e9c78814",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "HttpInterceptor > should be intercept and pass headers",
              "title": "HttpInterceptor > should be intercept and pass headers",
              "timedOut": false,
              "duration": 4,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { INestApplication } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\n\nimport { HttpClientService } from '../http/services/httpClient.service';\nimport { HttpClientInterceptor } from '../http/interceptors/httpClient.interceptor';\nimport { HttpClientModule } from '../http/httpClient.module';\nimport { config } from './utils';\n\nconst executionContext: any = {\n  switchToHttp: jest.fn().mockReturnThis(),\n  getRequest: jest.fn().mockReturnThis(),\n  getResponse: jest.fn().mockReturnThis(),\n};\n\nconst callHandler: any = {\n  handle: jest.fn(),\n};\n\ndescribe('HttpInterceptor', () => {\n  let app: INestApplication;\n  let service: HttpClientService;\n  let interceptor: HttpClientInterceptor<any>;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          isGlobal: true,\n          load: [config],\n        }),\n        HttpClientModule,\n      ],\n    }).compile();\n    app = module.createNestApplication();\n    await app.init;\n\n    service = module.get<HttpClientService>(HttpClientService);\n    interceptor = new HttpClientInterceptor(service);\n  });\n\n  it('should be defined', () => {\n    expect(interceptor).toBeDefined();\n  });\n\n  it('should be intercept and pass headers', async () => {\n    await interceptor.intercept(executionContext, callHandler);\n    expect(callHandler.handle).toBeCalledTimes(1);\n  });\n});\n",
              "err": {},
              "uuid": "e9c0a462-5343-4a9a-8376-91df74402bea",
              "parentUUID": "e4e47e1f-5a40-4eb8-851c-7904e9c78814",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "HttpModule > registerAsync useFactory > should be define",
              "title": "HttpModule > registerAsync useFactory > should be define",
              "timedOut": false,
              "duration": 78,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { INestApplication } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\n\nimport { HttpClientModule } from '../http/httpClient.module';\nimport { config } from './utils';\nimport { HttpModuleAsyncOptions } from '../http/interfaces/http-module.interface';\n\nclass MockedClass {\n  createHttpOptions() {\n    return {\n      timeout: 5000,\n      maxRedirects: 5,\n    };\n  }\n}\n\ndescribe('HttpModule', () => {\n  const mockedUseFactory: HttpModuleAsyncOptions = {\n    useFactory: async () => ({\n      timeout: 5000,\n      maxRedirects: 5,\n    }),\n  };\n\n  describe('registerAsync useFactory', () => {\n    let app: INestApplication;\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.registerAsync(mockedUseFactory),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be define', async () => {\n      expect(app).toBeDefined();\n    });\n  });\n\n  const mockedUseClassOptions: HttpModuleAsyncOptions = {\n    useClass: MockedClass,\n  };\n\n  describe('registerAsync useClass', () => {\n    let app: INestApplication;\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.registerAsync(mockedUseClassOptions),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be define', async () => {\n      expect(app).toBeDefined();\n    });\n  });\n\n  const mockedUseExistingOptions: HttpModuleAsyncOptions = {\n    extraProviders: [MockedClass],\n    useExisting: MockedClass,\n  };\n\n  describe('registerAsync useExisting', () => {\n    let app: INestApplication;\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.registerAsync(mockedUseExistingOptions),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be define', async () => {\n      expect(app).toBeDefined();\n    });\n  });\n\n  describe('register', () => {\n    let app: INestApplication;\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.register({ ...config().httOptions }),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be define', async () => {\n      expect(app).toBeDefined();\n    });\n  });\n});\n",
              "err": {},
              "uuid": "77403594-c004-4586-b2f3-6d5e278512b3",
              "parentUUID": "e4e47e1f-5a40-4eb8-851c-7904e9c78814",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "HttpModule > registerAsync useClass > should be define",
              "title": "HttpModule > registerAsync useClass > should be define",
              "timedOut": false,
              "duration": 6,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { INestApplication } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\n\nimport { HttpClientModule } from '../http/httpClient.module';\nimport { config } from './utils';\nimport { HttpModuleAsyncOptions } from '../http/interfaces/http-module.interface';\n\nclass MockedClass {\n  createHttpOptions() {\n    return {\n      timeout: 5000,\n      maxRedirects: 5,\n    };\n  }\n}\n\ndescribe('HttpModule', () => {\n  const mockedUseFactory: HttpModuleAsyncOptions = {\n    useFactory: async () => ({\n      timeout: 5000,\n      maxRedirects: 5,\n    }),\n  };\n\n  describe('registerAsync useFactory', () => {\n    let app: INestApplication;\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.registerAsync(mockedUseFactory),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be define', async () => {\n      expect(app).toBeDefined();\n    });\n  });\n\n  const mockedUseClassOptions: HttpModuleAsyncOptions = {\n    useClass: MockedClass,\n  };\n\n  describe('registerAsync useClass', () => {\n    let app: INestApplication;\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.registerAsync(mockedUseClassOptions),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be define', async () => {\n      expect(app).toBeDefined();\n    });\n  });\n\n  const mockedUseExistingOptions: HttpModuleAsyncOptions = {\n    extraProviders: [MockedClass],\n    useExisting: MockedClass,\n  };\n\n  describe('registerAsync useExisting', () => {\n    let app: INestApplication;\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.registerAsync(mockedUseExistingOptions),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be define', async () => {\n      expect(app).toBeDefined();\n    });\n  });\n\n  describe('register', () => {\n    let app: INestApplication;\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.register({ ...config().httOptions }),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be define', async () => {\n      expect(app).toBeDefined();\n    });\n  });\n});\n",
              "err": {},
              "uuid": "12b2846a-fcfe-46fd-9061-bd60214831f1",
              "parentUUID": "e4e47e1f-5a40-4eb8-851c-7904e9c78814",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "HttpModule > registerAsync useExisting > should be define",
              "title": "HttpModule > registerAsync useExisting > should be define",
              "timedOut": false,
              "duration": 4,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { INestApplication } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\n\nimport { HttpClientModule } from '../http/httpClient.module';\nimport { config } from './utils';\nimport { HttpModuleAsyncOptions } from '../http/interfaces/http-module.interface';\n\nclass MockedClass {\n  createHttpOptions() {\n    return {\n      timeout: 5000,\n      maxRedirects: 5,\n    };\n  }\n}\n\ndescribe('HttpModule', () => {\n  const mockedUseFactory: HttpModuleAsyncOptions = {\n    useFactory: async () => ({\n      timeout: 5000,\n      maxRedirects: 5,\n    }),\n  };\n\n  describe('registerAsync useFactory', () => {\n    let app: INestApplication;\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.registerAsync(mockedUseFactory),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be define', async () => {\n      expect(app).toBeDefined();\n    });\n  });\n\n  const mockedUseClassOptions: HttpModuleAsyncOptions = {\n    useClass: MockedClass,\n  };\n\n  describe('registerAsync useClass', () => {\n    let app: INestApplication;\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.registerAsync(mockedUseClassOptions),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be define', async () => {\n      expect(app).toBeDefined();\n    });\n  });\n\n  const mockedUseExistingOptions: HttpModuleAsyncOptions = {\n    extraProviders: [MockedClass],\n    useExisting: MockedClass,\n  };\n\n  describe('registerAsync useExisting', () => {\n    let app: INestApplication;\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.registerAsync(mockedUseExistingOptions),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be define', async () => {\n      expect(app).toBeDefined();\n    });\n  });\n\n  describe('register', () => {\n    let app: INestApplication;\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.register({ ...config().httOptions }),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be define', async () => {\n      expect(app).toBeDefined();\n    });\n  });\n});\n",
              "err": {},
              "uuid": "5e7b9720-0329-4013-9122-0a6bf6b378f6",
              "parentUUID": "e4e47e1f-5a40-4eb8-851c-7904e9c78814",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "HttpModule > register > should be define",
              "title": "HttpModule > register > should be define",
              "timedOut": false,
              "duration": 4,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { INestApplication } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\n\nimport { HttpClientModule } from '../http/httpClient.module';\nimport { config } from './utils';\nimport { HttpModuleAsyncOptions } from '../http/interfaces/http-module.interface';\n\nclass MockedClass {\n  createHttpOptions() {\n    return {\n      timeout: 5000,\n      maxRedirects: 5,\n    };\n  }\n}\n\ndescribe('HttpModule', () => {\n  const mockedUseFactory: HttpModuleAsyncOptions = {\n    useFactory: async () => ({\n      timeout: 5000,\n      maxRedirects: 5,\n    }),\n  };\n\n  describe('registerAsync useFactory', () => {\n    let app: INestApplication;\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.registerAsync(mockedUseFactory),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be define', async () => {\n      expect(app).toBeDefined();\n    });\n  });\n\n  const mockedUseClassOptions: HttpModuleAsyncOptions = {\n    useClass: MockedClass,\n  };\n\n  describe('registerAsync useClass', () => {\n    let app: INestApplication;\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.registerAsync(mockedUseClassOptions),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be define', async () => {\n      expect(app).toBeDefined();\n    });\n  });\n\n  const mockedUseExistingOptions: HttpModuleAsyncOptions = {\n    extraProviders: [MockedClass],\n    useExisting: MockedClass,\n  };\n\n  describe('registerAsync useExisting', () => {\n    let app: INestApplication;\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.registerAsync(mockedUseExistingOptions),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be define', async () => {\n      expect(app).toBeDefined();\n    });\n  });\n\n  describe('register', () => {\n    let app: INestApplication;\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [config],\n          }),\n          HttpClientModule.register({ ...config().httOptions }),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      await app.init;\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be define', async () => {\n      expect(app).toBeDefined();\n    });\n  });\n});\n",
              "err": {},
              "uuid": "4651145d-737a-4d74-b970-9300d80e0f9e",
              "parentUUID": "e4e47e1f-5a40-4eb8-851c-7904e9c78814",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "01392ef8-c46d-416e-8b14-8b488a37891b",
            "e15cdea4-97a4-4baf-9b9b-cf0cd24b13df",
            "c4d6a6c7-e872-4647-b4f1-90aacb1421fd",
            "a85e5925-a1d7-4537-9f67-78b1b6f4a9cf",
            "cda2ffb3-7d7a-4bba-935a-aebf0151fac8",
            "a988cb86-970c-49e0-b911-1b5f569dc634",
            "8a13c851-7d44-4d50-bd09-f3f5093a8063",
            "9aeecf01-166e-42b6-8087-dffad821d978",
            "6892fae6-80a8-4cee-998e-4f0a2615acdf",
            "da246b4d-93fb-4db3-84b6-513164062dc7",
            "6beb7206-8573-4edf-b6ee-dc8d2a273aaa",
            "e9c0a462-5343-4a9a-8376-91df74402bea",
            "77403594-c004-4586-b2f3-6d5e278512b3",
            "12b2846a-fcfe-46fd-9061-bd60214831f1",
            "5e7b9720-0329-4013-9122-0a6bf6b378f6",
            "4651145d-737a-4d74-b970-9300d80e0f9e"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 3333,
          "root": false,
          "rootEmpty": false,
          "_timeout": 5000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 5000
    },
    {
      "uuid": "711a1818-3569-4b49-bc6f-5a6a9f7dd036",
      "title": "@tresdoce-nestjs-toolkit/mailer",
      "fullFile": "",
      "file": "",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "523b2ad6-7258-473b-8a13-419105450da5",
          "title": "@tresdoce-nestjs-toolkit/mailer",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "fullTitle": "MailerService > should not be defined if a transport is not provided",
              "title": "MailerService > should not be defined if a transport is not provided",
              "timedOut": false,
              "duration": 10,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { pathJoin } from '@tresdoce-nestjs-toolkit/test-utils';\nimport * as nodemailerMock from 'nodemailer-mock';\nimport MailMessage from 'nodemailer/lib/mailer/mail-message';\nimport SMTPTransport from 'nodemailer/lib/smtp-transport';\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from '../mailer/constants/mailer.constant';\n\nimport { MailerOptions, TransportType } from '../mailer/interfaces/mailer-options.interface';\nimport { MailerTransportFactory } from '../mailer/interfaces/mailer-transport-factory.interface';\n\nimport { HandlebarsAdapter } from '../mailer/adapters/handlebars.adapter';\nimport { PugAdapter } from '../mailer/adapters/pug.adapter';\nimport { EjsAdapter } from '../mailer/adapters/ejs.adapter';\n\nimport { MailerService } from '../mailer/services/mailer.service';\n\nconst template_path = pathJoin(__dirname, 'utils/test-templates');\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise<MailerService> {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get<MailerService>(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) => void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, 'send')\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) => void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: 'ABCD',\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: 'ok',\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise<MailerService> {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: 'localhost', port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get<MailerService>(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe('MailerService', () => {\n  it('should not be defined if a transport is not provided', async () => {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it('should accept a smtp transport string', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transports string', async () => {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) => {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it('should accept smtp transport options', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: 'user@domain.com',\n          pass: 'pass',\n        },\n        options: {\n          host: 'smtp.domain.com',\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transport instance', async () => {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it('should send emails with nodemailer', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer transports', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    await service.sendMail({\n      transporterName: 'myDomain',\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer with different transports name', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n        },\n      });\n\n      await service.sendMail({\n        transporterName: 'testDomain',\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\"Transporters object doesn't have testDomain key\");\n    }\n  });\n\n  it('should send emails with nodemailer without transports', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe('Transporter object undefined');\n    }\n  });\n\n  it('should use mailerOptions.defaults when send emails', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n      defaults: {\n        from: 'user1@example.test',\n      },\n    });\n\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n  });\n\n  it('should use custom transport to send mail', async () => {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it('should compile template with the handlebars adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with error template path', async () => {\n    let templatePath = pathJoin(template_path, '/handlebars-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.hbs'`,\n      );\n    }\n  });\n\n  it('should compile template with the handlebars adapter with disabled inline-css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) => {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the handlebars adapter with enabled inline-css and media query', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: ' ', preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the pug adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/pug-templates');\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          world: 'World',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open '${templatePath}.pug'`);\n    }\n  });\n\n  it('should compile template with the pug adapter without inline css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Pug test template.</p><p>Hello World!</p>');\n  });\n\n  it('should compile template with the ejs adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/ejs-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.ejs'`,\n      );\n    }\n  });\n\n  it('should compile template with the ejs adapter read template relative url', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter without css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Ejs test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n});\n",
              "err": {},
              "uuid": "52fc7fb9-9bb4-4e09-9818-cc98e383ac88",
              "parentUUID": "523b2ad6-7258-473b-8a13-419105450da5",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "MailerService > should accept a smtp transport string",
              "title": "MailerService > should accept a smtp transport string",
              "timedOut": false,
              "duration": 6,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { pathJoin } from '@tresdoce-nestjs-toolkit/test-utils';\nimport * as nodemailerMock from 'nodemailer-mock';\nimport MailMessage from 'nodemailer/lib/mailer/mail-message';\nimport SMTPTransport from 'nodemailer/lib/smtp-transport';\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from '../mailer/constants/mailer.constant';\n\nimport { MailerOptions, TransportType } from '../mailer/interfaces/mailer-options.interface';\nimport { MailerTransportFactory } from '../mailer/interfaces/mailer-transport-factory.interface';\n\nimport { HandlebarsAdapter } from '../mailer/adapters/handlebars.adapter';\nimport { PugAdapter } from '../mailer/adapters/pug.adapter';\nimport { EjsAdapter } from '../mailer/adapters/ejs.adapter';\n\nimport { MailerService } from '../mailer/services/mailer.service';\n\nconst template_path = pathJoin(__dirname, 'utils/test-templates');\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise<MailerService> {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get<MailerService>(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) => void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, 'send')\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) => void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: 'ABCD',\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: 'ok',\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise<MailerService> {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: 'localhost', port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get<MailerService>(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe('MailerService', () => {\n  it('should not be defined if a transport is not provided', async () => {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it('should accept a smtp transport string', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transports string', async () => {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) => {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it('should accept smtp transport options', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: 'user@domain.com',\n          pass: 'pass',\n        },\n        options: {\n          host: 'smtp.domain.com',\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transport instance', async () => {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it('should send emails with nodemailer', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer transports', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    await service.sendMail({\n      transporterName: 'myDomain',\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer with different transports name', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n        },\n      });\n\n      await service.sendMail({\n        transporterName: 'testDomain',\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\"Transporters object doesn't have testDomain key\");\n    }\n  });\n\n  it('should send emails with nodemailer without transports', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe('Transporter object undefined');\n    }\n  });\n\n  it('should use mailerOptions.defaults when send emails', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n      defaults: {\n        from: 'user1@example.test',\n      },\n    });\n\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n  });\n\n  it('should use custom transport to send mail', async () => {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it('should compile template with the handlebars adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with error template path', async () => {\n    let templatePath = pathJoin(template_path, '/handlebars-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.hbs'`,\n      );\n    }\n  });\n\n  it('should compile template with the handlebars adapter with disabled inline-css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) => {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the handlebars adapter with enabled inline-css and media query', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: ' ', preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the pug adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/pug-templates');\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          world: 'World',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open '${templatePath}.pug'`);\n    }\n  });\n\n  it('should compile template with the pug adapter without inline css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Pug test template.</p><p>Hello World!</p>');\n  });\n\n  it('should compile template with the ejs adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/ejs-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.ejs'`,\n      );\n    }\n  });\n\n  it('should compile template with the ejs adapter read template relative url', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter without css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Ejs test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n});\n",
              "err": {},
              "uuid": "ff5491c4-bd95-4b5c-9a5f-0d740aaa2b5d",
              "parentUUID": "523b2ad6-7258-473b-8a13-419105450da5",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "MailerService > should accept a smtp transports string",
              "title": "MailerService > should accept a smtp transports string",
              "timedOut": false,
              "duration": 5,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { pathJoin } from '@tresdoce-nestjs-toolkit/test-utils';\nimport * as nodemailerMock from 'nodemailer-mock';\nimport MailMessage from 'nodemailer/lib/mailer/mail-message';\nimport SMTPTransport from 'nodemailer/lib/smtp-transport';\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from '../mailer/constants/mailer.constant';\n\nimport { MailerOptions, TransportType } from '../mailer/interfaces/mailer-options.interface';\nimport { MailerTransportFactory } from '../mailer/interfaces/mailer-transport-factory.interface';\n\nimport { HandlebarsAdapter } from '../mailer/adapters/handlebars.adapter';\nimport { PugAdapter } from '../mailer/adapters/pug.adapter';\nimport { EjsAdapter } from '../mailer/adapters/ejs.adapter';\n\nimport { MailerService } from '../mailer/services/mailer.service';\n\nconst template_path = pathJoin(__dirname, 'utils/test-templates');\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise<MailerService> {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get<MailerService>(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) => void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, 'send')\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) => void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: 'ABCD',\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: 'ok',\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise<MailerService> {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: 'localhost', port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get<MailerService>(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe('MailerService', () => {\n  it('should not be defined if a transport is not provided', async () => {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it('should accept a smtp transport string', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transports string', async () => {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) => {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it('should accept smtp transport options', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: 'user@domain.com',\n          pass: 'pass',\n        },\n        options: {\n          host: 'smtp.domain.com',\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transport instance', async () => {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it('should send emails with nodemailer', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer transports', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    await service.sendMail({\n      transporterName: 'myDomain',\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer with different transports name', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n        },\n      });\n\n      await service.sendMail({\n        transporterName: 'testDomain',\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\"Transporters object doesn't have testDomain key\");\n    }\n  });\n\n  it('should send emails with nodemailer without transports', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe('Transporter object undefined');\n    }\n  });\n\n  it('should use mailerOptions.defaults when send emails', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n      defaults: {\n        from: 'user1@example.test',\n      },\n    });\n\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n  });\n\n  it('should use custom transport to send mail', async () => {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it('should compile template with the handlebars adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with error template path', async () => {\n    let templatePath = pathJoin(template_path, '/handlebars-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.hbs'`,\n      );\n    }\n  });\n\n  it('should compile template with the handlebars adapter with disabled inline-css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) => {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the handlebars adapter with enabled inline-css and media query', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: ' ', preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the pug adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/pug-templates');\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          world: 'World',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open '${templatePath}.pug'`);\n    }\n  });\n\n  it('should compile template with the pug adapter without inline css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Pug test template.</p><p>Hello World!</p>');\n  });\n\n  it('should compile template with the ejs adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/ejs-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.ejs'`,\n      );\n    }\n  });\n\n  it('should compile template with the ejs adapter read template relative url', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter without css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Ejs test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n});\n",
              "err": {},
              "uuid": "f63abc46-1239-48ae-ace1-6d34d53e9804",
              "parentUUID": "523b2ad6-7258-473b-8a13-419105450da5",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "MailerService > should accept smtp transport options",
              "title": "MailerService > should accept smtp transport options",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { pathJoin } from '@tresdoce-nestjs-toolkit/test-utils';\nimport * as nodemailerMock from 'nodemailer-mock';\nimport MailMessage from 'nodemailer/lib/mailer/mail-message';\nimport SMTPTransport from 'nodemailer/lib/smtp-transport';\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from '../mailer/constants/mailer.constant';\n\nimport { MailerOptions, TransportType } from '../mailer/interfaces/mailer-options.interface';\nimport { MailerTransportFactory } from '../mailer/interfaces/mailer-transport-factory.interface';\n\nimport { HandlebarsAdapter } from '../mailer/adapters/handlebars.adapter';\nimport { PugAdapter } from '../mailer/adapters/pug.adapter';\nimport { EjsAdapter } from '../mailer/adapters/ejs.adapter';\n\nimport { MailerService } from '../mailer/services/mailer.service';\n\nconst template_path = pathJoin(__dirname, 'utils/test-templates');\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise<MailerService> {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get<MailerService>(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) => void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, 'send')\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) => void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: 'ABCD',\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: 'ok',\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise<MailerService> {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: 'localhost', port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get<MailerService>(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe('MailerService', () => {\n  it('should not be defined if a transport is not provided', async () => {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it('should accept a smtp transport string', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transports string', async () => {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) => {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it('should accept smtp transport options', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: 'user@domain.com',\n          pass: 'pass',\n        },\n        options: {\n          host: 'smtp.domain.com',\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transport instance', async () => {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it('should send emails with nodemailer', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer transports', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    await service.sendMail({\n      transporterName: 'myDomain',\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer with different transports name', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n        },\n      });\n\n      await service.sendMail({\n        transporterName: 'testDomain',\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\"Transporters object doesn't have testDomain key\");\n    }\n  });\n\n  it('should send emails with nodemailer without transports', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe('Transporter object undefined');\n    }\n  });\n\n  it('should use mailerOptions.defaults when send emails', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n      defaults: {\n        from: 'user1@example.test',\n      },\n    });\n\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n  });\n\n  it('should use custom transport to send mail', async () => {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it('should compile template with the handlebars adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with error template path', async () => {\n    let templatePath = pathJoin(template_path, '/handlebars-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.hbs'`,\n      );\n    }\n  });\n\n  it('should compile template with the handlebars adapter with disabled inline-css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) => {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the handlebars adapter with enabled inline-css and media query', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: ' ', preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the pug adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/pug-templates');\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          world: 'World',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open '${templatePath}.pug'`);\n    }\n  });\n\n  it('should compile template with the pug adapter without inline css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Pug test template.</p><p>Hello World!</p>');\n  });\n\n  it('should compile template with the ejs adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/ejs-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.ejs'`,\n      );\n    }\n  });\n\n  it('should compile template with the ejs adapter read template relative url', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter without css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Ejs test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n});\n",
              "err": {},
              "uuid": "2b40a82e-febb-4d57-b887-5c3d914e47c2",
              "parentUUID": "523b2ad6-7258-473b-8a13-419105450da5",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "MailerService > should accept a smtp transport instance",
              "title": "MailerService > should accept a smtp transport instance",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { pathJoin } from '@tresdoce-nestjs-toolkit/test-utils';\nimport * as nodemailerMock from 'nodemailer-mock';\nimport MailMessage from 'nodemailer/lib/mailer/mail-message';\nimport SMTPTransport from 'nodemailer/lib/smtp-transport';\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from '../mailer/constants/mailer.constant';\n\nimport { MailerOptions, TransportType } from '../mailer/interfaces/mailer-options.interface';\nimport { MailerTransportFactory } from '../mailer/interfaces/mailer-transport-factory.interface';\n\nimport { HandlebarsAdapter } from '../mailer/adapters/handlebars.adapter';\nimport { PugAdapter } from '../mailer/adapters/pug.adapter';\nimport { EjsAdapter } from '../mailer/adapters/ejs.adapter';\n\nimport { MailerService } from '../mailer/services/mailer.service';\n\nconst template_path = pathJoin(__dirname, 'utils/test-templates');\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise<MailerService> {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get<MailerService>(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) => void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, 'send')\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) => void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: 'ABCD',\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: 'ok',\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise<MailerService> {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: 'localhost', port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get<MailerService>(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe('MailerService', () => {\n  it('should not be defined if a transport is not provided', async () => {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it('should accept a smtp transport string', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transports string', async () => {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) => {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it('should accept smtp transport options', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: 'user@domain.com',\n          pass: 'pass',\n        },\n        options: {\n          host: 'smtp.domain.com',\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transport instance', async () => {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it('should send emails with nodemailer', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer transports', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    await service.sendMail({\n      transporterName: 'myDomain',\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer with different transports name', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n        },\n      });\n\n      await service.sendMail({\n        transporterName: 'testDomain',\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\"Transporters object doesn't have testDomain key\");\n    }\n  });\n\n  it('should send emails with nodemailer without transports', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe('Transporter object undefined');\n    }\n  });\n\n  it('should use mailerOptions.defaults when send emails', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n      defaults: {\n        from: 'user1@example.test',\n      },\n    });\n\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n  });\n\n  it('should use custom transport to send mail', async () => {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it('should compile template with the handlebars adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with error template path', async () => {\n    let templatePath = pathJoin(template_path, '/handlebars-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.hbs'`,\n      );\n    }\n  });\n\n  it('should compile template with the handlebars adapter with disabled inline-css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) => {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the handlebars adapter with enabled inline-css and media query', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: ' ', preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the pug adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/pug-templates');\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          world: 'World',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open '${templatePath}.pug'`);\n    }\n  });\n\n  it('should compile template with the pug adapter without inline css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Pug test template.</p><p>Hello World!</p>');\n  });\n\n  it('should compile template with the ejs adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/ejs-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.ejs'`,\n      );\n    }\n  });\n\n  it('should compile template with the ejs adapter read template relative url', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter without css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Ejs test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n});\n",
              "err": {},
              "uuid": "39f941d7-f0ad-4f44-9560-7ad4742374ab",
              "parentUUID": "523b2ad6-7258-473b-8a13-419105450da5",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "MailerService > should send emails with nodemailer",
              "title": "MailerService > should send emails with nodemailer",
              "timedOut": false,
              "duration": 7,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { pathJoin } from '@tresdoce-nestjs-toolkit/test-utils';\nimport * as nodemailerMock from 'nodemailer-mock';\nimport MailMessage from 'nodemailer/lib/mailer/mail-message';\nimport SMTPTransport from 'nodemailer/lib/smtp-transport';\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from '../mailer/constants/mailer.constant';\n\nimport { MailerOptions, TransportType } from '../mailer/interfaces/mailer-options.interface';\nimport { MailerTransportFactory } from '../mailer/interfaces/mailer-transport-factory.interface';\n\nimport { HandlebarsAdapter } from '../mailer/adapters/handlebars.adapter';\nimport { PugAdapter } from '../mailer/adapters/pug.adapter';\nimport { EjsAdapter } from '../mailer/adapters/ejs.adapter';\n\nimport { MailerService } from '../mailer/services/mailer.service';\n\nconst template_path = pathJoin(__dirname, 'utils/test-templates');\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise<MailerService> {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get<MailerService>(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) => void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, 'send')\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) => void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: 'ABCD',\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: 'ok',\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise<MailerService> {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: 'localhost', port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get<MailerService>(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe('MailerService', () => {\n  it('should not be defined if a transport is not provided', async () => {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it('should accept a smtp transport string', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transports string', async () => {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) => {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it('should accept smtp transport options', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: 'user@domain.com',\n          pass: 'pass',\n        },\n        options: {\n          host: 'smtp.domain.com',\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transport instance', async () => {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it('should send emails with nodemailer', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer transports', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    await service.sendMail({\n      transporterName: 'myDomain',\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer with different transports name', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n        },\n      });\n\n      await service.sendMail({\n        transporterName: 'testDomain',\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\"Transporters object doesn't have testDomain key\");\n    }\n  });\n\n  it('should send emails with nodemailer without transports', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe('Transporter object undefined');\n    }\n  });\n\n  it('should use mailerOptions.defaults when send emails', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n      defaults: {\n        from: 'user1@example.test',\n      },\n    });\n\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n  });\n\n  it('should use custom transport to send mail', async () => {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it('should compile template with the handlebars adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with error template path', async () => {\n    let templatePath = pathJoin(template_path, '/handlebars-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.hbs'`,\n      );\n    }\n  });\n\n  it('should compile template with the handlebars adapter with disabled inline-css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) => {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the handlebars adapter with enabled inline-css and media query', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: ' ', preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the pug adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/pug-templates');\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          world: 'World',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open '${templatePath}.pug'`);\n    }\n  });\n\n  it('should compile template with the pug adapter without inline css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Pug test template.</p><p>Hello World!</p>');\n  });\n\n  it('should compile template with the ejs adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/ejs-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.ejs'`,\n      );\n    }\n  });\n\n  it('should compile template with the ejs adapter read template relative url', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter without css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Ejs test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n});\n",
              "err": {},
              "uuid": "bae792da-29da-4110-9c1d-4d4e28aa7f46",
              "parentUUID": "523b2ad6-7258-473b-8a13-419105450da5",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "MailerService > should send emails with nodemailer transports",
              "title": "MailerService > should send emails with nodemailer transports",
              "timedOut": false,
              "duration": 3,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { pathJoin } from '@tresdoce-nestjs-toolkit/test-utils';\nimport * as nodemailerMock from 'nodemailer-mock';\nimport MailMessage from 'nodemailer/lib/mailer/mail-message';\nimport SMTPTransport from 'nodemailer/lib/smtp-transport';\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from '../mailer/constants/mailer.constant';\n\nimport { MailerOptions, TransportType } from '../mailer/interfaces/mailer-options.interface';\nimport { MailerTransportFactory } from '../mailer/interfaces/mailer-transport-factory.interface';\n\nimport { HandlebarsAdapter } from '../mailer/adapters/handlebars.adapter';\nimport { PugAdapter } from '../mailer/adapters/pug.adapter';\nimport { EjsAdapter } from '../mailer/adapters/ejs.adapter';\n\nimport { MailerService } from '../mailer/services/mailer.service';\n\nconst template_path = pathJoin(__dirname, 'utils/test-templates');\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise<MailerService> {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get<MailerService>(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) => void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, 'send')\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) => void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: 'ABCD',\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: 'ok',\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise<MailerService> {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: 'localhost', port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get<MailerService>(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe('MailerService', () => {\n  it('should not be defined if a transport is not provided', async () => {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it('should accept a smtp transport string', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transports string', async () => {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) => {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it('should accept smtp transport options', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: 'user@domain.com',\n          pass: 'pass',\n        },\n        options: {\n          host: 'smtp.domain.com',\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transport instance', async () => {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it('should send emails with nodemailer', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer transports', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    await service.sendMail({\n      transporterName: 'myDomain',\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer with different transports name', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n        },\n      });\n\n      await service.sendMail({\n        transporterName: 'testDomain',\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\"Transporters object doesn't have testDomain key\");\n    }\n  });\n\n  it('should send emails with nodemailer without transports', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe('Transporter object undefined');\n    }\n  });\n\n  it('should use mailerOptions.defaults when send emails', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n      defaults: {\n        from: 'user1@example.test',\n      },\n    });\n\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n  });\n\n  it('should use custom transport to send mail', async () => {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it('should compile template with the handlebars adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with error template path', async () => {\n    let templatePath = pathJoin(template_path, '/handlebars-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.hbs'`,\n      );\n    }\n  });\n\n  it('should compile template with the handlebars adapter with disabled inline-css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) => {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the handlebars adapter with enabled inline-css and media query', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: ' ', preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the pug adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/pug-templates');\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          world: 'World',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open '${templatePath}.pug'`);\n    }\n  });\n\n  it('should compile template with the pug adapter without inline css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Pug test template.</p><p>Hello World!</p>');\n  });\n\n  it('should compile template with the ejs adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/ejs-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.ejs'`,\n      );\n    }\n  });\n\n  it('should compile template with the ejs adapter read template relative url', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter without css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Ejs test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n});\n",
              "err": {},
              "uuid": "cba95eb4-3975-4e5b-a0f1-f755b0794b6c",
              "parentUUID": "523b2ad6-7258-473b-8a13-419105450da5",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "MailerService > should send emails with nodemailer with different transports name",
              "title": "MailerService > should send emails with nodemailer with different transports name",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { pathJoin } from '@tresdoce-nestjs-toolkit/test-utils';\nimport * as nodemailerMock from 'nodemailer-mock';\nimport MailMessage from 'nodemailer/lib/mailer/mail-message';\nimport SMTPTransport from 'nodemailer/lib/smtp-transport';\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from '../mailer/constants/mailer.constant';\n\nimport { MailerOptions, TransportType } from '../mailer/interfaces/mailer-options.interface';\nimport { MailerTransportFactory } from '../mailer/interfaces/mailer-transport-factory.interface';\n\nimport { HandlebarsAdapter } from '../mailer/adapters/handlebars.adapter';\nimport { PugAdapter } from '../mailer/adapters/pug.adapter';\nimport { EjsAdapter } from '../mailer/adapters/ejs.adapter';\n\nimport { MailerService } from '../mailer/services/mailer.service';\n\nconst template_path = pathJoin(__dirname, 'utils/test-templates');\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise<MailerService> {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get<MailerService>(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) => void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, 'send')\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) => void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: 'ABCD',\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: 'ok',\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise<MailerService> {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: 'localhost', port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get<MailerService>(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe('MailerService', () => {\n  it('should not be defined if a transport is not provided', async () => {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it('should accept a smtp transport string', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transports string', async () => {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) => {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it('should accept smtp transport options', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: 'user@domain.com',\n          pass: 'pass',\n        },\n        options: {\n          host: 'smtp.domain.com',\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transport instance', async () => {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it('should send emails with nodemailer', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer transports', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    await service.sendMail({\n      transporterName: 'myDomain',\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer with different transports name', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n        },\n      });\n\n      await service.sendMail({\n        transporterName: 'testDomain',\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\"Transporters object doesn't have testDomain key\");\n    }\n  });\n\n  it('should send emails with nodemailer without transports', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe('Transporter object undefined');\n    }\n  });\n\n  it('should use mailerOptions.defaults when send emails', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n      defaults: {\n        from: 'user1@example.test',\n      },\n    });\n\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n  });\n\n  it('should use custom transport to send mail', async () => {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it('should compile template with the handlebars adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with error template path', async () => {\n    let templatePath = pathJoin(template_path, '/handlebars-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.hbs'`,\n      );\n    }\n  });\n\n  it('should compile template with the handlebars adapter with disabled inline-css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) => {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the handlebars adapter with enabled inline-css and media query', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: ' ', preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the pug adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/pug-templates');\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          world: 'World',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open '${templatePath}.pug'`);\n    }\n  });\n\n  it('should compile template with the pug adapter without inline css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Pug test template.</p><p>Hello World!</p>');\n  });\n\n  it('should compile template with the ejs adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/ejs-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.ejs'`,\n      );\n    }\n  });\n\n  it('should compile template with the ejs adapter read template relative url', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter without css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Ejs test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n});\n",
              "err": {},
              "uuid": "4dc56762-cd3c-4f26-9835-cc65d25639ff",
              "parentUUID": "523b2ad6-7258-473b-8a13-419105450da5",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "MailerService > should send emails with nodemailer without transports",
              "title": "MailerService > should send emails with nodemailer without transports",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { pathJoin } from '@tresdoce-nestjs-toolkit/test-utils';\nimport * as nodemailerMock from 'nodemailer-mock';\nimport MailMessage from 'nodemailer/lib/mailer/mail-message';\nimport SMTPTransport from 'nodemailer/lib/smtp-transport';\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from '../mailer/constants/mailer.constant';\n\nimport { MailerOptions, TransportType } from '../mailer/interfaces/mailer-options.interface';\nimport { MailerTransportFactory } from '../mailer/interfaces/mailer-transport-factory.interface';\n\nimport { HandlebarsAdapter } from '../mailer/adapters/handlebars.adapter';\nimport { PugAdapter } from '../mailer/adapters/pug.adapter';\nimport { EjsAdapter } from '../mailer/adapters/ejs.adapter';\n\nimport { MailerService } from '../mailer/services/mailer.service';\n\nconst template_path = pathJoin(__dirname, 'utils/test-templates');\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise<MailerService> {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get<MailerService>(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) => void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, 'send')\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) => void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: 'ABCD',\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: 'ok',\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise<MailerService> {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: 'localhost', port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get<MailerService>(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe('MailerService', () => {\n  it('should not be defined if a transport is not provided', async () => {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it('should accept a smtp transport string', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transports string', async () => {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) => {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it('should accept smtp transport options', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: 'user@domain.com',\n          pass: 'pass',\n        },\n        options: {\n          host: 'smtp.domain.com',\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transport instance', async () => {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it('should send emails with nodemailer', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer transports', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    await service.sendMail({\n      transporterName: 'myDomain',\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer with different transports name', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n        },\n      });\n\n      await service.sendMail({\n        transporterName: 'testDomain',\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\"Transporters object doesn't have testDomain key\");\n    }\n  });\n\n  it('should send emails with nodemailer without transports', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe('Transporter object undefined');\n    }\n  });\n\n  it('should use mailerOptions.defaults when send emails', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n      defaults: {\n        from: 'user1@example.test',\n      },\n    });\n\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n  });\n\n  it('should use custom transport to send mail', async () => {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it('should compile template with the handlebars adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with error template path', async () => {\n    let templatePath = pathJoin(template_path, '/handlebars-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.hbs'`,\n      );\n    }\n  });\n\n  it('should compile template with the handlebars adapter with disabled inline-css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) => {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the handlebars adapter with enabled inline-css and media query', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: ' ', preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the pug adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/pug-templates');\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          world: 'World',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open '${templatePath}.pug'`);\n    }\n  });\n\n  it('should compile template with the pug adapter without inline css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Pug test template.</p><p>Hello World!</p>');\n  });\n\n  it('should compile template with the ejs adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/ejs-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.ejs'`,\n      );\n    }\n  });\n\n  it('should compile template with the ejs adapter read template relative url', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter without css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Ejs test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n});\n",
              "err": {},
              "uuid": "31b21d0c-b653-4a0f-9f5f-1bb32afe76dd",
              "parentUUID": "523b2ad6-7258-473b-8a13-419105450da5",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "MailerService > should use mailerOptions.defaults when send emails",
              "title": "MailerService > should use mailerOptions.defaults when send emails",
              "timedOut": false,
              "duration": 3,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { pathJoin } from '@tresdoce-nestjs-toolkit/test-utils';\nimport * as nodemailerMock from 'nodemailer-mock';\nimport MailMessage from 'nodemailer/lib/mailer/mail-message';\nimport SMTPTransport from 'nodemailer/lib/smtp-transport';\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from '../mailer/constants/mailer.constant';\n\nimport { MailerOptions, TransportType } from '../mailer/interfaces/mailer-options.interface';\nimport { MailerTransportFactory } from '../mailer/interfaces/mailer-transport-factory.interface';\n\nimport { HandlebarsAdapter } from '../mailer/adapters/handlebars.adapter';\nimport { PugAdapter } from '../mailer/adapters/pug.adapter';\nimport { EjsAdapter } from '../mailer/adapters/ejs.adapter';\n\nimport { MailerService } from '../mailer/services/mailer.service';\n\nconst template_path = pathJoin(__dirname, 'utils/test-templates');\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise<MailerService> {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get<MailerService>(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) => void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, 'send')\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) => void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: 'ABCD',\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: 'ok',\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise<MailerService> {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: 'localhost', port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get<MailerService>(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe('MailerService', () => {\n  it('should not be defined if a transport is not provided', async () => {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it('should accept a smtp transport string', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transports string', async () => {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) => {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it('should accept smtp transport options', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: 'user@domain.com',\n          pass: 'pass',\n        },\n        options: {\n          host: 'smtp.domain.com',\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transport instance', async () => {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it('should send emails with nodemailer', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer transports', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    await service.sendMail({\n      transporterName: 'myDomain',\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer with different transports name', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n        },\n      });\n\n      await service.sendMail({\n        transporterName: 'testDomain',\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\"Transporters object doesn't have testDomain key\");\n    }\n  });\n\n  it('should send emails with nodemailer without transports', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe('Transporter object undefined');\n    }\n  });\n\n  it('should use mailerOptions.defaults when send emails', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n      defaults: {\n        from: 'user1@example.test',\n      },\n    });\n\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n  });\n\n  it('should use custom transport to send mail', async () => {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it('should compile template with the handlebars adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with error template path', async () => {\n    let templatePath = pathJoin(template_path, '/handlebars-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.hbs'`,\n      );\n    }\n  });\n\n  it('should compile template with the handlebars adapter with disabled inline-css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) => {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the handlebars adapter with enabled inline-css and media query', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: ' ', preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the pug adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/pug-templates');\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          world: 'World',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open '${templatePath}.pug'`);\n    }\n  });\n\n  it('should compile template with the pug adapter without inline css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Pug test template.</p><p>Hello World!</p>');\n  });\n\n  it('should compile template with the ejs adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/ejs-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.ejs'`,\n      );\n    }\n  });\n\n  it('should compile template with the ejs adapter read template relative url', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter without css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Ejs test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n});\n",
              "err": {},
              "uuid": "b32d6557-ac3d-430c-860b-293606aa2e16",
              "parentUUID": "523b2ad6-7258-473b-8a13-419105450da5",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "MailerService > should use custom transport to send mail",
              "title": "MailerService > should use custom transport to send mail",
              "timedOut": false,
              "duration": 4,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { pathJoin } from '@tresdoce-nestjs-toolkit/test-utils';\nimport * as nodemailerMock from 'nodemailer-mock';\nimport MailMessage from 'nodemailer/lib/mailer/mail-message';\nimport SMTPTransport from 'nodemailer/lib/smtp-transport';\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from '../mailer/constants/mailer.constant';\n\nimport { MailerOptions, TransportType } from '../mailer/interfaces/mailer-options.interface';\nimport { MailerTransportFactory } from '../mailer/interfaces/mailer-transport-factory.interface';\n\nimport { HandlebarsAdapter } from '../mailer/adapters/handlebars.adapter';\nimport { PugAdapter } from '../mailer/adapters/pug.adapter';\nimport { EjsAdapter } from '../mailer/adapters/ejs.adapter';\n\nimport { MailerService } from '../mailer/services/mailer.service';\n\nconst template_path = pathJoin(__dirname, 'utils/test-templates');\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise<MailerService> {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get<MailerService>(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) => void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, 'send')\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) => void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: 'ABCD',\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: 'ok',\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise<MailerService> {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: 'localhost', port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get<MailerService>(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe('MailerService', () => {\n  it('should not be defined if a transport is not provided', async () => {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it('should accept a smtp transport string', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transports string', async () => {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) => {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it('should accept smtp transport options', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: 'user@domain.com',\n          pass: 'pass',\n        },\n        options: {\n          host: 'smtp.domain.com',\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transport instance', async () => {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it('should send emails with nodemailer', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer transports', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    await service.sendMail({\n      transporterName: 'myDomain',\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer with different transports name', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n        },\n      });\n\n      await service.sendMail({\n        transporterName: 'testDomain',\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\"Transporters object doesn't have testDomain key\");\n    }\n  });\n\n  it('should send emails with nodemailer without transports', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe('Transporter object undefined');\n    }\n  });\n\n  it('should use mailerOptions.defaults when send emails', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n      defaults: {\n        from: 'user1@example.test',\n      },\n    });\n\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n  });\n\n  it('should use custom transport to send mail', async () => {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it('should compile template with the handlebars adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with error template path', async () => {\n    let templatePath = pathJoin(template_path, '/handlebars-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.hbs'`,\n      );\n    }\n  });\n\n  it('should compile template with the handlebars adapter with disabled inline-css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) => {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the handlebars adapter with enabled inline-css and media query', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: ' ', preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the pug adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/pug-templates');\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          world: 'World',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open '${templatePath}.pug'`);\n    }\n  });\n\n  it('should compile template with the pug adapter without inline css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Pug test template.</p><p>Hello World!</p>');\n  });\n\n  it('should compile template with the ejs adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/ejs-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.ejs'`,\n      );\n    }\n  });\n\n  it('should compile template with the ejs adapter read template relative url', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter without css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Ejs test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n});\n",
              "err": {},
              "uuid": "c05d45f8-ce4a-4d38-b6df-0de7883d9db0",
              "parentUUID": "523b2ad6-7258-473b-8a13-419105450da5",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "MailerService > should compile template with the handlebars adapter",
              "title": "MailerService > should compile template with the handlebars adapter",
              "timedOut": false,
              "duration": 18,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { pathJoin } from '@tresdoce-nestjs-toolkit/test-utils';\nimport * as nodemailerMock from 'nodemailer-mock';\nimport MailMessage from 'nodemailer/lib/mailer/mail-message';\nimport SMTPTransport from 'nodemailer/lib/smtp-transport';\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from '../mailer/constants/mailer.constant';\n\nimport { MailerOptions, TransportType } from '../mailer/interfaces/mailer-options.interface';\nimport { MailerTransportFactory } from '../mailer/interfaces/mailer-transport-factory.interface';\n\nimport { HandlebarsAdapter } from '../mailer/adapters/handlebars.adapter';\nimport { PugAdapter } from '../mailer/adapters/pug.adapter';\nimport { EjsAdapter } from '../mailer/adapters/ejs.adapter';\n\nimport { MailerService } from '../mailer/services/mailer.service';\n\nconst template_path = pathJoin(__dirname, 'utils/test-templates');\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise<MailerService> {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get<MailerService>(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) => void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, 'send')\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) => void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: 'ABCD',\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: 'ok',\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise<MailerService> {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: 'localhost', port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get<MailerService>(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe('MailerService', () => {\n  it('should not be defined if a transport is not provided', async () => {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it('should accept a smtp transport string', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transports string', async () => {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) => {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it('should accept smtp transport options', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: 'user@domain.com',\n          pass: 'pass',\n        },\n        options: {\n          host: 'smtp.domain.com',\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transport instance', async () => {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it('should send emails with nodemailer', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer transports', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    await service.sendMail({\n      transporterName: 'myDomain',\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer with different transports name', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n        },\n      });\n\n      await service.sendMail({\n        transporterName: 'testDomain',\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\"Transporters object doesn't have testDomain key\");\n    }\n  });\n\n  it('should send emails with nodemailer without transports', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe('Transporter object undefined');\n    }\n  });\n\n  it('should use mailerOptions.defaults when send emails', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n      defaults: {\n        from: 'user1@example.test',\n      },\n    });\n\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n  });\n\n  it('should use custom transport to send mail', async () => {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it('should compile template with the handlebars adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with error template path', async () => {\n    let templatePath = pathJoin(template_path, '/handlebars-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.hbs'`,\n      );\n    }\n  });\n\n  it('should compile template with the handlebars adapter with disabled inline-css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) => {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the handlebars adapter with enabled inline-css and media query', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: ' ', preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the pug adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/pug-templates');\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          world: 'World',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open '${templatePath}.pug'`);\n    }\n  });\n\n  it('should compile template with the pug adapter without inline css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Pug test template.</p><p>Hello World!</p>');\n  });\n\n  it('should compile template with the ejs adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/ejs-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.ejs'`,\n      );\n    }\n  });\n\n  it('should compile template with the ejs adapter read template relative url', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter without css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Ejs test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n});\n",
              "err": {},
              "uuid": "2a6fdb36-4f31-48f0-89a9-24d224552b43",
              "parentUUID": "523b2ad6-7258-473b-8a13-419105450da5",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "MailerService > should compile template with the handlebars adapter with relative path",
              "title": "MailerService > should compile template with the handlebars adapter with relative path",
              "timedOut": false,
              "duration": 18,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { pathJoin } from '@tresdoce-nestjs-toolkit/test-utils';\nimport * as nodemailerMock from 'nodemailer-mock';\nimport MailMessage from 'nodemailer/lib/mailer/mail-message';\nimport SMTPTransport from 'nodemailer/lib/smtp-transport';\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from '../mailer/constants/mailer.constant';\n\nimport { MailerOptions, TransportType } from '../mailer/interfaces/mailer-options.interface';\nimport { MailerTransportFactory } from '../mailer/interfaces/mailer-transport-factory.interface';\n\nimport { HandlebarsAdapter } from '../mailer/adapters/handlebars.adapter';\nimport { PugAdapter } from '../mailer/adapters/pug.adapter';\nimport { EjsAdapter } from '../mailer/adapters/ejs.adapter';\n\nimport { MailerService } from '../mailer/services/mailer.service';\n\nconst template_path = pathJoin(__dirname, 'utils/test-templates');\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise<MailerService> {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get<MailerService>(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) => void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, 'send')\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) => void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: 'ABCD',\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: 'ok',\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise<MailerService> {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: 'localhost', port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get<MailerService>(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe('MailerService', () => {\n  it('should not be defined if a transport is not provided', async () => {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it('should accept a smtp transport string', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transports string', async () => {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) => {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it('should accept smtp transport options', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: 'user@domain.com',\n          pass: 'pass',\n        },\n        options: {\n          host: 'smtp.domain.com',\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transport instance', async () => {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it('should send emails with nodemailer', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer transports', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    await service.sendMail({\n      transporterName: 'myDomain',\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer with different transports name', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n        },\n      });\n\n      await service.sendMail({\n        transporterName: 'testDomain',\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\"Transporters object doesn't have testDomain key\");\n    }\n  });\n\n  it('should send emails with nodemailer without transports', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe('Transporter object undefined');\n    }\n  });\n\n  it('should use mailerOptions.defaults when send emails', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n      defaults: {\n        from: 'user1@example.test',\n      },\n    });\n\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n  });\n\n  it('should use custom transport to send mail', async () => {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it('should compile template with the handlebars adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with error template path', async () => {\n    let templatePath = pathJoin(template_path, '/handlebars-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.hbs'`,\n      );\n    }\n  });\n\n  it('should compile template with the handlebars adapter with disabled inline-css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) => {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the handlebars adapter with enabled inline-css and media query', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: ' ', preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the pug adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/pug-templates');\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          world: 'World',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open '${templatePath}.pug'`);\n    }\n  });\n\n  it('should compile template with the pug adapter without inline css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Pug test template.</p><p>Hello World!</p>');\n  });\n\n  it('should compile template with the ejs adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/ejs-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.ejs'`,\n      );\n    }\n  });\n\n  it('should compile template with the ejs adapter read template relative url', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter without css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Ejs test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n});\n",
              "err": {},
              "uuid": "87647877-9657-40b2-a705-368180177047",
              "parentUUID": "523b2ad6-7258-473b-8a13-419105450da5",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "MailerService > should compile template with the handlebars adapter with error template path",
              "title": "MailerService > should compile template with the handlebars adapter with error template path",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { pathJoin } from '@tresdoce-nestjs-toolkit/test-utils';\nimport * as nodemailerMock from 'nodemailer-mock';\nimport MailMessage from 'nodemailer/lib/mailer/mail-message';\nimport SMTPTransport from 'nodemailer/lib/smtp-transport';\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from '../mailer/constants/mailer.constant';\n\nimport { MailerOptions, TransportType } from '../mailer/interfaces/mailer-options.interface';\nimport { MailerTransportFactory } from '../mailer/interfaces/mailer-transport-factory.interface';\n\nimport { HandlebarsAdapter } from '../mailer/adapters/handlebars.adapter';\nimport { PugAdapter } from '../mailer/adapters/pug.adapter';\nimport { EjsAdapter } from '../mailer/adapters/ejs.adapter';\n\nimport { MailerService } from '../mailer/services/mailer.service';\n\nconst template_path = pathJoin(__dirname, 'utils/test-templates');\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise<MailerService> {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get<MailerService>(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) => void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, 'send')\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) => void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: 'ABCD',\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: 'ok',\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise<MailerService> {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: 'localhost', port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get<MailerService>(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe('MailerService', () => {\n  it('should not be defined if a transport is not provided', async () => {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it('should accept a smtp transport string', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transports string', async () => {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) => {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it('should accept smtp transport options', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: 'user@domain.com',\n          pass: 'pass',\n        },\n        options: {\n          host: 'smtp.domain.com',\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transport instance', async () => {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it('should send emails with nodemailer', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer transports', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    await service.sendMail({\n      transporterName: 'myDomain',\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer with different transports name', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n        },\n      });\n\n      await service.sendMail({\n        transporterName: 'testDomain',\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\"Transporters object doesn't have testDomain key\");\n    }\n  });\n\n  it('should send emails with nodemailer without transports', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe('Transporter object undefined');\n    }\n  });\n\n  it('should use mailerOptions.defaults when send emails', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n      defaults: {\n        from: 'user1@example.test',\n      },\n    });\n\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n  });\n\n  it('should use custom transport to send mail', async () => {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it('should compile template with the handlebars adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with error template path', async () => {\n    let templatePath = pathJoin(template_path, '/handlebars-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.hbs'`,\n      );\n    }\n  });\n\n  it('should compile template with the handlebars adapter with disabled inline-css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) => {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the handlebars adapter with enabled inline-css and media query', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: ' ', preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the pug adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/pug-templates');\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          world: 'World',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open '${templatePath}.pug'`);\n    }\n  });\n\n  it('should compile template with the pug adapter without inline css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Pug test template.</p><p>Hello World!</p>');\n  });\n\n  it('should compile template with the ejs adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/ejs-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.ejs'`,\n      );\n    }\n  });\n\n  it('should compile template with the ejs adapter read template relative url', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter without css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Ejs test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n});\n",
              "err": {},
              "uuid": "3b9b66c6-5fe8-4148-885e-bb110a2221dc",
              "parentUUID": "523b2ad6-7258-473b-8a13-419105450da5",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "MailerService > should compile template with the handlebars adapter with disabled inline-css",
              "title": "MailerService > should compile template with the handlebars adapter with disabled inline-css",
              "timedOut": false,
              "duration": 3,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { pathJoin } from '@tresdoce-nestjs-toolkit/test-utils';\nimport * as nodemailerMock from 'nodemailer-mock';\nimport MailMessage from 'nodemailer/lib/mailer/mail-message';\nimport SMTPTransport from 'nodemailer/lib/smtp-transport';\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from '../mailer/constants/mailer.constant';\n\nimport { MailerOptions, TransportType } from '../mailer/interfaces/mailer-options.interface';\nimport { MailerTransportFactory } from '../mailer/interfaces/mailer-transport-factory.interface';\n\nimport { HandlebarsAdapter } from '../mailer/adapters/handlebars.adapter';\nimport { PugAdapter } from '../mailer/adapters/pug.adapter';\nimport { EjsAdapter } from '../mailer/adapters/ejs.adapter';\n\nimport { MailerService } from '../mailer/services/mailer.service';\n\nconst template_path = pathJoin(__dirname, 'utils/test-templates');\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise<MailerService> {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get<MailerService>(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) => void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, 'send')\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) => void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: 'ABCD',\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: 'ok',\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise<MailerService> {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: 'localhost', port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get<MailerService>(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe('MailerService', () => {\n  it('should not be defined if a transport is not provided', async () => {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it('should accept a smtp transport string', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transports string', async () => {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) => {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it('should accept smtp transport options', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: 'user@domain.com',\n          pass: 'pass',\n        },\n        options: {\n          host: 'smtp.domain.com',\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transport instance', async () => {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it('should send emails with nodemailer', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer transports', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    await service.sendMail({\n      transporterName: 'myDomain',\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer with different transports name', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n        },\n      });\n\n      await service.sendMail({\n        transporterName: 'testDomain',\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\"Transporters object doesn't have testDomain key\");\n    }\n  });\n\n  it('should send emails with nodemailer without transports', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe('Transporter object undefined');\n    }\n  });\n\n  it('should use mailerOptions.defaults when send emails', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n      defaults: {\n        from: 'user1@example.test',\n      },\n    });\n\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n  });\n\n  it('should use custom transport to send mail', async () => {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it('should compile template with the handlebars adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with error template path', async () => {\n    let templatePath = pathJoin(template_path, '/handlebars-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.hbs'`,\n      );\n    }\n  });\n\n  it('should compile template with the handlebars adapter with disabled inline-css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) => {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the handlebars adapter with enabled inline-css and media query', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: ' ', preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the pug adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/pug-templates');\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          world: 'World',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open '${templatePath}.pug'`);\n    }\n  });\n\n  it('should compile template with the pug adapter without inline css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Pug test template.</p><p>Hello World!</p>');\n  });\n\n  it('should compile template with the ejs adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/ejs-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.ejs'`,\n      );\n    }\n  });\n\n  it('should compile template with the ejs adapter read template relative url', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter without css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Ejs test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n});\n",
              "err": {},
              "uuid": "b534aa8f-d114-4f80-9d3d-4f3547e59479",
              "parentUUID": "523b2ad6-7258-473b-8a13-419105450da5",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "MailerService > should compile template with the handlebars adapter with enabled inline-css and media query",
              "title": "MailerService > should compile template with the handlebars adapter with enabled inline-css and media query",
              "timedOut": false,
              "duration": 6,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { pathJoin } from '@tresdoce-nestjs-toolkit/test-utils';\nimport * as nodemailerMock from 'nodemailer-mock';\nimport MailMessage from 'nodemailer/lib/mailer/mail-message';\nimport SMTPTransport from 'nodemailer/lib/smtp-transport';\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from '../mailer/constants/mailer.constant';\n\nimport { MailerOptions, TransportType } from '../mailer/interfaces/mailer-options.interface';\nimport { MailerTransportFactory } from '../mailer/interfaces/mailer-transport-factory.interface';\n\nimport { HandlebarsAdapter } from '../mailer/adapters/handlebars.adapter';\nimport { PugAdapter } from '../mailer/adapters/pug.adapter';\nimport { EjsAdapter } from '../mailer/adapters/ejs.adapter';\n\nimport { MailerService } from '../mailer/services/mailer.service';\n\nconst template_path = pathJoin(__dirname, 'utils/test-templates');\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise<MailerService> {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get<MailerService>(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) => void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, 'send')\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) => void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: 'ABCD',\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: 'ok',\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise<MailerService> {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: 'localhost', port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get<MailerService>(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe('MailerService', () => {\n  it('should not be defined if a transport is not provided', async () => {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it('should accept a smtp transport string', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transports string', async () => {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) => {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it('should accept smtp transport options', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: 'user@domain.com',\n          pass: 'pass',\n        },\n        options: {\n          host: 'smtp.domain.com',\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transport instance', async () => {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it('should send emails with nodemailer', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer transports', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    await service.sendMail({\n      transporterName: 'myDomain',\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer with different transports name', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n        },\n      });\n\n      await service.sendMail({\n        transporterName: 'testDomain',\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\"Transporters object doesn't have testDomain key\");\n    }\n  });\n\n  it('should send emails with nodemailer without transports', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe('Transporter object undefined');\n    }\n  });\n\n  it('should use mailerOptions.defaults when send emails', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n      defaults: {\n        from: 'user1@example.test',\n      },\n    });\n\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n  });\n\n  it('should use custom transport to send mail', async () => {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it('should compile template with the handlebars adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with error template path', async () => {\n    let templatePath = pathJoin(template_path, '/handlebars-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.hbs'`,\n      );\n    }\n  });\n\n  it('should compile template with the handlebars adapter with disabled inline-css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) => {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the handlebars adapter with enabled inline-css and media query', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: ' ', preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the pug adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/pug-templates');\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          world: 'World',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open '${templatePath}.pug'`);\n    }\n  });\n\n  it('should compile template with the pug adapter without inline css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Pug test template.</p><p>Hello World!</p>');\n  });\n\n  it('should compile template with the ejs adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/ejs-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.ejs'`,\n      );\n    }\n  });\n\n  it('should compile template with the ejs adapter read template relative url', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter without css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Ejs test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n});\n",
              "err": {},
              "uuid": "e901561e-400c-469f-b96e-afeb05986f15",
              "parentUUID": "523b2ad6-7258-473b-8a13-419105450da5",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "MailerService > should compile template with the pug adapter",
              "title": "MailerService > should compile template with the pug adapter",
              "timedOut": false,
              "duration": 22,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { pathJoin } from '@tresdoce-nestjs-toolkit/test-utils';\nimport * as nodemailerMock from 'nodemailer-mock';\nimport MailMessage from 'nodemailer/lib/mailer/mail-message';\nimport SMTPTransport from 'nodemailer/lib/smtp-transport';\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from '../mailer/constants/mailer.constant';\n\nimport { MailerOptions, TransportType } from '../mailer/interfaces/mailer-options.interface';\nimport { MailerTransportFactory } from '../mailer/interfaces/mailer-transport-factory.interface';\n\nimport { HandlebarsAdapter } from '../mailer/adapters/handlebars.adapter';\nimport { PugAdapter } from '../mailer/adapters/pug.adapter';\nimport { EjsAdapter } from '../mailer/adapters/ejs.adapter';\n\nimport { MailerService } from '../mailer/services/mailer.service';\n\nconst template_path = pathJoin(__dirname, 'utils/test-templates');\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise<MailerService> {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get<MailerService>(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) => void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, 'send')\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) => void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: 'ABCD',\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: 'ok',\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise<MailerService> {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: 'localhost', port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get<MailerService>(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe('MailerService', () => {\n  it('should not be defined if a transport is not provided', async () => {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it('should accept a smtp transport string', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transports string', async () => {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) => {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it('should accept smtp transport options', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: 'user@domain.com',\n          pass: 'pass',\n        },\n        options: {\n          host: 'smtp.domain.com',\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transport instance', async () => {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it('should send emails with nodemailer', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer transports', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    await service.sendMail({\n      transporterName: 'myDomain',\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer with different transports name', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n        },\n      });\n\n      await service.sendMail({\n        transporterName: 'testDomain',\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\"Transporters object doesn't have testDomain key\");\n    }\n  });\n\n  it('should send emails with nodemailer without transports', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe('Transporter object undefined');\n    }\n  });\n\n  it('should use mailerOptions.defaults when send emails', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n      defaults: {\n        from: 'user1@example.test',\n      },\n    });\n\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n  });\n\n  it('should use custom transport to send mail', async () => {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it('should compile template with the handlebars adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with error template path', async () => {\n    let templatePath = pathJoin(template_path, '/handlebars-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.hbs'`,\n      );\n    }\n  });\n\n  it('should compile template with the handlebars adapter with disabled inline-css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) => {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the handlebars adapter with enabled inline-css and media query', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: ' ', preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the pug adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/pug-templates');\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          world: 'World',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open '${templatePath}.pug'`);\n    }\n  });\n\n  it('should compile template with the pug adapter without inline css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Pug test template.</p><p>Hello World!</p>');\n  });\n\n  it('should compile template with the ejs adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/ejs-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.ejs'`,\n      );\n    }\n  });\n\n  it('should compile template with the ejs adapter read template relative url', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter without css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Ejs test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n});\n",
              "err": {},
              "uuid": "565c2b07-6dd1-4bab-b284-8a492ad4dfb0",
              "parentUUID": "523b2ad6-7258-473b-8a13-419105450da5",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "MailerService > should compile template with the pug adapter with relative path",
              "title": "MailerService > should compile template with the pug adapter with relative path",
              "timedOut": false,
              "duration": 6,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { pathJoin } from '@tresdoce-nestjs-toolkit/test-utils';\nimport * as nodemailerMock from 'nodemailer-mock';\nimport MailMessage from 'nodemailer/lib/mailer/mail-message';\nimport SMTPTransport from 'nodemailer/lib/smtp-transport';\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from '../mailer/constants/mailer.constant';\n\nimport { MailerOptions, TransportType } from '../mailer/interfaces/mailer-options.interface';\nimport { MailerTransportFactory } from '../mailer/interfaces/mailer-transport-factory.interface';\n\nimport { HandlebarsAdapter } from '../mailer/adapters/handlebars.adapter';\nimport { PugAdapter } from '../mailer/adapters/pug.adapter';\nimport { EjsAdapter } from '../mailer/adapters/ejs.adapter';\n\nimport { MailerService } from '../mailer/services/mailer.service';\n\nconst template_path = pathJoin(__dirname, 'utils/test-templates');\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise<MailerService> {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get<MailerService>(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) => void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, 'send')\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) => void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: 'ABCD',\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: 'ok',\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise<MailerService> {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: 'localhost', port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get<MailerService>(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe('MailerService', () => {\n  it('should not be defined if a transport is not provided', async () => {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it('should accept a smtp transport string', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transports string', async () => {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) => {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it('should accept smtp transport options', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: 'user@domain.com',\n          pass: 'pass',\n        },\n        options: {\n          host: 'smtp.domain.com',\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transport instance', async () => {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it('should send emails with nodemailer', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer transports', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    await service.sendMail({\n      transporterName: 'myDomain',\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer with different transports name', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n        },\n      });\n\n      await service.sendMail({\n        transporterName: 'testDomain',\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\"Transporters object doesn't have testDomain key\");\n    }\n  });\n\n  it('should send emails with nodemailer without transports', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe('Transporter object undefined');\n    }\n  });\n\n  it('should use mailerOptions.defaults when send emails', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n      defaults: {\n        from: 'user1@example.test',\n      },\n    });\n\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n  });\n\n  it('should use custom transport to send mail', async () => {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it('should compile template with the handlebars adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with error template path', async () => {\n    let templatePath = pathJoin(template_path, '/handlebars-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.hbs'`,\n      );\n    }\n  });\n\n  it('should compile template with the handlebars adapter with disabled inline-css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) => {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the handlebars adapter with enabled inline-css and media query', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: ' ', preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the pug adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/pug-templates');\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          world: 'World',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open '${templatePath}.pug'`);\n    }\n  });\n\n  it('should compile template with the pug adapter without inline css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Pug test template.</p><p>Hello World!</p>');\n  });\n\n  it('should compile template with the ejs adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/ejs-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.ejs'`,\n      );\n    }\n  });\n\n  it('should compile template with the ejs adapter read template relative url', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter without css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Ejs test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n});\n",
              "err": {},
              "uuid": "1b264ffd-e064-4064-a6c6-43c5bebb378a",
              "parentUUID": "523b2ad6-7258-473b-8a13-419105450da5",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "MailerService > should compile template with the pug adapter with error to read template",
              "title": "MailerService > should compile template with the pug adapter with error to read template",
              "timedOut": false,
              "duration": 4,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { pathJoin } from '@tresdoce-nestjs-toolkit/test-utils';\nimport * as nodemailerMock from 'nodemailer-mock';\nimport MailMessage from 'nodemailer/lib/mailer/mail-message';\nimport SMTPTransport from 'nodemailer/lib/smtp-transport';\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from '../mailer/constants/mailer.constant';\n\nimport { MailerOptions, TransportType } from '../mailer/interfaces/mailer-options.interface';\nimport { MailerTransportFactory } from '../mailer/interfaces/mailer-transport-factory.interface';\n\nimport { HandlebarsAdapter } from '../mailer/adapters/handlebars.adapter';\nimport { PugAdapter } from '../mailer/adapters/pug.adapter';\nimport { EjsAdapter } from '../mailer/adapters/ejs.adapter';\n\nimport { MailerService } from '../mailer/services/mailer.service';\n\nconst template_path = pathJoin(__dirname, 'utils/test-templates');\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise<MailerService> {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get<MailerService>(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) => void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, 'send')\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) => void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: 'ABCD',\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: 'ok',\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise<MailerService> {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: 'localhost', port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get<MailerService>(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe('MailerService', () => {\n  it('should not be defined if a transport is not provided', async () => {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it('should accept a smtp transport string', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transports string', async () => {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) => {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it('should accept smtp transport options', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: 'user@domain.com',\n          pass: 'pass',\n        },\n        options: {\n          host: 'smtp.domain.com',\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transport instance', async () => {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it('should send emails with nodemailer', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer transports', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    await service.sendMail({\n      transporterName: 'myDomain',\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer with different transports name', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n        },\n      });\n\n      await service.sendMail({\n        transporterName: 'testDomain',\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\"Transporters object doesn't have testDomain key\");\n    }\n  });\n\n  it('should send emails with nodemailer without transports', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe('Transporter object undefined');\n    }\n  });\n\n  it('should use mailerOptions.defaults when send emails', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n      defaults: {\n        from: 'user1@example.test',\n      },\n    });\n\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n  });\n\n  it('should use custom transport to send mail', async () => {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it('should compile template with the handlebars adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with error template path', async () => {\n    let templatePath = pathJoin(template_path, '/handlebars-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.hbs'`,\n      );\n    }\n  });\n\n  it('should compile template with the handlebars adapter with disabled inline-css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) => {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the handlebars adapter with enabled inline-css and media query', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: ' ', preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the pug adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/pug-templates');\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          world: 'World',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open '${templatePath}.pug'`);\n    }\n  });\n\n  it('should compile template with the pug adapter without inline css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Pug test template.</p><p>Hello World!</p>');\n  });\n\n  it('should compile template with the ejs adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/ejs-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.ejs'`,\n      );\n    }\n  });\n\n  it('should compile template with the ejs adapter read template relative url', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter without css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Ejs test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n});\n",
              "err": {},
              "uuid": "a311b1a6-3fe6-416b-b8f8-7c40be31b31d",
              "parentUUID": "523b2ad6-7258-473b-8a13-419105450da5",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "MailerService > should compile template with the pug adapter without inline css",
              "title": "MailerService > should compile template with the pug adapter without inline css",
              "timedOut": false,
              "duration": 4,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { pathJoin } from '@tresdoce-nestjs-toolkit/test-utils';\nimport * as nodemailerMock from 'nodemailer-mock';\nimport MailMessage from 'nodemailer/lib/mailer/mail-message';\nimport SMTPTransport from 'nodemailer/lib/smtp-transport';\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from '../mailer/constants/mailer.constant';\n\nimport { MailerOptions, TransportType } from '../mailer/interfaces/mailer-options.interface';\nimport { MailerTransportFactory } from '../mailer/interfaces/mailer-transport-factory.interface';\n\nimport { HandlebarsAdapter } from '../mailer/adapters/handlebars.adapter';\nimport { PugAdapter } from '../mailer/adapters/pug.adapter';\nimport { EjsAdapter } from '../mailer/adapters/ejs.adapter';\n\nimport { MailerService } from '../mailer/services/mailer.service';\n\nconst template_path = pathJoin(__dirname, 'utils/test-templates');\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise<MailerService> {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get<MailerService>(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) => void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, 'send')\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) => void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: 'ABCD',\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: 'ok',\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise<MailerService> {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: 'localhost', port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get<MailerService>(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe('MailerService', () => {\n  it('should not be defined if a transport is not provided', async () => {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it('should accept a smtp transport string', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transports string', async () => {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) => {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it('should accept smtp transport options', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: 'user@domain.com',\n          pass: 'pass',\n        },\n        options: {\n          host: 'smtp.domain.com',\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transport instance', async () => {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it('should send emails with nodemailer', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer transports', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    await service.sendMail({\n      transporterName: 'myDomain',\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer with different transports name', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n        },\n      });\n\n      await service.sendMail({\n        transporterName: 'testDomain',\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\"Transporters object doesn't have testDomain key\");\n    }\n  });\n\n  it('should send emails with nodemailer without transports', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe('Transporter object undefined');\n    }\n  });\n\n  it('should use mailerOptions.defaults when send emails', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n      defaults: {\n        from: 'user1@example.test',\n      },\n    });\n\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n  });\n\n  it('should use custom transport to send mail', async () => {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it('should compile template with the handlebars adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with error template path', async () => {\n    let templatePath = pathJoin(template_path, '/handlebars-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.hbs'`,\n      );\n    }\n  });\n\n  it('should compile template with the handlebars adapter with disabled inline-css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) => {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the handlebars adapter with enabled inline-css and media query', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: ' ', preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the pug adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/pug-templates');\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          world: 'World',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open '${templatePath}.pug'`);\n    }\n  });\n\n  it('should compile template with the pug adapter without inline css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Pug test template.</p><p>Hello World!</p>');\n  });\n\n  it('should compile template with the ejs adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/ejs-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.ejs'`,\n      );\n    }\n  });\n\n  it('should compile template with the ejs adapter read template relative url', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter without css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Ejs test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n});\n",
              "err": {},
              "uuid": "defab326-b749-4d51-818e-1b0064d7db1a",
              "parentUUID": "523b2ad6-7258-473b-8a13-419105450da5",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "MailerService > should compile template with the ejs adapter",
              "title": "MailerService > should compile template with the ejs adapter",
              "timedOut": false,
              "duration": 4,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { pathJoin } from '@tresdoce-nestjs-toolkit/test-utils';\nimport * as nodemailerMock from 'nodemailer-mock';\nimport MailMessage from 'nodemailer/lib/mailer/mail-message';\nimport SMTPTransport from 'nodemailer/lib/smtp-transport';\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from '../mailer/constants/mailer.constant';\n\nimport { MailerOptions, TransportType } from '../mailer/interfaces/mailer-options.interface';\nimport { MailerTransportFactory } from '../mailer/interfaces/mailer-transport-factory.interface';\n\nimport { HandlebarsAdapter } from '../mailer/adapters/handlebars.adapter';\nimport { PugAdapter } from '../mailer/adapters/pug.adapter';\nimport { EjsAdapter } from '../mailer/adapters/ejs.adapter';\n\nimport { MailerService } from '../mailer/services/mailer.service';\n\nconst template_path = pathJoin(__dirname, 'utils/test-templates');\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise<MailerService> {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get<MailerService>(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) => void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, 'send')\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) => void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: 'ABCD',\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: 'ok',\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise<MailerService> {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: 'localhost', port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get<MailerService>(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe('MailerService', () => {\n  it('should not be defined if a transport is not provided', async () => {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it('should accept a smtp transport string', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transports string', async () => {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) => {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it('should accept smtp transport options', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: 'user@domain.com',\n          pass: 'pass',\n        },\n        options: {\n          host: 'smtp.domain.com',\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transport instance', async () => {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it('should send emails with nodemailer', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer transports', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    await service.sendMail({\n      transporterName: 'myDomain',\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer with different transports name', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n        },\n      });\n\n      await service.sendMail({\n        transporterName: 'testDomain',\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\"Transporters object doesn't have testDomain key\");\n    }\n  });\n\n  it('should send emails with nodemailer without transports', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe('Transporter object undefined');\n    }\n  });\n\n  it('should use mailerOptions.defaults when send emails', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n      defaults: {\n        from: 'user1@example.test',\n      },\n    });\n\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n  });\n\n  it('should use custom transport to send mail', async () => {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it('should compile template with the handlebars adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with error template path', async () => {\n    let templatePath = pathJoin(template_path, '/handlebars-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.hbs'`,\n      );\n    }\n  });\n\n  it('should compile template with the handlebars adapter with disabled inline-css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) => {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the handlebars adapter with enabled inline-css and media query', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: ' ', preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the pug adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/pug-templates');\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          world: 'World',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open '${templatePath}.pug'`);\n    }\n  });\n\n  it('should compile template with the pug adapter without inline css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Pug test template.</p><p>Hello World!</p>');\n  });\n\n  it('should compile template with the ejs adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/ejs-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.ejs'`,\n      );\n    }\n  });\n\n  it('should compile template with the ejs adapter read template relative url', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter without css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Ejs test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n});\n",
              "err": {},
              "uuid": "eda902ed-9e69-47e5-9bed-c5439cedbf17",
              "parentUUID": "523b2ad6-7258-473b-8a13-419105450da5",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "MailerService > should compile template with the ejs adapter with error to read template",
              "title": "MailerService > should compile template with the ejs adapter with error to read template",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { pathJoin } from '@tresdoce-nestjs-toolkit/test-utils';\nimport * as nodemailerMock from 'nodemailer-mock';\nimport MailMessage from 'nodemailer/lib/mailer/mail-message';\nimport SMTPTransport from 'nodemailer/lib/smtp-transport';\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from '../mailer/constants/mailer.constant';\n\nimport { MailerOptions, TransportType } from '../mailer/interfaces/mailer-options.interface';\nimport { MailerTransportFactory } from '../mailer/interfaces/mailer-transport-factory.interface';\n\nimport { HandlebarsAdapter } from '../mailer/adapters/handlebars.adapter';\nimport { PugAdapter } from '../mailer/adapters/pug.adapter';\nimport { EjsAdapter } from '../mailer/adapters/ejs.adapter';\n\nimport { MailerService } from '../mailer/services/mailer.service';\n\nconst template_path = pathJoin(__dirname, 'utils/test-templates');\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise<MailerService> {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get<MailerService>(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) => void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, 'send')\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) => void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: 'ABCD',\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: 'ok',\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise<MailerService> {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: 'localhost', port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get<MailerService>(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe('MailerService', () => {\n  it('should not be defined if a transport is not provided', async () => {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it('should accept a smtp transport string', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transports string', async () => {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) => {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it('should accept smtp transport options', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: 'user@domain.com',\n          pass: 'pass',\n        },\n        options: {\n          host: 'smtp.domain.com',\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transport instance', async () => {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it('should send emails with nodemailer', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer transports', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    await service.sendMail({\n      transporterName: 'myDomain',\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer with different transports name', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n        },\n      });\n\n      await service.sendMail({\n        transporterName: 'testDomain',\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\"Transporters object doesn't have testDomain key\");\n    }\n  });\n\n  it('should send emails with nodemailer without transports', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe('Transporter object undefined');\n    }\n  });\n\n  it('should use mailerOptions.defaults when send emails', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n      defaults: {\n        from: 'user1@example.test',\n      },\n    });\n\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n  });\n\n  it('should use custom transport to send mail', async () => {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it('should compile template with the handlebars adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with error template path', async () => {\n    let templatePath = pathJoin(template_path, '/handlebars-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.hbs'`,\n      );\n    }\n  });\n\n  it('should compile template with the handlebars adapter with disabled inline-css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) => {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the handlebars adapter with enabled inline-css and media query', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: ' ', preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the pug adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/pug-templates');\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          world: 'World',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open '${templatePath}.pug'`);\n    }\n  });\n\n  it('should compile template with the pug adapter without inline css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Pug test template.</p><p>Hello World!</p>');\n  });\n\n  it('should compile template with the ejs adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/ejs-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.ejs'`,\n      );\n    }\n  });\n\n  it('should compile template with the ejs adapter read template relative url', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter without css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Ejs test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n});\n",
              "err": {},
              "uuid": "c0889da1-14e0-4910-8a9a-4892115a4b2a",
              "parentUUID": "523b2ad6-7258-473b-8a13-419105450da5",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "MailerService > should compile template with the ejs adapter read template relative url",
              "title": "MailerService > should compile template with the ejs adapter read template relative url",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { pathJoin } from '@tresdoce-nestjs-toolkit/test-utils';\nimport * as nodemailerMock from 'nodemailer-mock';\nimport MailMessage from 'nodemailer/lib/mailer/mail-message';\nimport SMTPTransport from 'nodemailer/lib/smtp-transport';\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from '../mailer/constants/mailer.constant';\n\nimport { MailerOptions, TransportType } from '../mailer/interfaces/mailer-options.interface';\nimport { MailerTransportFactory } from '../mailer/interfaces/mailer-transport-factory.interface';\n\nimport { HandlebarsAdapter } from '../mailer/adapters/handlebars.adapter';\nimport { PugAdapter } from '../mailer/adapters/pug.adapter';\nimport { EjsAdapter } from '../mailer/adapters/ejs.adapter';\n\nimport { MailerService } from '../mailer/services/mailer.service';\n\nconst template_path = pathJoin(__dirname, 'utils/test-templates');\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise<MailerService> {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get<MailerService>(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) => void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, 'send')\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) => void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: 'ABCD',\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: 'ok',\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise<MailerService> {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: 'localhost', port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get<MailerService>(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe('MailerService', () => {\n  it('should not be defined if a transport is not provided', async () => {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it('should accept a smtp transport string', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transports string', async () => {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) => {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it('should accept smtp transport options', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: 'user@domain.com',\n          pass: 'pass',\n        },\n        options: {\n          host: 'smtp.domain.com',\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transport instance', async () => {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it('should send emails with nodemailer', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer transports', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    await service.sendMail({\n      transporterName: 'myDomain',\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer with different transports name', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n        },\n      });\n\n      await service.sendMail({\n        transporterName: 'testDomain',\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\"Transporters object doesn't have testDomain key\");\n    }\n  });\n\n  it('should send emails with nodemailer without transports', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe('Transporter object undefined');\n    }\n  });\n\n  it('should use mailerOptions.defaults when send emails', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n      defaults: {\n        from: 'user1@example.test',\n      },\n    });\n\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n  });\n\n  it('should use custom transport to send mail', async () => {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it('should compile template with the handlebars adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with error template path', async () => {\n    let templatePath = pathJoin(template_path, '/handlebars-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.hbs'`,\n      );\n    }\n  });\n\n  it('should compile template with the handlebars adapter with disabled inline-css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) => {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the handlebars adapter with enabled inline-css and media query', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: ' ', preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the pug adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/pug-templates');\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          world: 'World',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open '${templatePath}.pug'`);\n    }\n  });\n\n  it('should compile template with the pug adapter without inline css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Pug test template.</p><p>Hello World!</p>');\n  });\n\n  it('should compile template with the ejs adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/ejs-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.ejs'`,\n      );\n    }\n  });\n\n  it('should compile template with the ejs adapter read template relative url', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter without css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Ejs test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n});\n",
              "err": {},
              "uuid": "d5f75db4-0e47-46dc-a427-6199e7103048",
              "parentUUID": "523b2ad6-7258-473b-8a13-419105450da5",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "MailerService > should compile template with the ejs adapter without css inline",
              "title": "MailerService > should compile template with the ejs adapter without css inline",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { pathJoin } from '@tresdoce-nestjs-toolkit/test-utils';\nimport * as nodemailerMock from 'nodemailer-mock';\nimport MailMessage from 'nodemailer/lib/mailer/mail-message';\nimport SMTPTransport from 'nodemailer/lib/smtp-transport';\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from '../mailer/constants/mailer.constant';\n\nimport { MailerOptions, TransportType } from '../mailer/interfaces/mailer-options.interface';\nimport { MailerTransportFactory } from '../mailer/interfaces/mailer-transport-factory.interface';\n\nimport { HandlebarsAdapter } from '../mailer/adapters/handlebars.adapter';\nimport { PugAdapter } from '../mailer/adapters/pug.adapter';\nimport { EjsAdapter } from '../mailer/adapters/ejs.adapter';\n\nimport { MailerService } from '../mailer/services/mailer.service';\n\nconst template_path = pathJoin(__dirname, 'utils/test-templates');\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise<MailerService> {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get<MailerService>(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) => void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, 'send')\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) => void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: 'ABCD',\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: 'ok',\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise<MailerService> {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: 'localhost', port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get<MailerService>(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe('MailerService', () => {\n  it('should not be defined if a transport is not provided', async () => {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it('should accept a smtp transport string', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transports string', async () => {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) => {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it('should accept smtp transport options', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: 'user@domain.com',\n          pass: 'pass',\n        },\n        options: {\n          host: 'smtp.domain.com',\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transport instance', async () => {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it('should send emails with nodemailer', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer transports', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    await service.sendMail({\n      transporterName: 'myDomain',\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer with different transports name', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n        },\n      });\n\n      await service.sendMail({\n        transporterName: 'testDomain',\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\"Transporters object doesn't have testDomain key\");\n    }\n  });\n\n  it('should send emails with nodemailer without transports', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe('Transporter object undefined');\n    }\n  });\n\n  it('should use mailerOptions.defaults when send emails', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n      defaults: {\n        from: 'user1@example.test',\n      },\n    });\n\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n  });\n\n  it('should use custom transport to send mail', async () => {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it('should compile template with the handlebars adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with error template path', async () => {\n    let templatePath = pathJoin(template_path, '/handlebars-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.hbs'`,\n      );\n    }\n  });\n\n  it('should compile template with the handlebars adapter with disabled inline-css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) => {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the handlebars adapter with enabled inline-css and media query', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: ' ', preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the pug adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/pug-templates');\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          world: 'World',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open '${templatePath}.pug'`);\n    }\n  });\n\n  it('should compile template with the pug adapter without inline css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Pug test template.</p><p>Hello World!</p>');\n  });\n\n  it('should compile template with the ejs adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/ejs-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.ejs'`,\n      );\n    }\n  });\n\n  it('should compile template with the ejs adapter read template relative url', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter without css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Ejs test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n});\n",
              "err": {},
              "uuid": "36108f0f-c968-4658-ab81-7df4312e659f",
              "parentUUID": "523b2ad6-7258-473b-8a13-419105450da5",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "MailerService > should compile template with the ejs adapter with css inline",
              "title": "MailerService > should compile template with the ejs adapter with css inline",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { pathJoin } from '@tresdoce-nestjs-toolkit/test-utils';\nimport * as nodemailerMock from 'nodemailer-mock';\nimport MailMessage from 'nodemailer/lib/mailer/mail-message';\nimport SMTPTransport from 'nodemailer/lib/smtp-transport';\n\nimport { MAILER_OPTIONS, MAILER_TRANSPORT_FACTORY } from '../mailer/constants/mailer.constant';\n\nimport { MailerOptions, TransportType } from '../mailer/interfaces/mailer-options.interface';\nimport { MailerTransportFactory } from '../mailer/interfaces/mailer-transport-factory.interface';\n\nimport { HandlebarsAdapter } from '../mailer/adapters/handlebars.adapter';\nimport { PugAdapter } from '../mailer/adapters/pug.adapter';\nimport { EjsAdapter } from '../mailer/adapters/ejs.adapter';\n\nimport { MailerService } from '../mailer/services/mailer.service';\n\nconst template_path = pathJoin(__dirname, 'utils/test-templates');\n\nasync function getMailerServiceForOptions(options: MailerOptions): Promise<MailerService> {\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      MailerService,\n    ],\n  }).compile();\n\n  return module.get<MailerService>(MailerService);\n}\n\nfunction spyOnSmtpSend(onMail: (mail: MailMessage) => void) {\n  return jest\n    .spyOn(SMTPTransport.prototype, 'send')\n    .mockImplementation(function (\n      mail: MailMessage,\n      callback: (err: Error | null, info: SMTPTransport.SentMessageInfo) => void,\n    ): void {\n      onMail(mail);\n      callback(null, {\n        envelope: {\n          from: mail.data.from as string,\n          to: [mail.data.to as string],\n        },\n        messageId: 'ABCD',\n        accepted: [],\n        rejected: [],\n        pending: [],\n        response: 'ok',\n      });\n    });\n}\n\nasync function getMailerServiceWithCustomTransport(options: MailerOptions): Promise<MailerService> {\n  class TestTransportFactory implements MailerTransportFactory {\n    createTransport(options?: TransportType): any {\n      return nodemailerMock.createTransport({ host: 'localhost', port: -100 });\n    }\n  }\n\n  const module: TestingModule = await Test.createTestingModule({\n    providers: [\n      {\n        name: MAILER_OPTIONS,\n        provide: MAILER_OPTIONS,\n        useValue: options,\n      },\n      {\n        name: MAILER_TRANSPORT_FACTORY,\n        provide: MAILER_TRANSPORT_FACTORY,\n        useClass: TestTransportFactory,\n      },\n      MailerService,\n    ],\n  }).compile();\n  await module.init();\n\n  return module.get<MailerService>(MailerService);\n}\n\njest.setTimeout(70000);\ndescribe('MailerService', () => {\n  it('should not be defined if a transport is not provided', async () => {\n    await expect(getMailerServiceForOptions({})).rejects.toMatchInlineSnapshot(\n      `[Error: Make sure to provide a nodemailer transport configuration object, connection url or a transport plugin instance.]`,\n    );\n  });\n\n  it('should accept a smtp transport string', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transports string', async () => {\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    expect(service).toBeDefined();\n    (service as any).transporters.forEach((value, key) => {\n      expect(value.transporter).toBeInstanceOf(SMTPTransport);\n    });\n  });\n\n  it('should accept smtp transport options', async () => {\n    const service = await getMailerServiceForOptions({\n      transport: {\n        secure: true,\n        requireTLS: true,\n        auth: {\n          user: 'user@domain.com',\n          pass: 'pass',\n        },\n        options: {\n          host: 'smtp.domain.com',\n        },\n      },\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBeInstanceOf(SMTPTransport);\n  });\n\n  it('should accept a smtp transport instance', async () => {\n    const transport = new SMTPTransport({});\n    const service = await getMailerServiceForOptions({\n      transport: transport,\n    });\n\n    expect(service).toBeDefined();\n    expect((service as any).transporter.transporter).toBe(transport);\n  });\n\n  it('should send emails with nodemailer', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer transports', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transports: {\n        myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n      },\n    });\n\n    await service.sendMail({\n      transporterName: 'myDomain',\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.to).toBe('user2@example.test');\n    expect(lastMail.data.subject).toBe('Test');\n    expect(lastMail.data.html).toBe('This is test.');\n  });\n\n  it('should send emails with nodemailer with different transports name', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {\n          myDomain: 'smtps://user@domain.com:pass@smtp.domain.com',\n        },\n      });\n\n      await service.sendMail({\n        transporterName: 'testDomain',\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\"Transporters object doesn't have testDomain key\");\n    }\n  });\n\n  it('should send emails with nodemailer without transports', async () => {\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transports: {},\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        html: 'This is test.',\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe('Transporter object undefined');\n    }\n  });\n\n  it('should use mailerOptions.defaults when send emails', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n      defaults: {\n        from: 'user1@example.test',\n      },\n    });\n\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n  });\n\n  it('should use custom transport to send mail', async () => {\n    const service = await getMailerServiceWithCustomTransport({\n      transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n    });\n    await service.sendMail({\n      to: 'user2@example.test',\n      subject: 'Test',\n      html: 'This is test.',\n    });\n\n    expect(nodemailerMock.mock.getSentMail().length).toEqual(1);\n  });\n\n  it('should compile template with the handlebars adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(),\n        dir: `${template_path}`,\n      },\n      options: {\n        strict: true,\n        partials: {\n          dir: `${template_path}`,\n        },\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./handlebars-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Handlebars test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n\n  it('should compile template with the handlebars adapter with error template path', async () => {\n    let templatePath = pathJoin(template_path, '/handlebars-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new HandlebarsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.hbs'`,\n      );\n    }\n  });\n\n  it('should compile template with the handlebars adapter with disabled inline-css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    /*{\n      myHelper: (context, value) => {\n        console.log(context, value);\n      },\n    }*/\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, { inlineCssEnabled: false }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the handlebars adapter with enabled inline-css and media query', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new HandlebarsAdapter(undefined, {\n          inlineCssEnabled: true,\n          inlineCssOptions: { url: ' ', preserveMediaQueries: true },\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/handlebars-template-media-query`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toContain('@media only screen and (max-width:350px)');\n    expect(lastMail.data.html).toContain('<p>Handlebars test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the pug adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with relative path', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter(),\n        dir: template_path,\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Pug test template.</p><p>Hello World!</p></body></html>',\n    );\n  });\n\n  it('should compile template with the pug adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/pug-templates');\n\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new PugAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          world: 'World',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(`ENOENT: no such file or directory, open '${templatePath}.pug'`);\n    }\n  });\n\n  it('should compile template with the pug adapter without inline css', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new PugAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/pug-template`,\n      context: {\n        world: 'World',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Pug test template.</p><p>Hello World!</p>');\n  });\n\n  it('should compile template with the ejs adapter', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with error to read template', async () => {\n    let templatePath = pathJoin(template_path, '/ejs-templates');\n    try {\n      let lastMail: MailMessage;\n      const send = spyOnSmtpSend((mail: MailMessage) => {\n        lastMail = mail;\n      });\n\n      const service = await getMailerServiceForOptions({\n        transport: new SMTPTransport({}),\n        template: {\n          adapter: new EjsAdapter(),\n        },\n      });\n\n      await service.sendMail({\n        from: 'user1@example.test',\n        to: 'user2@example.test',\n        subject: 'Test',\n        template: `${templatePath}`,\n        context: {\n          MAILER: 'Nest-modules TM',\n        },\n      });\n\n      expect(send).toHaveBeenCalled();\n    } catch (error) {\n      expect(error.message).toBe(\n        `Error: ENOENT: no such file or directory, open '${templatePath}.ejs'`,\n      );\n    }\n  });\n\n  it('should compile template with the ejs adapter read template relative url', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        dir: template_path,\n        adapter: new EjsAdapter(),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `./ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter without css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: false,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe('<p>Ejs test template. by Nest-modules TM</p>');\n  });\n\n  it('should compile template with the ejs adapter with css inline', async () => {\n    let lastMail: MailMessage;\n    const send = spyOnSmtpSend((mail: MailMessage) => {\n      lastMail = mail;\n    });\n\n    const service = await getMailerServiceForOptions({\n      transport: new SMTPTransport({}),\n      template: {\n        adapter: new EjsAdapter({\n          inlineCssEnabled: true,\n        }),\n      },\n    });\n\n    await service.sendMail({\n      from: 'user1@example.test',\n      to: 'user2@example.test',\n      subject: 'Test',\n      template: `${template_path}/ejs-template`,\n      context: {\n        MAILER: 'Nest-modules TM',\n      },\n    });\n\n    expect(send).toHaveBeenCalled();\n    expect(lastMail.data.from).toBe('user1@example.test');\n    expect(lastMail.data.html).toBe(\n      '<html><head></head><body><p>Ejs test template. by Nest-modules TM</p></body></html>',\n    );\n  });\n});\n",
              "err": {},
              "uuid": "2a70f433-9c7d-4b7d-ad5e-c213bbeec5b8",
              "parentUUID": "523b2ad6-7258-473b-8a13-419105450da5",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "MailerModule > forRoot > should be defined",
              "title": "MailerModule > forRoot > should be defined",
              "timedOut": false,
              "duration": 149,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { INestApplication } from '@nestjs/common';\nimport { MailerModule } from '../mailer/mailer.module';\nimport { ConfigModule } from '@nestjs/config';\nimport { dynamicConfig } from '@tresdoce-nestjs-toolkit/test-utils';\n\ndescribe('MailerModule', () => {\n  let app: INestApplication;\n\n  describe('forRoot', () => {\n    beforeEach(async () => {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          MailerModule.forRoot({\n            transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n            defaults: {\n              from: '\"nest-modules\" <modules@nestjs.com>',\n            },\n          }),\n        ],\n      }).compile();\n\n      app = moduleFixture.createNestApplication();\n      await app.init();\n    });\n\n    it('should be defined', () => {\n      expect(app).toBeDefined();\n    });\n  });\n\n  describe('forRootAsync', () => {\n    beforeEach(async () => {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [\n              dynamicConfig({\n                mailer: {\n                  transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n                  defaults: {\n                    from: '\"nest-modules\" <modules@nestjs.com>',\n                  },\n                },\n              }),\n            ],\n          }),\n          MailerModule,\n        ],\n      }).compile();\n\n      app = moduleFixture.createNestApplication();\n      await app.init();\n    });\n\n    it('should be defined', () => {\n      expect(app).toBeDefined();\n    });\n  });\n});\n",
              "err": {},
              "uuid": "d047f066-4074-494c-83b6-8cf75b351ec7",
              "parentUUID": "523b2ad6-7258-473b-8a13-419105450da5",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "MailerModule > forRootAsync > should be defined",
              "title": "MailerModule > forRootAsync > should be defined",
              "timedOut": false,
              "duration": 7,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { Test, TestingModule } from '@nestjs/testing';\nimport { INestApplication } from '@nestjs/common';\nimport { MailerModule } from '../mailer/mailer.module';\nimport { ConfigModule } from '@nestjs/config';\nimport { dynamicConfig } from '@tresdoce-nestjs-toolkit/test-utils';\n\ndescribe('MailerModule', () => {\n  let app: INestApplication;\n\n  describe('forRoot', () => {\n    beforeEach(async () => {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          MailerModule.forRoot({\n            transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n            defaults: {\n              from: '\"nest-modules\" <modules@nestjs.com>',\n            },\n          }),\n        ],\n      }).compile();\n\n      app = moduleFixture.createNestApplication();\n      await app.init();\n    });\n\n    it('should be defined', () => {\n      expect(app).toBeDefined();\n    });\n  });\n\n  describe('forRootAsync', () => {\n    beforeEach(async () => {\n      const moduleFixture: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [\n              dynamicConfig({\n                mailer: {\n                  transport: 'smtps://user@domain.com:pass@smtp.domain.com',\n                  defaults: {\n                    from: '\"nest-modules\" <modules@nestjs.com>',\n                  },\n                },\n              }),\n            ],\n          }),\n          MailerModule,\n        ],\n      }).compile();\n\n      app = moduleFixture.createNestApplication();\n      await app.init();\n    });\n\n    it('should be defined', () => {\n      expect(app).toBeDefined();\n    });\n  });\n});\n",
              "err": {},
              "uuid": "864ea9b7-b6d9-4d29-bc69-f5652c0d108d",
              "parentUUID": "523b2ad6-7258-473b-8a13-419105450da5",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "52fc7fb9-9bb4-4e09-9818-cc98e383ac88",
            "ff5491c4-bd95-4b5c-9a5f-0d740aaa2b5d",
            "f63abc46-1239-48ae-ace1-6d34d53e9804",
            "2b40a82e-febb-4d57-b887-5c3d914e47c2",
            "39f941d7-f0ad-4f44-9560-7ad4742374ab",
            "bae792da-29da-4110-9c1d-4d4e28aa7f46",
            "cba95eb4-3975-4e5b-a0f1-f755b0794b6c",
            "4dc56762-cd3c-4f26-9835-cc65d25639ff",
            "31b21d0c-b653-4a0f-9f5f-1bb32afe76dd",
            "b32d6557-ac3d-430c-860b-293606aa2e16",
            "c05d45f8-ce4a-4d38-b6df-0de7883d9db0",
            "2a6fdb36-4f31-48f0-89a9-24d224552b43",
            "87647877-9657-40b2-a705-368180177047",
            "3b9b66c6-5fe8-4148-885e-bb110a2221dc",
            "b534aa8f-d114-4f80-9d3d-4f3547e59479",
            "e901561e-400c-469f-b96e-afeb05986f15",
            "565c2b07-6dd1-4bab-b284-8a492ad4dfb0",
            "1b264ffd-e064-4064-a6c6-43c5bebb378a",
            "a311b1a6-3fe6-416b-b8f8-7c40be31b31d",
            "defab326-b749-4d51-818e-1b0064d7db1a",
            "eda902ed-9e69-47e5-9bed-c5439cedbf17",
            "c0889da1-14e0-4910-8a9a-4892115a4b2a",
            "d5f75db4-0e47-46dc-a427-6199e7103048",
            "36108f0f-c968-4658-ab81-7df4312e659f",
            "2a70f433-9c7d-4b7d-ad5e-c213bbeec5b8",
            "d047f066-4074-494c-83b6-8cf75b351ec7",
            "864ea9b7-b6d9-4d29-bc69-f5652c0d108d"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 296,
          "root": false,
          "rootEmpty": false,
          "_timeout": 5000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 5000
    },
    {
      "uuid": "e0063c2a-85cb-4b0a-907c-14dcde957be3",
      "title": "@tresdoce-nestjs-toolkit/redis",
      "fullFile": "",
      "file": "",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "f91a5298-822f-4969-b8a3-08efa9095d2a",
          "title": "@tresdoce-nestjs-toolkit/redis",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "fullTitle": "RedisService > should be defined",
              "title": "RedisService > should be defined",
              "timedOut": false,
              "duration": 192,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { INestApplication } from '@nestjs/common';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { delay, tcName, TCRedisOptions, testContainers } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { RedisModule } from '../redis/redis.module';\nimport { RedisService } from '../redis/services/redis.service';\n\ndescribe('RedisService', () => {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () => {\n    container = await new testContainers('redis:6.2-alpine', {\n      ...TCRedisOptions,\n      command: ['redis-server', '--appendonly', 'yes', '--requirepass', '123456'],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () => {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: 'test-redis-module',\n          username: encodeURIComponent('default'),\n          password: encodeURIComponent('123456'),\n          host: global.hostContainer,\n          port: parseInt('6379', 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', async () => {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it('should be return echo', async () => {\n    const msg = 'hello world';\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it('should be return false if key dont exist in redis', async () => {\n    expect(await service.exists('myKey')).toBeFalsy();\n  });\n\n  it('should be return OK when set value in redis', async () => {\n    expect(await service.set('myKey', 'hello world')).toEqual('OK');\n  });\n\n  it('should be return value of key', async () => {\n    expect(await service.get('myKey')).toEqual('hello world');\n  });\n\n  it('should be return true if key exist in redis', async () => {\n    expect(await service.exists('myKey')).toBeTruthy();\n  });\n\n  it('should be set value in redis with expiration date', async () => {\n    expect(await service.set('myKeyEx', 'hello world', 2)).toEqual('OK');\n    expect(await service.exists('myKeyEx')).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists('myKeyEx')).toBeFalsy();\n  });\n\n  it('should be return true when copy key', async () => {\n    expect(await service.copy('myKey', 'copyKey')).toBeTruthy();\n  });\n\n  it('should be return false when copy key', async () => {\n    expect(await service.copy('myKey2', 'copyKey')).toBeFalsy();\n  });\n\n  it('should be rename a key', async () => {\n    expect(await service.rename('copyKey', 'newKey')).toEqual('OK');\n  });\n\n  it('should be return false when delete a key', async () => {\n    expect(await service.del('testKey')).toBeFalsy();\n  });\n\n  it('should be return true when delete a key', async () => {\n    expect(await service.del('newKey')).toBeTruthy();\n  });\n\n  it('should be flush all', async () => {\n    expect(await service.flushAll()).toEqual('OK');\n    expect(await service.get('myKey')).toBeNull();\n  });\n});\n",
              "err": {},
              "uuid": "736d0be0-4533-47b2-90b9-c64749567884",
              "parentUUID": "f91a5298-822f-4969-b8a3-08efa9095d2a",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "RedisService > should be return echo",
              "title": "RedisService > should be return echo",
              "timedOut": false,
              "duration": 14,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { INestApplication } from '@nestjs/common';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { delay, tcName, TCRedisOptions, testContainers } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { RedisModule } from '../redis/redis.module';\nimport { RedisService } from '../redis/services/redis.service';\n\ndescribe('RedisService', () => {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () => {\n    container = await new testContainers('redis:6.2-alpine', {\n      ...TCRedisOptions,\n      command: ['redis-server', '--appendonly', 'yes', '--requirepass', '123456'],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () => {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: 'test-redis-module',\n          username: encodeURIComponent('default'),\n          password: encodeURIComponent('123456'),\n          host: global.hostContainer,\n          port: parseInt('6379', 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', async () => {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it('should be return echo', async () => {\n    const msg = 'hello world';\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it('should be return false if key dont exist in redis', async () => {\n    expect(await service.exists('myKey')).toBeFalsy();\n  });\n\n  it('should be return OK when set value in redis', async () => {\n    expect(await service.set('myKey', 'hello world')).toEqual('OK');\n  });\n\n  it('should be return value of key', async () => {\n    expect(await service.get('myKey')).toEqual('hello world');\n  });\n\n  it('should be return true if key exist in redis', async () => {\n    expect(await service.exists('myKey')).toBeTruthy();\n  });\n\n  it('should be set value in redis with expiration date', async () => {\n    expect(await service.set('myKeyEx', 'hello world', 2)).toEqual('OK');\n    expect(await service.exists('myKeyEx')).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists('myKeyEx')).toBeFalsy();\n  });\n\n  it('should be return true when copy key', async () => {\n    expect(await service.copy('myKey', 'copyKey')).toBeTruthy();\n  });\n\n  it('should be return false when copy key', async () => {\n    expect(await service.copy('myKey2', 'copyKey')).toBeFalsy();\n  });\n\n  it('should be rename a key', async () => {\n    expect(await service.rename('copyKey', 'newKey')).toEqual('OK');\n  });\n\n  it('should be return false when delete a key', async () => {\n    expect(await service.del('testKey')).toBeFalsy();\n  });\n\n  it('should be return true when delete a key', async () => {\n    expect(await service.del('newKey')).toBeTruthy();\n  });\n\n  it('should be flush all', async () => {\n    expect(await service.flushAll()).toEqual('OK');\n    expect(await service.get('myKey')).toBeNull();\n  });\n});\n",
              "err": {},
              "uuid": "7dfeb273-b8bb-441d-a8f9-7389891ca300",
              "parentUUID": "f91a5298-822f-4969-b8a3-08efa9095d2a",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "RedisService > should be return false if key dont exist in redis",
              "title": "RedisService > should be return false if key dont exist in redis",
              "timedOut": false,
              "duration": 10,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { INestApplication } from '@nestjs/common';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { delay, tcName, TCRedisOptions, testContainers } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { RedisModule } from '../redis/redis.module';\nimport { RedisService } from '../redis/services/redis.service';\n\ndescribe('RedisService', () => {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () => {\n    container = await new testContainers('redis:6.2-alpine', {\n      ...TCRedisOptions,\n      command: ['redis-server', '--appendonly', 'yes', '--requirepass', '123456'],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () => {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: 'test-redis-module',\n          username: encodeURIComponent('default'),\n          password: encodeURIComponent('123456'),\n          host: global.hostContainer,\n          port: parseInt('6379', 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', async () => {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it('should be return echo', async () => {\n    const msg = 'hello world';\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it('should be return false if key dont exist in redis', async () => {\n    expect(await service.exists('myKey')).toBeFalsy();\n  });\n\n  it('should be return OK when set value in redis', async () => {\n    expect(await service.set('myKey', 'hello world')).toEqual('OK');\n  });\n\n  it('should be return value of key', async () => {\n    expect(await service.get('myKey')).toEqual('hello world');\n  });\n\n  it('should be return true if key exist in redis', async () => {\n    expect(await service.exists('myKey')).toBeTruthy();\n  });\n\n  it('should be set value in redis with expiration date', async () => {\n    expect(await service.set('myKeyEx', 'hello world', 2)).toEqual('OK');\n    expect(await service.exists('myKeyEx')).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists('myKeyEx')).toBeFalsy();\n  });\n\n  it('should be return true when copy key', async () => {\n    expect(await service.copy('myKey', 'copyKey')).toBeTruthy();\n  });\n\n  it('should be return false when copy key', async () => {\n    expect(await service.copy('myKey2', 'copyKey')).toBeFalsy();\n  });\n\n  it('should be rename a key', async () => {\n    expect(await service.rename('copyKey', 'newKey')).toEqual('OK');\n  });\n\n  it('should be return false when delete a key', async () => {\n    expect(await service.del('testKey')).toBeFalsy();\n  });\n\n  it('should be return true when delete a key', async () => {\n    expect(await service.del('newKey')).toBeTruthy();\n  });\n\n  it('should be flush all', async () => {\n    expect(await service.flushAll()).toEqual('OK');\n    expect(await service.get('myKey')).toBeNull();\n  });\n});\n",
              "err": {},
              "uuid": "e7e0d3aa-fcfa-4d5b-af7f-c5fb96f66cec",
              "parentUUID": "f91a5298-822f-4969-b8a3-08efa9095d2a",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "RedisService > should be return OK when set value in redis",
              "title": "RedisService > should be return OK when set value in redis",
              "timedOut": false,
              "duration": 10,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { INestApplication } from '@nestjs/common';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { delay, tcName, TCRedisOptions, testContainers } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { RedisModule } from '../redis/redis.module';\nimport { RedisService } from '../redis/services/redis.service';\n\ndescribe('RedisService', () => {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () => {\n    container = await new testContainers('redis:6.2-alpine', {\n      ...TCRedisOptions,\n      command: ['redis-server', '--appendonly', 'yes', '--requirepass', '123456'],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () => {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: 'test-redis-module',\n          username: encodeURIComponent('default'),\n          password: encodeURIComponent('123456'),\n          host: global.hostContainer,\n          port: parseInt('6379', 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', async () => {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it('should be return echo', async () => {\n    const msg = 'hello world';\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it('should be return false if key dont exist in redis', async () => {\n    expect(await service.exists('myKey')).toBeFalsy();\n  });\n\n  it('should be return OK when set value in redis', async () => {\n    expect(await service.set('myKey', 'hello world')).toEqual('OK');\n  });\n\n  it('should be return value of key', async () => {\n    expect(await service.get('myKey')).toEqual('hello world');\n  });\n\n  it('should be return true if key exist in redis', async () => {\n    expect(await service.exists('myKey')).toBeTruthy();\n  });\n\n  it('should be set value in redis with expiration date', async () => {\n    expect(await service.set('myKeyEx', 'hello world', 2)).toEqual('OK');\n    expect(await service.exists('myKeyEx')).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists('myKeyEx')).toBeFalsy();\n  });\n\n  it('should be return true when copy key', async () => {\n    expect(await service.copy('myKey', 'copyKey')).toBeTruthy();\n  });\n\n  it('should be return false when copy key', async () => {\n    expect(await service.copy('myKey2', 'copyKey')).toBeFalsy();\n  });\n\n  it('should be rename a key', async () => {\n    expect(await service.rename('copyKey', 'newKey')).toEqual('OK');\n  });\n\n  it('should be return false when delete a key', async () => {\n    expect(await service.del('testKey')).toBeFalsy();\n  });\n\n  it('should be return true when delete a key', async () => {\n    expect(await service.del('newKey')).toBeTruthy();\n  });\n\n  it('should be flush all', async () => {\n    expect(await service.flushAll()).toEqual('OK');\n    expect(await service.get('myKey')).toBeNull();\n  });\n});\n",
              "err": {},
              "uuid": "4eee2f73-b926-4739-8acb-453823c0ede6",
              "parentUUID": "f91a5298-822f-4969-b8a3-08efa9095d2a",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "RedisService > should be return value of key",
              "title": "RedisService > should be return value of key",
              "timedOut": false,
              "duration": 12,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { INestApplication } from '@nestjs/common';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { delay, tcName, TCRedisOptions, testContainers } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { RedisModule } from '../redis/redis.module';\nimport { RedisService } from '../redis/services/redis.service';\n\ndescribe('RedisService', () => {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () => {\n    container = await new testContainers('redis:6.2-alpine', {\n      ...TCRedisOptions,\n      command: ['redis-server', '--appendonly', 'yes', '--requirepass', '123456'],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () => {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: 'test-redis-module',\n          username: encodeURIComponent('default'),\n          password: encodeURIComponent('123456'),\n          host: global.hostContainer,\n          port: parseInt('6379', 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', async () => {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it('should be return echo', async () => {\n    const msg = 'hello world';\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it('should be return false if key dont exist in redis', async () => {\n    expect(await service.exists('myKey')).toBeFalsy();\n  });\n\n  it('should be return OK when set value in redis', async () => {\n    expect(await service.set('myKey', 'hello world')).toEqual('OK');\n  });\n\n  it('should be return value of key', async () => {\n    expect(await service.get('myKey')).toEqual('hello world');\n  });\n\n  it('should be return true if key exist in redis', async () => {\n    expect(await service.exists('myKey')).toBeTruthy();\n  });\n\n  it('should be set value in redis with expiration date', async () => {\n    expect(await service.set('myKeyEx', 'hello world', 2)).toEqual('OK');\n    expect(await service.exists('myKeyEx')).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists('myKeyEx')).toBeFalsy();\n  });\n\n  it('should be return true when copy key', async () => {\n    expect(await service.copy('myKey', 'copyKey')).toBeTruthy();\n  });\n\n  it('should be return false when copy key', async () => {\n    expect(await service.copy('myKey2', 'copyKey')).toBeFalsy();\n  });\n\n  it('should be rename a key', async () => {\n    expect(await service.rename('copyKey', 'newKey')).toEqual('OK');\n  });\n\n  it('should be return false when delete a key', async () => {\n    expect(await service.del('testKey')).toBeFalsy();\n  });\n\n  it('should be return true when delete a key', async () => {\n    expect(await service.del('newKey')).toBeTruthy();\n  });\n\n  it('should be flush all', async () => {\n    expect(await service.flushAll()).toEqual('OK');\n    expect(await service.get('myKey')).toBeNull();\n  });\n});\n",
              "err": {},
              "uuid": "4896a766-6c8b-43b1-81df-9cc32fe7ea8a",
              "parentUUID": "f91a5298-822f-4969-b8a3-08efa9095d2a",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "RedisService > should be return true if key exist in redis",
              "title": "RedisService > should be return true if key exist in redis",
              "timedOut": false,
              "duration": 11,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { INestApplication } from '@nestjs/common';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { delay, tcName, TCRedisOptions, testContainers } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { RedisModule } from '../redis/redis.module';\nimport { RedisService } from '../redis/services/redis.service';\n\ndescribe('RedisService', () => {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () => {\n    container = await new testContainers('redis:6.2-alpine', {\n      ...TCRedisOptions,\n      command: ['redis-server', '--appendonly', 'yes', '--requirepass', '123456'],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () => {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: 'test-redis-module',\n          username: encodeURIComponent('default'),\n          password: encodeURIComponent('123456'),\n          host: global.hostContainer,\n          port: parseInt('6379', 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', async () => {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it('should be return echo', async () => {\n    const msg = 'hello world';\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it('should be return false if key dont exist in redis', async () => {\n    expect(await service.exists('myKey')).toBeFalsy();\n  });\n\n  it('should be return OK when set value in redis', async () => {\n    expect(await service.set('myKey', 'hello world')).toEqual('OK');\n  });\n\n  it('should be return value of key', async () => {\n    expect(await service.get('myKey')).toEqual('hello world');\n  });\n\n  it('should be return true if key exist in redis', async () => {\n    expect(await service.exists('myKey')).toBeTruthy();\n  });\n\n  it('should be set value in redis with expiration date', async () => {\n    expect(await service.set('myKeyEx', 'hello world', 2)).toEqual('OK');\n    expect(await service.exists('myKeyEx')).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists('myKeyEx')).toBeFalsy();\n  });\n\n  it('should be return true when copy key', async () => {\n    expect(await service.copy('myKey', 'copyKey')).toBeTruthy();\n  });\n\n  it('should be return false when copy key', async () => {\n    expect(await service.copy('myKey2', 'copyKey')).toBeFalsy();\n  });\n\n  it('should be rename a key', async () => {\n    expect(await service.rename('copyKey', 'newKey')).toEqual('OK');\n  });\n\n  it('should be return false when delete a key', async () => {\n    expect(await service.del('testKey')).toBeFalsy();\n  });\n\n  it('should be return true when delete a key', async () => {\n    expect(await service.del('newKey')).toBeTruthy();\n  });\n\n  it('should be flush all', async () => {\n    expect(await service.flushAll()).toEqual('OK');\n    expect(await service.get('myKey')).toBeNull();\n  });\n});\n",
              "err": {},
              "uuid": "61e780a8-1d7d-473d-ad3e-9ee5d5a69a81",
              "parentUUID": "f91a5298-822f-4969-b8a3-08efa9095d2a",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "RedisService > should be set value in redis with expiration date",
              "title": "RedisService > should be set value in redis with expiration date",
              "timedOut": false,
              "duration": 3012,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { INestApplication } from '@nestjs/common';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { delay, tcName, TCRedisOptions, testContainers } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { RedisModule } from '../redis/redis.module';\nimport { RedisService } from '../redis/services/redis.service';\n\ndescribe('RedisService', () => {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () => {\n    container = await new testContainers('redis:6.2-alpine', {\n      ...TCRedisOptions,\n      command: ['redis-server', '--appendonly', 'yes', '--requirepass', '123456'],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () => {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: 'test-redis-module',\n          username: encodeURIComponent('default'),\n          password: encodeURIComponent('123456'),\n          host: global.hostContainer,\n          port: parseInt('6379', 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', async () => {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it('should be return echo', async () => {\n    const msg = 'hello world';\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it('should be return false if key dont exist in redis', async () => {\n    expect(await service.exists('myKey')).toBeFalsy();\n  });\n\n  it('should be return OK when set value in redis', async () => {\n    expect(await service.set('myKey', 'hello world')).toEqual('OK');\n  });\n\n  it('should be return value of key', async () => {\n    expect(await service.get('myKey')).toEqual('hello world');\n  });\n\n  it('should be return true if key exist in redis', async () => {\n    expect(await service.exists('myKey')).toBeTruthy();\n  });\n\n  it('should be set value in redis with expiration date', async () => {\n    expect(await service.set('myKeyEx', 'hello world', 2)).toEqual('OK');\n    expect(await service.exists('myKeyEx')).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists('myKeyEx')).toBeFalsy();\n  });\n\n  it('should be return true when copy key', async () => {\n    expect(await service.copy('myKey', 'copyKey')).toBeTruthy();\n  });\n\n  it('should be return false when copy key', async () => {\n    expect(await service.copy('myKey2', 'copyKey')).toBeFalsy();\n  });\n\n  it('should be rename a key', async () => {\n    expect(await service.rename('copyKey', 'newKey')).toEqual('OK');\n  });\n\n  it('should be return false when delete a key', async () => {\n    expect(await service.del('testKey')).toBeFalsy();\n  });\n\n  it('should be return true when delete a key', async () => {\n    expect(await service.del('newKey')).toBeTruthy();\n  });\n\n  it('should be flush all', async () => {\n    expect(await service.flushAll()).toEqual('OK');\n    expect(await service.get('myKey')).toBeNull();\n  });\n});\n",
              "err": {},
              "uuid": "8f59a20c-61a4-4ac2-bd92-0b6b28b2abf0",
              "parentUUID": "f91a5298-822f-4969-b8a3-08efa9095d2a",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "RedisService > should be return true when copy key",
              "title": "RedisService > should be return true when copy key",
              "timedOut": false,
              "duration": 10,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { INestApplication } from '@nestjs/common';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { delay, tcName, TCRedisOptions, testContainers } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { RedisModule } from '../redis/redis.module';\nimport { RedisService } from '../redis/services/redis.service';\n\ndescribe('RedisService', () => {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () => {\n    container = await new testContainers('redis:6.2-alpine', {\n      ...TCRedisOptions,\n      command: ['redis-server', '--appendonly', 'yes', '--requirepass', '123456'],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () => {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: 'test-redis-module',\n          username: encodeURIComponent('default'),\n          password: encodeURIComponent('123456'),\n          host: global.hostContainer,\n          port: parseInt('6379', 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', async () => {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it('should be return echo', async () => {\n    const msg = 'hello world';\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it('should be return false if key dont exist in redis', async () => {\n    expect(await service.exists('myKey')).toBeFalsy();\n  });\n\n  it('should be return OK when set value in redis', async () => {\n    expect(await service.set('myKey', 'hello world')).toEqual('OK');\n  });\n\n  it('should be return value of key', async () => {\n    expect(await service.get('myKey')).toEqual('hello world');\n  });\n\n  it('should be return true if key exist in redis', async () => {\n    expect(await service.exists('myKey')).toBeTruthy();\n  });\n\n  it('should be set value in redis with expiration date', async () => {\n    expect(await service.set('myKeyEx', 'hello world', 2)).toEqual('OK');\n    expect(await service.exists('myKeyEx')).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists('myKeyEx')).toBeFalsy();\n  });\n\n  it('should be return true when copy key', async () => {\n    expect(await service.copy('myKey', 'copyKey')).toBeTruthy();\n  });\n\n  it('should be return false when copy key', async () => {\n    expect(await service.copy('myKey2', 'copyKey')).toBeFalsy();\n  });\n\n  it('should be rename a key', async () => {\n    expect(await service.rename('copyKey', 'newKey')).toEqual('OK');\n  });\n\n  it('should be return false when delete a key', async () => {\n    expect(await service.del('testKey')).toBeFalsy();\n  });\n\n  it('should be return true when delete a key', async () => {\n    expect(await service.del('newKey')).toBeTruthy();\n  });\n\n  it('should be flush all', async () => {\n    expect(await service.flushAll()).toEqual('OK');\n    expect(await service.get('myKey')).toBeNull();\n  });\n});\n",
              "err": {},
              "uuid": "2939e4b3-ffa7-4536-89ee-52cdfec2d7ea",
              "parentUUID": "f91a5298-822f-4969-b8a3-08efa9095d2a",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "RedisService > should be return false when copy key",
              "title": "RedisService > should be return false when copy key",
              "timedOut": false,
              "duration": 14,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { INestApplication } from '@nestjs/common';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { delay, tcName, TCRedisOptions, testContainers } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { RedisModule } from '../redis/redis.module';\nimport { RedisService } from '../redis/services/redis.service';\n\ndescribe('RedisService', () => {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () => {\n    container = await new testContainers('redis:6.2-alpine', {\n      ...TCRedisOptions,\n      command: ['redis-server', '--appendonly', 'yes', '--requirepass', '123456'],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () => {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: 'test-redis-module',\n          username: encodeURIComponent('default'),\n          password: encodeURIComponent('123456'),\n          host: global.hostContainer,\n          port: parseInt('6379', 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', async () => {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it('should be return echo', async () => {\n    const msg = 'hello world';\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it('should be return false if key dont exist in redis', async () => {\n    expect(await service.exists('myKey')).toBeFalsy();\n  });\n\n  it('should be return OK when set value in redis', async () => {\n    expect(await service.set('myKey', 'hello world')).toEqual('OK');\n  });\n\n  it('should be return value of key', async () => {\n    expect(await service.get('myKey')).toEqual('hello world');\n  });\n\n  it('should be return true if key exist in redis', async () => {\n    expect(await service.exists('myKey')).toBeTruthy();\n  });\n\n  it('should be set value in redis with expiration date', async () => {\n    expect(await service.set('myKeyEx', 'hello world', 2)).toEqual('OK');\n    expect(await service.exists('myKeyEx')).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists('myKeyEx')).toBeFalsy();\n  });\n\n  it('should be return true when copy key', async () => {\n    expect(await service.copy('myKey', 'copyKey')).toBeTruthy();\n  });\n\n  it('should be return false when copy key', async () => {\n    expect(await service.copy('myKey2', 'copyKey')).toBeFalsy();\n  });\n\n  it('should be rename a key', async () => {\n    expect(await service.rename('copyKey', 'newKey')).toEqual('OK');\n  });\n\n  it('should be return false when delete a key', async () => {\n    expect(await service.del('testKey')).toBeFalsy();\n  });\n\n  it('should be return true when delete a key', async () => {\n    expect(await service.del('newKey')).toBeTruthy();\n  });\n\n  it('should be flush all', async () => {\n    expect(await service.flushAll()).toEqual('OK');\n    expect(await service.get('myKey')).toBeNull();\n  });\n});\n",
              "err": {},
              "uuid": "7b30220a-9d35-4f08-ba46-c9e6be550f43",
              "parentUUID": "f91a5298-822f-4969-b8a3-08efa9095d2a",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "RedisService > should be rename a key",
              "title": "RedisService > should be rename a key",
              "timedOut": false,
              "duration": 11,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { INestApplication } from '@nestjs/common';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { delay, tcName, TCRedisOptions, testContainers } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { RedisModule } from '../redis/redis.module';\nimport { RedisService } from '../redis/services/redis.service';\n\ndescribe('RedisService', () => {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () => {\n    container = await new testContainers('redis:6.2-alpine', {\n      ...TCRedisOptions,\n      command: ['redis-server', '--appendonly', 'yes', '--requirepass', '123456'],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () => {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: 'test-redis-module',\n          username: encodeURIComponent('default'),\n          password: encodeURIComponent('123456'),\n          host: global.hostContainer,\n          port: parseInt('6379', 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', async () => {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it('should be return echo', async () => {\n    const msg = 'hello world';\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it('should be return false if key dont exist in redis', async () => {\n    expect(await service.exists('myKey')).toBeFalsy();\n  });\n\n  it('should be return OK when set value in redis', async () => {\n    expect(await service.set('myKey', 'hello world')).toEqual('OK');\n  });\n\n  it('should be return value of key', async () => {\n    expect(await service.get('myKey')).toEqual('hello world');\n  });\n\n  it('should be return true if key exist in redis', async () => {\n    expect(await service.exists('myKey')).toBeTruthy();\n  });\n\n  it('should be set value in redis with expiration date', async () => {\n    expect(await service.set('myKeyEx', 'hello world', 2)).toEqual('OK');\n    expect(await service.exists('myKeyEx')).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists('myKeyEx')).toBeFalsy();\n  });\n\n  it('should be return true when copy key', async () => {\n    expect(await service.copy('myKey', 'copyKey')).toBeTruthy();\n  });\n\n  it('should be return false when copy key', async () => {\n    expect(await service.copy('myKey2', 'copyKey')).toBeFalsy();\n  });\n\n  it('should be rename a key', async () => {\n    expect(await service.rename('copyKey', 'newKey')).toEqual('OK');\n  });\n\n  it('should be return false when delete a key', async () => {\n    expect(await service.del('testKey')).toBeFalsy();\n  });\n\n  it('should be return true when delete a key', async () => {\n    expect(await service.del('newKey')).toBeTruthy();\n  });\n\n  it('should be flush all', async () => {\n    expect(await service.flushAll()).toEqual('OK');\n    expect(await service.get('myKey')).toBeNull();\n  });\n});\n",
              "err": {},
              "uuid": "188a1188-caeb-4b59-8c4f-962cdac2e070",
              "parentUUID": "f91a5298-822f-4969-b8a3-08efa9095d2a",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "RedisService > should be return false when delete a key",
              "title": "RedisService > should be return false when delete a key",
              "timedOut": false,
              "duration": 9,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { INestApplication } from '@nestjs/common';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { delay, tcName, TCRedisOptions, testContainers } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { RedisModule } from '../redis/redis.module';\nimport { RedisService } from '../redis/services/redis.service';\n\ndescribe('RedisService', () => {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () => {\n    container = await new testContainers('redis:6.2-alpine', {\n      ...TCRedisOptions,\n      command: ['redis-server', '--appendonly', 'yes', '--requirepass', '123456'],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () => {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: 'test-redis-module',\n          username: encodeURIComponent('default'),\n          password: encodeURIComponent('123456'),\n          host: global.hostContainer,\n          port: parseInt('6379', 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', async () => {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it('should be return echo', async () => {\n    const msg = 'hello world';\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it('should be return false if key dont exist in redis', async () => {\n    expect(await service.exists('myKey')).toBeFalsy();\n  });\n\n  it('should be return OK when set value in redis', async () => {\n    expect(await service.set('myKey', 'hello world')).toEqual('OK');\n  });\n\n  it('should be return value of key', async () => {\n    expect(await service.get('myKey')).toEqual('hello world');\n  });\n\n  it('should be return true if key exist in redis', async () => {\n    expect(await service.exists('myKey')).toBeTruthy();\n  });\n\n  it('should be set value in redis with expiration date', async () => {\n    expect(await service.set('myKeyEx', 'hello world', 2)).toEqual('OK');\n    expect(await service.exists('myKeyEx')).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists('myKeyEx')).toBeFalsy();\n  });\n\n  it('should be return true when copy key', async () => {\n    expect(await service.copy('myKey', 'copyKey')).toBeTruthy();\n  });\n\n  it('should be return false when copy key', async () => {\n    expect(await service.copy('myKey2', 'copyKey')).toBeFalsy();\n  });\n\n  it('should be rename a key', async () => {\n    expect(await service.rename('copyKey', 'newKey')).toEqual('OK');\n  });\n\n  it('should be return false when delete a key', async () => {\n    expect(await service.del('testKey')).toBeFalsy();\n  });\n\n  it('should be return true when delete a key', async () => {\n    expect(await service.del('newKey')).toBeTruthy();\n  });\n\n  it('should be flush all', async () => {\n    expect(await service.flushAll()).toEqual('OK');\n    expect(await service.get('myKey')).toBeNull();\n  });\n});\n",
              "err": {},
              "uuid": "76ce8772-8a75-4b7b-87f3-cd755fb1b4bd",
              "parentUUID": "f91a5298-822f-4969-b8a3-08efa9095d2a",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "RedisService > should be return true when delete a key",
              "title": "RedisService > should be return true when delete a key",
              "timedOut": false,
              "duration": 14,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { INestApplication } from '@nestjs/common';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { delay, tcName, TCRedisOptions, testContainers } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { RedisModule } from '../redis/redis.module';\nimport { RedisService } from '../redis/services/redis.service';\n\ndescribe('RedisService', () => {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () => {\n    container = await new testContainers('redis:6.2-alpine', {\n      ...TCRedisOptions,\n      command: ['redis-server', '--appendonly', 'yes', '--requirepass', '123456'],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () => {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: 'test-redis-module',\n          username: encodeURIComponent('default'),\n          password: encodeURIComponent('123456'),\n          host: global.hostContainer,\n          port: parseInt('6379', 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', async () => {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it('should be return echo', async () => {\n    const msg = 'hello world';\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it('should be return false if key dont exist in redis', async () => {\n    expect(await service.exists('myKey')).toBeFalsy();\n  });\n\n  it('should be return OK when set value in redis', async () => {\n    expect(await service.set('myKey', 'hello world')).toEqual('OK');\n  });\n\n  it('should be return value of key', async () => {\n    expect(await service.get('myKey')).toEqual('hello world');\n  });\n\n  it('should be return true if key exist in redis', async () => {\n    expect(await service.exists('myKey')).toBeTruthy();\n  });\n\n  it('should be set value in redis with expiration date', async () => {\n    expect(await service.set('myKeyEx', 'hello world', 2)).toEqual('OK');\n    expect(await service.exists('myKeyEx')).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists('myKeyEx')).toBeFalsy();\n  });\n\n  it('should be return true when copy key', async () => {\n    expect(await service.copy('myKey', 'copyKey')).toBeTruthy();\n  });\n\n  it('should be return false when copy key', async () => {\n    expect(await service.copy('myKey2', 'copyKey')).toBeFalsy();\n  });\n\n  it('should be rename a key', async () => {\n    expect(await service.rename('copyKey', 'newKey')).toEqual('OK');\n  });\n\n  it('should be return false when delete a key', async () => {\n    expect(await service.del('testKey')).toBeFalsy();\n  });\n\n  it('should be return true when delete a key', async () => {\n    expect(await service.del('newKey')).toBeTruthy();\n  });\n\n  it('should be flush all', async () => {\n    expect(await service.flushAll()).toEqual('OK');\n    expect(await service.get('myKey')).toBeNull();\n  });\n});\n",
              "err": {},
              "uuid": "f891fddd-37e9-454f-82d1-b3415d67c742",
              "parentUUID": "f91a5298-822f-4969-b8a3-08efa9095d2a",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "RedisService > should be flush all",
              "title": "RedisService > should be flush all",
              "timedOut": false,
              "duration": 14,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { INestApplication } from '@nestjs/common';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { delay, tcName, TCRedisOptions, testContainers } from '@tresdoce-nestjs-toolkit/test-utils';\nimport { RedisModule } from '../redis/redis.module';\nimport { RedisService } from '../redis/services/redis.service';\n\ndescribe('RedisService', () => {\n  let app: INestApplication;\n  let container: testContainers;\n  let service: RedisService;\n\n  beforeAll(async () => {\n    container = await new testContainers('redis:6.2-alpine', {\n      ...TCRedisOptions,\n      command: ['redis-server', '--appendonly', 'yes', '--requirepass', '123456'],\n      containerName: `${tcName}-redis-service`,\n    });\n    await container.start();\n  });\n\n  afterAll(async () => {\n    await container.stop({ removeVolumes: true });\n  });\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [\n        RedisModule.register({\n          name: 'test-redis-module',\n          username: encodeURIComponent('default'),\n          password: encodeURIComponent('123456'),\n          host: global.hostContainer,\n          port: parseInt('6379', 10),\n        }),\n      ],\n      providers: [RedisService],\n    }).compile();\n\n    app = module.createNestApplication();\n    service = module.get(RedisService);\n    await app.init();\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });\n\n  it('should be defined', async () => {\n    await expect(app).toBeDefined();\n  }, 50000);\n\n  it('should be return echo', async () => {\n    const msg = 'hello world';\n    expect(await service.echo(msg)).toEqual(msg);\n  });\n\n  it('should be return false if key dont exist in redis', async () => {\n    expect(await service.exists('myKey')).toBeFalsy();\n  });\n\n  it('should be return OK when set value in redis', async () => {\n    expect(await service.set('myKey', 'hello world')).toEqual('OK');\n  });\n\n  it('should be return value of key', async () => {\n    expect(await service.get('myKey')).toEqual('hello world');\n  });\n\n  it('should be return true if key exist in redis', async () => {\n    expect(await service.exists('myKey')).toBeTruthy();\n  });\n\n  it('should be set value in redis with expiration date', async () => {\n    expect(await service.set('myKeyEx', 'hello world', 2)).toEqual('OK');\n    expect(await service.exists('myKeyEx')).toBeTruthy();\n    await delay(3000);\n    expect(await service.exists('myKeyEx')).toBeFalsy();\n  });\n\n  it('should be return true when copy key', async () => {\n    expect(await service.copy('myKey', 'copyKey')).toBeTruthy();\n  });\n\n  it('should be return false when copy key', async () => {\n    expect(await service.copy('myKey2', 'copyKey')).toBeFalsy();\n  });\n\n  it('should be rename a key', async () => {\n    expect(await service.rename('copyKey', 'newKey')).toEqual('OK');\n  });\n\n  it('should be return false when delete a key', async () => {\n    expect(await service.del('testKey')).toBeFalsy();\n  });\n\n  it('should be return true when delete a key', async () => {\n    expect(await service.del('newKey')).toBeTruthy();\n  });\n\n  it('should be flush all', async () => {\n    expect(await service.flushAll()).toEqual('OK');\n    expect(await service.get('myKey')).toBeNull();\n  });\n});\n",
              "err": {},
              "uuid": "a2ef4bba-8989-44ed-9590-8114f74e4552",
              "parentUUID": "f91a5298-822f-4969-b8a3-08efa9095d2a",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "RedisModule > with auth > forRootAsync > should be defined",
              "title": "RedisModule > with auth > forRootAsync > should be defined",
              "timedOut": false,
              "duration": 109,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { INestApplication } from '@nestjs/common';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { ConfigModule } from '@nestjs/config';\nimport { tcName, TCRedisOptions, testContainers } from '@tresdoce-nestjs-toolkit/test-utils';\n\nimport { RedisModule } from '../redis/redis.module';\nimport { config } from './utils';\n\njest.setTimeout(70000);\ndescribe('RedisModule', () => {\n  describe('with auth', () => {\n    let app: INestApplication;\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('redis:6.2-alpine', {\n        ...TCRedisOptions,\n        command: ['redis-server', '--appendonly', 'yes', '--requirepass', '123456'],\n        containerName: `${tcName}-redis-module-with-auth`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    describe('forRootAsync', () => {\n      beforeEach(async () => {\n        const module: TestingModule = await Test.createTestingModule({\n          imports: [\n            ConfigModule.forRoot({\n              isGlobal: true,\n              load: [config],\n            }),\n            RedisModule,\n          ],\n        }).compile();\n\n        app = module.createNestApplication();\n        await app.init();\n      });\n\n      afterEach(async () => {\n        await app.close();\n      });\n\n      it('should be defined', async () => {\n        await expect(app).toBeDefined();\n      }, 50000);\n    });\n\n    describe('register', () => {\n      beforeEach(async () => {\n        const module: TestingModule = await Test.createTestingModule({\n          imports: [\n            RedisModule.register({\n              name: 'test-redis-module',\n              username: encodeURIComponent('default'),\n              password: encodeURIComponent('123456'),\n              host: global.hostContainer,\n              port: parseInt('6379', 10),\n            }),\n          ],\n        }).compile();\n\n        app = module.createNestApplication();\n        await app.init();\n      });\n\n      afterEach(async () => {\n        await app.close();\n      });\n\n      it('should be defined', async () => {\n        await expect(app).toBeDefined();\n      }, 50000);\n    });\n  });\n\n  describe('without auth', () => {\n    let app: INestApplication;\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('redis:6.2-alpine', {\n        ...TCRedisOptions,\n        containerName: `${tcName}-redis-module-without-auth`,\n        envs: {},\n        ports: [\n          {\n            container: 6379,\n            host: 6380,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          RedisModule.register({\n            host: global.hostContainer,\n            port: parseInt('6380', 10),\n            database: 1,\n          }),\n        ],\n      }).compile();\n\n      app = module.createNestApplication();\n      await app.init();\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be defined', async () => {\n      await expect(app).toBeDefined();\n    }, 50000);\n  });\n});\n",
              "err": {},
              "uuid": "1aef0271-9816-4181-ba86-e2096f1bc6e6",
              "parentUUID": "f91a5298-822f-4969-b8a3-08efa9095d2a",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "RedisModule > with auth > register > should be defined",
              "title": "RedisModule > with auth > register > should be defined",
              "timedOut": false,
              "duration": 10,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { INestApplication } from '@nestjs/common';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { ConfigModule } from '@nestjs/config';\nimport { tcName, TCRedisOptions, testContainers } from '@tresdoce-nestjs-toolkit/test-utils';\n\nimport { RedisModule } from '../redis/redis.module';\nimport { config } from './utils';\n\njest.setTimeout(70000);\ndescribe('RedisModule', () => {\n  describe('with auth', () => {\n    let app: INestApplication;\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('redis:6.2-alpine', {\n        ...TCRedisOptions,\n        command: ['redis-server', '--appendonly', 'yes', '--requirepass', '123456'],\n        containerName: `${tcName}-redis-module-with-auth`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    describe('forRootAsync', () => {\n      beforeEach(async () => {\n        const module: TestingModule = await Test.createTestingModule({\n          imports: [\n            ConfigModule.forRoot({\n              isGlobal: true,\n              load: [config],\n            }),\n            RedisModule,\n          ],\n        }).compile();\n\n        app = module.createNestApplication();\n        await app.init();\n      });\n\n      afterEach(async () => {\n        await app.close();\n      });\n\n      it('should be defined', async () => {\n        await expect(app).toBeDefined();\n      }, 50000);\n    });\n\n    describe('register', () => {\n      beforeEach(async () => {\n        const module: TestingModule = await Test.createTestingModule({\n          imports: [\n            RedisModule.register({\n              name: 'test-redis-module',\n              username: encodeURIComponent('default'),\n              password: encodeURIComponent('123456'),\n              host: global.hostContainer,\n              port: parseInt('6379', 10),\n            }),\n          ],\n        }).compile();\n\n        app = module.createNestApplication();\n        await app.init();\n      });\n\n      afterEach(async () => {\n        await app.close();\n      });\n\n      it('should be defined', async () => {\n        await expect(app).toBeDefined();\n      }, 50000);\n    });\n  });\n\n  describe('without auth', () => {\n    let app: INestApplication;\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('redis:6.2-alpine', {\n        ...TCRedisOptions,\n        containerName: `${tcName}-redis-module-without-auth`,\n        envs: {},\n        ports: [\n          {\n            container: 6379,\n            host: 6380,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          RedisModule.register({\n            host: global.hostContainer,\n            port: parseInt('6380', 10),\n            database: 1,\n          }),\n        ],\n      }).compile();\n\n      app = module.createNestApplication();\n      await app.init();\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be defined', async () => {\n      await expect(app).toBeDefined();\n    }, 50000);\n  });\n});\n",
              "err": {},
              "uuid": "c53da8e0-f2ee-4a08-9d40-fca870c98a52",
              "parentUUID": "f91a5298-822f-4969-b8a3-08efa9095d2a",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "RedisModule > without auth > should be defined",
              "title": "RedisModule > without auth > should be defined",
              "timedOut": false,
              "duration": 13,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { INestApplication } from '@nestjs/common';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { ConfigModule } from '@nestjs/config';\nimport { tcName, TCRedisOptions, testContainers } from '@tresdoce-nestjs-toolkit/test-utils';\n\nimport { RedisModule } from '../redis/redis.module';\nimport { config } from './utils';\n\njest.setTimeout(70000);\ndescribe('RedisModule', () => {\n  describe('with auth', () => {\n    let app: INestApplication;\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('redis:6.2-alpine', {\n        ...TCRedisOptions,\n        command: ['redis-server', '--appendonly', 'yes', '--requirepass', '123456'],\n        containerName: `${tcName}-redis-module-with-auth`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    describe('forRootAsync', () => {\n      beforeEach(async () => {\n        const module: TestingModule = await Test.createTestingModule({\n          imports: [\n            ConfigModule.forRoot({\n              isGlobal: true,\n              load: [config],\n            }),\n            RedisModule,\n          ],\n        }).compile();\n\n        app = module.createNestApplication();\n        await app.init();\n      });\n\n      afterEach(async () => {\n        await app.close();\n      });\n\n      it('should be defined', async () => {\n        await expect(app).toBeDefined();\n      }, 50000);\n    });\n\n    describe('register', () => {\n      beforeEach(async () => {\n        const module: TestingModule = await Test.createTestingModule({\n          imports: [\n            RedisModule.register({\n              name: 'test-redis-module',\n              username: encodeURIComponent('default'),\n              password: encodeURIComponent('123456'),\n              host: global.hostContainer,\n              port: parseInt('6379', 10),\n            }),\n          ],\n        }).compile();\n\n        app = module.createNestApplication();\n        await app.init();\n      });\n\n      afterEach(async () => {\n        await app.close();\n      });\n\n      it('should be defined', async () => {\n        await expect(app).toBeDefined();\n      }, 50000);\n    });\n  });\n\n  describe('without auth', () => {\n    let app: INestApplication;\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('redis:6.2-alpine', {\n        ...TCRedisOptions,\n        containerName: `${tcName}-redis-module-without-auth`,\n        envs: {},\n        ports: [\n          {\n            container: 6379,\n            host: 6380,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          RedisModule.register({\n            host: global.hostContainer,\n            port: parseInt('6380', 10),\n            database: 1,\n          }),\n        ],\n      }).compile();\n\n      app = module.createNestApplication();\n      await app.init();\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be defined', async () => {\n      await expect(app).toBeDefined();\n    }, 50000);\n  });\n});\n",
              "err": {},
              "uuid": "15491cc9-1c61-4432-acff-d65b426d82ce",
              "parentUUID": "f91a5298-822f-4969-b8a3-08efa9095d2a",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "736d0be0-4533-47b2-90b9-c64749567884",
            "7dfeb273-b8bb-441d-a8f9-7389891ca300",
            "e7e0d3aa-fcfa-4d5b-af7f-c5fb96f66cec",
            "4eee2f73-b926-4739-8acb-453823c0ede6",
            "4896a766-6c8b-43b1-81df-9cc32fe7ea8a",
            "61e780a8-1d7d-473d-ad3e-9ee5d5a69a81",
            "8f59a20c-61a4-4ac2-bd92-0b6b28b2abf0",
            "2939e4b3-ffa7-4536-89ee-52cdfec2d7ea",
            "7b30220a-9d35-4f08-ba46-c9e6be550f43",
            "188a1188-caeb-4b59-8c4f-962cdac2e070",
            "76ce8772-8a75-4b7b-87f3-cd755fb1b4bd",
            "f891fddd-37e9-454f-82d1-b3415d67c742",
            "a2ef4bba-8989-44ed-9590-8114f74e4552",
            "1aef0271-9816-4181-ba86-e2096f1bc6e6",
            "c53da8e0-f2ee-4a08-9d40-fca870c98a52",
            "15491cc9-1c61-4432-acff-d65b426d82ce"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 3465,
          "root": false,
          "rootEmpty": false,
          "_timeout": 5000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 5000
    },
    {
      "uuid": "dfb2f10c-5f41-451a-bedd-553050ea2f1b",
      "title": "@tresdoce-nestjs-toolkit/response-parser",
      "fullFile": "",
      "file": "",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "1beb1fec-473e-4439-a467-4590ee0f9733",
          "title": "@tresdoce-nestjs-toolkit/response-parser",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "fullTitle": "ResponseInterceptor > should be defined",
              "title": "ResponseInterceptor > should be defined",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { ResponseInterceptor } from '../response/response.interceptor';\nimport {\n  JestFN,\n  fixtureUserResponse,\n  fixtureUserArrayResponse,\n} from '@tresdoce-nestjs-toolkit/test-utils';\nimport { of } from 'rxjs';\n\nconst executionContext: any = JestFN.executionContext;\n\ndescribe('ResponseInterceptor', () => {\n  let interceptor = new ResponseInterceptor();\n\n  it('should be defined', () => {\n    expect(interceptor).toBeDefined();\n  });\n\n  it('should return an ResponseInterceptor instance simple entity', (done) => {\n    const callHandler: any = {\n      handle: jest.fn(() => of(fixtureUserResponse)),\n    };\n\n    const obs = interceptor.intercept(executionContext, callHandler);\n    expect(callHandler.handle).toBeCalledTimes(1);\n\n    obs.subscribe({\n      next: (value) => {\n        expect(value).toMatchObject(fixtureUserResponse);\n      },\n      error: (error) => {\n        throw error;\n      },\n      complete: () => {\n        done();\n      },\n    });\n  });\n\n  it('should return an ResponseInterceptor instance multiple entity', (done) => {\n    const callHandler: any = {\n      handle: jest.fn(() => of(fixtureUserArrayResponse)),\n    };\n    const obs = interceptor.intercept(executionContext, callHandler);\n    expect(callHandler.handle).toBeCalledTimes(1);\n\n    obs.subscribe({\n      next: (value) => {\n        expect(value).toMatchObject({ data: fixtureUserArrayResponse });\n      },\n      error: (error) => {\n        throw error;\n      },\n      complete: () => {\n        done();\n      },\n    });\n  });\n});\n",
              "err": {},
              "uuid": "9d0e654b-17f9-412d-8b7c-1e3fe28d9616",
              "parentUUID": "1beb1fec-473e-4439-a467-4590ee0f9733",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "ResponseInterceptor > should return an ResponseInterceptor instance simple entity",
              "title": "ResponseInterceptor > should return an ResponseInterceptor instance simple entity",
              "timedOut": false,
              "duration": 3,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { ResponseInterceptor } from '../response/response.interceptor';\nimport {\n  JestFN,\n  fixtureUserResponse,\n  fixtureUserArrayResponse,\n} from '@tresdoce-nestjs-toolkit/test-utils';\nimport { of } from 'rxjs';\n\nconst executionContext: any = JestFN.executionContext;\n\ndescribe('ResponseInterceptor', () => {\n  let interceptor = new ResponseInterceptor();\n\n  it('should be defined', () => {\n    expect(interceptor).toBeDefined();\n  });\n\n  it('should return an ResponseInterceptor instance simple entity', (done) => {\n    const callHandler: any = {\n      handle: jest.fn(() => of(fixtureUserResponse)),\n    };\n\n    const obs = interceptor.intercept(executionContext, callHandler);\n    expect(callHandler.handle).toBeCalledTimes(1);\n\n    obs.subscribe({\n      next: (value) => {\n        expect(value).toMatchObject(fixtureUserResponse);\n      },\n      error: (error) => {\n        throw error;\n      },\n      complete: () => {\n        done();\n      },\n    });\n  });\n\n  it('should return an ResponseInterceptor instance multiple entity', (done) => {\n    const callHandler: any = {\n      handle: jest.fn(() => of(fixtureUserArrayResponse)),\n    };\n    const obs = interceptor.intercept(executionContext, callHandler);\n    expect(callHandler.handle).toBeCalledTimes(1);\n\n    obs.subscribe({\n      next: (value) => {\n        expect(value).toMatchObject({ data: fixtureUserArrayResponse });\n      },\n      error: (error) => {\n        throw error;\n      },\n      complete: () => {\n        done();\n      },\n    });\n  });\n});\n",
              "err": {},
              "uuid": "fe0308c7-8df2-4cc8-89c0-d95401759fe1",
              "parentUUID": "1beb1fec-473e-4439-a467-4590ee0f9733",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "ResponseInterceptor > should return an ResponseInterceptor instance multiple entity",
              "title": "ResponseInterceptor > should return an ResponseInterceptor instance multiple entity",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { ResponseInterceptor } from '../response/response.interceptor';\nimport {\n  JestFN,\n  fixtureUserResponse,\n  fixtureUserArrayResponse,\n} from '@tresdoce-nestjs-toolkit/test-utils';\nimport { of } from 'rxjs';\n\nconst executionContext: any = JestFN.executionContext;\n\ndescribe('ResponseInterceptor', () => {\n  let interceptor = new ResponseInterceptor();\n\n  it('should be defined', () => {\n    expect(interceptor).toBeDefined();\n  });\n\n  it('should return an ResponseInterceptor instance simple entity', (done) => {\n    const callHandler: any = {\n      handle: jest.fn(() => of(fixtureUserResponse)),\n    };\n\n    const obs = interceptor.intercept(executionContext, callHandler);\n    expect(callHandler.handle).toBeCalledTimes(1);\n\n    obs.subscribe({\n      next: (value) => {\n        expect(value).toMatchObject(fixtureUserResponse);\n      },\n      error: (error) => {\n        throw error;\n      },\n      complete: () => {\n        done();\n      },\n    });\n  });\n\n  it('should return an ResponseInterceptor instance multiple entity', (done) => {\n    const callHandler: any = {\n      handle: jest.fn(() => of(fixtureUserArrayResponse)),\n    };\n    const obs = interceptor.intercept(executionContext, callHandler);\n    expect(callHandler.handle).toBeCalledTimes(1);\n\n    obs.subscribe({\n      next: (value) => {\n        expect(value).toMatchObject({ data: fixtureUserArrayResponse });\n      },\n      error: (error) => {\n        throw error;\n      },\n      complete: () => {\n        done();\n      },\n    });\n  });\n});\n",
              "err": {},
              "uuid": "32deb931-f75d-4711-aa56-1142ff35b08d",
              "parentUUID": "1beb1fec-473e-4439-a467-4590ee0f9733",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "9d0e654b-17f9-412d-8b7c-1e3fe28d9616",
            "fe0308c7-8df2-4cc8-89c0-d95401759fe1",
            "32deb931-f75d-4711-aa56-1142ff35b08d"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 6,
          "root": false,
          "rootEmpty": false,
          "_timeout": 5000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 5000
    },
    {
      "uuid": "dea4d602-c5db-4133-975e-de6213f9c1f6",
      "title": "@tresdoce-nestjs-toolkit/test-utils",
      "fullFile": "",
      "file": "",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "955034f6-e2ee-42f4-a3df-bd65c23b6c64",
          "title": "@tresdoce-nestjs-toolkit/test-utils",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "fullTitle": "globalTestContainers > should be initialize service from docker-compose.yml",
              "title": "globalTestContainers > should be initialize service from docker-compose.yml",
              "timedOut": false,
              "duration": 13505,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { StartedDockerComposeEnvironment } from 'testcontainers';\nimport { closeDockerCompose, initDockerCompose } from '../testcontainers';\nimport path from 'path';\n\ndescribe('globalTestContainers', () => {\n  const composeFilePath = path.resolve(__dirname, '..', 'fixtures', 'docker-compose');\n  const composeFile = 'docker-compose.yml';\n\n  it('should be initialize service from docker-compose.yml', async () => {\n    const services = ['mongo'];\n    const environment: StartedDockerComposeEnvironment = await initDockerCompose(\n      services,\n      composeFilePath,\n      composeFile,\n    )();\n    expect(environment).toBeDefined();\n    expect(environment).toBeInstanceOf(StartedDockerComposeEnvironment);\n    await closeDockerCompose({ removeVolumes: true })();\n  });\n\n  it('should be initialize all services from docker-compose.yml', async () => {\n    const services = [];\n    const environment: StartedDockerComposeEnvironment = await initDockerCompose(\n      services,\n      composeFilePath,\n      composeFile,\n    )();\n    expect(environment).toBeDefined();\n    expect(environment).toBeInstanceOf(StartedDockerComposeEnvironment);\n    await closeDockerCompose({ removeVolumes: true })();\n  });\n\n  it('should be initialize services from docker-compose.yml in default path and filename', async () => {\n    const services = [];\n    const environment: StartedDockerComposeEnvironment = await initDockerCompose(services)();\n    expect(environment).toBeDefined();\n    expect(environment).toBeInstanceOf(StartedDockerComposeEnvironment);\n    await closeDockerCompose({ removeVolumes: true })();\n  });\n});\n",
              "err": {},
              "uuid": "1bb3bed5-4684-4710-ba85-a4b285791c0c",
              "parentUUID": "955034f6-e2ee-42f4-a3df-bd65c23b6c64",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "globalTestContainers > should be initialize all services from docker-compose.yml",
              "title": "globalTestContainers > should be initialize all services from docker-compose.yml",
              "timedOut": false,
              "duration": 14563,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { StartedDockerComposeEnvironment } from 'testcontainers';\nimport { closeDockerCompose, initDockerCompose } from '../testcontainers';\nimport path from 'path';\n\ndescribe('globalTestContainers', () => {\n  const composeFilePath = path.resolve(__dirname, '..', 'fixtures', 'docker-compose');\n  const composeFile = 'docker-compose.yml';\n\n  it('should be initialize service from docker-compose.yml', async () => {\n    const services = ['mongo'];\n    const environment: StartedDockerComposeEnvironment = await initDockerCompose(\n      services,\n      composeFilePath,\n      composeFile,\n    )();\n    expect(environment).toBeDefined();\n    expect(environment).toBeInstanceOf(StartedDockerComposeEnvironment);\n    await closeDockerCompose({ removeVolumes: true })();\n  });\n\n  it('should be initialize all services from docker-compose.yml', async () => {\n    const services = [];\n    const environment: StartedDockerComposeEnvironment = await initDockerCompose(\n      services,\n      composeFilePath,\n      composeFile,\n    )();\n    expect(environment).toBeDefined();\n    expect(environment).toBeInstanceOf(StartedDockerComposeEnvironment);\n    await closeDockerCompose({ removeVolumes: true })();\n  });\n\n  it('should be initialize services from docker-compose.yml in default path and filename', async () => {\n    const services = [];\n    const environment: StartedDockerComposeEnvironment = await initDockerCompose(services)();\n    expect(environment).toBeDefined();\n    expect(environment).toBeInstanceOf(StartedDockerComposeEnvironment);\n    await closeDockerCompose({ removeVolumes: true })();\n  });\n});\n",
              "err": {},
              "uuid": "176e46ee-fd85-43f1-bc1e-209c013df4ba",
              "parentUUID": "955034f6-e2ee-42f4-a3df-bd65c23b6c64",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "globalTestContainers > should be initialize services from docker-compose.yml in default path and filename",
              "title": "globalTestContainers > should be initialize services from docker-compose.yml in default path and filename",
              "timedOut": false,
              "duration": 11929,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { StartedDockerComposeEnvironment } from 'testcontainers';\nimport { closeDockerCompose, initDockerCompose } from '../testcontainers';\nimport path from 'path';\n\ndescribe('globalTestContainers', () => {\n  const composeFilePath = path.resolve(__dirname, '..', 'fixtures', 'docker-compose');\n  const composeFile = 'docker-compose.yml';\n\n  it('should be initialize service from docker-compose.yml', async () => {\n    const services = ['mongo'];\n    const environment: StartedDockerComposeEnvironment = await initDockerCompose(\n      services,\n      composeFilePath,\n      composeFile,\n    )();\n    expect(environment).toBeDefined();\n    expect(environment).toBeInstanceOf(StartedDockerComposeEnvironment);\n    await closeDockerCompose({ removeVolumes: true })();\n  });\n\n  it('should be initialize all services from docker-compose.yml', async () => {\n    const services = [];\n    const environment: StartedDockerComposeEnvironment = await initDockerCompose(\n      services,\n      composeFilePath,\n      composeFile,\n    )();\n    expect(environment).toBeDefined();\n    expect(environment).toBeInstanceOf(StartedDockerComposeEnvironment);\n    await closeDockerCompose({ removeVolumes: true })();\n  });\n\n  it('should be initialize services from docker-compose.yml in default path and filename', async () => {\n    const services = [];\n    const environment: StartedDockerComposeEnvironment = await initDockerCompose(services)();\n    expect(environment).toBeDefined();\n    expect(environment).toBeInstanceOf(StartedDockerComposeEnvironment);\n    await closeDockerCompose({ removeVolumes: true })();\n  });\n});\n",
              "err": {},
              "uuid": "b935cc87-5a41-4248-87c3-891cc7c2dac4",
              "parentUUID": "955034f6-e2ee-42f4-a3df-bd65c23b6c64",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "TestContainers > Redis > should be defined",
              "title": "TestContainers > Redis > should be defined",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { testContainers } from '../testcontainers';\nimport { StartedGenericContainer } from 'testcontainers/dist/src/generic-container/started-generic-container';\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from '../fixtures';\n\njest.setTimeout(70000);\ndescribe('TestContainers', () => {\n  describe('Redis', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('redis:6.2-alpine', {\n        ...TCRedisOptions,\n        command: ['redis-server', '--appendonly', 'yes', '--requirepass', '123456'],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it('should be return exception of instance', async () => {\n      try {\n        await new testContainers('postgres:13', TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe('Use testContainers.getInstance() instead of new.');\n      }\n    });\n\n    it('should be get instance of test container', () => {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it('should be return envs of instance', () => {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it('should be return container instance', () => {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it('should be return host of container instance', () => {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual('localhost');\n    });\n\n    it('should be return name of container instance', () => {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it('should be return mapped port', () => {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe('DynamoDB', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('amazon/dynamodb-local:latest', {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('MongoDB', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('mongo:5.0', {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('MySql', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('mysql:5.7', {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('Postgres', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('postgres:13', TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('ElasticSearch', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('elasticsearch:8.3.3', {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n",
              "err": {},
              "uuid": "2fda0ca2-8b42-4094-9428-a9c26cbfcd0f",
              "parentUUID": "955034f6-e2ee-42f4-a3df-bd65c23b6c64",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "TestContainers > Redis > should be return exception of instance",
              "title": "TestContainers > Redis > should be return exception of instance",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { testContainers } from '../testcontainers';\nimport { StartedGenericContainer } from 'testcontainers/dist/src/generic-container/started-generic-container';\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from '../fixtures';\n\njest.setTimeout(70000);\ndescribe('TestContainers', () => {\n  describe('Redis', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('redis:6.2-alpine', {\n        ...TCRedisOptions,\n        command: ['redis-server', '--appendonly', 'yes', '--requirepass', '123456'],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it('should be return exception of instance', async () => {\n      try {\n        await new testContainers('postgres:13', TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe('Use testContainers.getInstance() instead of new.');\n      }\n    });\n\n    it('should be get instance of test container', () => {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it('should be return envs of instance', () => {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it('should be return container instance', () => {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it('should be return host of container instance', () => {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual('localhost');\n    });\n\n    it('should be return name of container instance', () => {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it('should be return mapped port', () => {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe('DynamoDB', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('amazon/dynamodb-local:latest', {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('MongoDB', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('mongo:5.0', {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('MySql', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('mysql:5.7', {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('Postgres', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('postgres:13', TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('ElasticSearch', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('elasticsearch:8.3.3', {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n",
              "err": {},
              "uuid": "68b721a3-fcdb-4c12-bd58-f9d71e7be663",
              "parentUUID": "955034f6-e2ee-42f4-a3df-bd65c23b6c64",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "TestContainers > Redis > should be get instance of test container",
              "title": "TestContainers > Redis > should be get instance of test container",
              "timedOut": false,
              "duration": 0,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { testContainers } from '../testcontainers';\nimport { StartedGenericContainer } from 'testcontainers/dist/src/generic-container/started-generic-container';\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from '../fixtures';\n\njest.setTimeout(70000);\ndescribe('TestContainers', () => {\n  describe('Redis', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('redis:6.2-alpine', {\n        ...TCRedisOptions,\n        command: ['redis-server', '--appendonly', 'yes', '--requirepass', '123456'],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it('should be return exception of instance', async () => {\n      try {\n        await new testContainers('postgres:13', TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe('Use testContainers.getInstance() instead of new.');\n      }\n    });\n\n    it('should be get instance of test container', () => {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it('should be return envs of instance', () => {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it('should be return container instance', () => {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it('should be return host of container instance', () => {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual('localhost');\n    });\n\n    it('should be return name of container instance', () => {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it('should be return mapped port', () => {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe('DynamoDB', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('amazon/dynamodb-local:latest', {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('MongoDB', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('mongo:5.0', {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('MySql', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('mysql:5.7', {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('Postgres', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('postgres:13', TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('ElasticSearch', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('elasticsearch:8.3.3', {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n",
              "err": {},
              "uuid": "039a5bd4-04bf-4a64-9b03-644a327641a6",
              "parentUUID": "955034f6-e2ee-42f4-a3df-bd65c23b6c64",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "TestContainers > Redis > should be return envs of instance",
              "title": "TestContainers > Redis > should be return envs of instance",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { testContainers } from '../testcontainers';\nimport { StartedGenericContainer } from 'testcontainers/dist/src/generic-container/started-generic-container';\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from '../fixtures';\n\njest.setTimeout(70000);\ndescribe('TestContainers', () => {\n  describe('Redis', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('redis:6.2-alpine', {\n        ...TCRedisOptions,\n        command: ['redis-server', '--appendonly', 'yes', '--requirepass', '123456'],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it('should be return exception of instance', async () => {\n      try {\n        await new testContainers('postgres:13', TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe('Use testContainers.getInstance() instead of new.');\n      }\n    });\n\n    it('should be get instance of test container', () => {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it('should be return envs of instance', () => {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it('should be return container instance', () => {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it('should be return host of container instance', () => {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual('localhost');\n    });\n\n    it('should be return name of container instance', () => {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it('should be return mapped port', () => {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe('DynamoDB', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('amazon/dynamodb-local:latest', {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('MongoDB', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('mongo:5.0', {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('MySql', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('mysql:5.7', {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('Postgres', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('postgres:13', TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('ElasticSearch', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('elasticsearch:8.3.3', {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n",
              "err": {},
              "uuid": "8c3ed895-4920-47ad-95f4-b353d26a7803",
              "parentUUID": "955034f6-e2ee-42f4-a3df-bd65c23b6c64",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "TestContainers > Redis > should be return container instance",
              "title": "TestContainers > Redis > should be return container instance",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { testContainers } from '../testcontainers';\nimport { StartedGenericContainer } from 'testcontainers/dist/src/generic-container/started-generic-container';\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from '../fixtures';\n\njest.setTimeout(70000);\ndescribe('TestContainers', () => {\n  describe('Redis', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('redis:6.2-alpine', {\n        ...TCRedisOptions,\n        command: ['redis-server', '--appendonly', 'yes', '--requirepass', '123456'],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it('should be return exception of instance', async () => {\n      try {\n        await new testContainers('postgres:13', TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe('Use testContainers.getInstance() instead of new.');\n      }\n    });\n\n    it('should be get instance of test container', () => {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it('should be return envs of instance', () => {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it('should be return container instance', () => {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it('should be return host of container instance', () => {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual('localhost');\n    });\n\n    it('should be return name of container instance', () => {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it('should be return mapped port', () => {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe('DynamoDB', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('amazon/dynamodb-local:latest', {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('MongoDB', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('mongo:5.0', {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('MySql', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('mysql:5.7', {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('Postgres', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('postgres:13', TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('ElasticSearch', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('elasticsearch:8.3.3', {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n",
              "err": {},
              "uuid": "a3a99614-5a4b-43af-8613-121187178d7b",
              "parentUUID": "955034f6-e2ee-42f4-a3df-bd65c23b6c64",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "TestContainers > Redis > should be return host of container instance",
              "title": "TestContainers > Redis > should be return host of container instance",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { testContainers } from '../testcontainers';\nimport { StartedGenericContainer } from 'testcontainers/dist/src/generic-container/started-generic-container';\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from '../fixtures';\n\njest.setTimeout(70000);\ndescribe('TestContainers', () => {\n  describe('Redis', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('redis:6.2-alpine', {\n        ...TCRedisOptions,\n        command: ['redis-server', '--appendonly', 'yes', '--requirepass', '123456'],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it('should be return exception of instance', async () => {\n      try {\n        await new testContainers('postgres:13', TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe('Use testContainers.getInstance() instead of new.');\n      }\n    });\n\n    it('should be get instance of test container', () => {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it('should be return envs of instance', () => {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it('should be return container instance', () => {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it('should be return host of container instance', () => {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual('localhost');\n    });\n\n    it('should be return name of container instance', () => {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it('should be return mapped port', () => {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe('DynamoDB', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('amazon/dynamodb-local:latest', {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('MongoDB', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('mongo:5.0', {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('MySql', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('mysql:5.7', {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('Postgres', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('postgres:13', TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('ElasticSearch', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('elasticsearch:8.3.3', {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n",
              "err": {},
              "uuid": "c4fce2eb-9ae7-43b6-8fa1-1427971d8a08",
              "parentUUID": "955034f6-e2ee-42f4-a3df-bd65c23b6c64",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "TestContainers > Redis > should be return name of container instance",
              "title": "TestContainers > Redis > should be return name of container instance",
              "timedOut": false,
              "duration": 0,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { testContainers } from '../testcontainers';\nimport { StartedGenericContainer } from 'testcontainers/dist/src/generic-container/started-generic-container';\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from '../fixtures';\n\njest.setTimeout(70000);\ndescribe('TestContainers', () => {\n  describe('Redis', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('redis:6.2-alpine', {\n        ...TCRedisOptions,\n        command: ['redis-server', '--appendonly', 'yes', '--requirepass', '123456'],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it('should be return exception of instance', async () => {\n      try {\n        await new testContainers('postgres:13', TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe('Use testContainers.getInstance() instead of new.');\n      }\n    });\n\n    it('should be get instance of test container', () => {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it('should be return envs of instance', () => {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it('should be return container instance', () => {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it('should be return host of container instance', () => {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual('localhost');\n    });\n\n    it('should be return name of container instance', () => {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it('should be return mapped port', () => {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe('DynamoDB', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('amazon/dynamodb-local:latest', {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('MongoDB', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('mongo:5.0', {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('MySql', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('mysql:5.7', {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('Postgres', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('postgres:13', TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('ElasticSearch', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('elasticsearch:8.3.3', {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n",
              "err": {},
              "uuid": "e115d45e-9ecc-4d1d-81bc-6b9025a9591b",
              "parentUUID": "955034f6-e2ee-42f4-a3df-bd65c23b6c64",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "TestContainers > Redis > should be return mapped port",
              "title": "TestContainers > Redis > should be return mapped port",
              "timedOut": false,
              "duration": 0,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { testContainers } from '../testcontainers';\nimport { StartedGenericContainer } from 'testcontainers/dist/src/generic-container/started-generic-container';\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from '../fixtures';\n\njest.setTimeout(70000);\ndescribe('TestContainers', () => {\n  describe('Redis', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('redis:6.2-alpine', {\n        ...TCRedisOptions,\n        command: ['redis-server', '--appendonly', 'yes', '--requirepass', '123456'],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it('should be return exception of instance', async () => {\n      try {\n        await new testContainers('postgres:13', TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe('Use testContainers.getInstance() instead of new.');\n      }\n    });\n\n    it('should be get instance of test container', () => {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it('should be return envs of instance', () => {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it('should be return container instance', () => {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it('should be return host of container instance', () => {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual('localhost');\n    });\n\n    it('should be return name of container instance', () => {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it('should be return mapped port', () => {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe('DynamoDB', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('amazon/dynamodb-local:latest', {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('MongoDB', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('mongo:5.0', {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('MySql', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('mysql:5.7', {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('Postgres', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('postgres:13', TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('ElasticSearch', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('elasticsearch:8.3.3', {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n",
              "err": {},
              "uuid": "70c4dd82-7d65-4f16-a22f-f580e5d4dba4",
              "parentUUID": "955034f6-e2ee-42f4-a3df-bd65c23b6c64",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "TestContainers > DynamoDB > should be defined",
              "title": "TestContainers > DynamoDB > should be defined",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { testContainers } from '../testcontainers';\nimport { StartedGenericContainer } from 'testcontainers/dist/src/generic-container/started-generic-container';\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from '../fixtures';\n\njest.setTimeout(70000);\ndescribe('TestContainers', () => {\n  describe('Redis', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('redis:6.2-alpine', {\n        ...TCRedisOptions,\n        command: ['redis-server', '--appendonly', 'yes', '--requirepass', '123456'],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it('should be return exception of instance', async () => {\n      try {\n        await new testContainers('postgres:13', TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe('Use testContainers.getInstance() instead of new.');\n      }\n    });\n\n    it('should be get instance of test container', () => {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it('should be return envs of instance', () => {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it('should be return container instance', () => {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it('should be return host of container instance', () => {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual('localhost');\n    });\n\n    it('should be return name of container instance', () => {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it('should be return mapped port', () => {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe('DynamoDB', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('amazon/dynamodb-local:latest', {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('MongoDB', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('mongo:5.0', {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('MySql', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('mysql:5.7', {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('Postgres', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('postgres:13', TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('ElasticSearch', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('elasticsearch:8.3.3', {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n",
              "err": {},
              "uuid": "75a38f7d-1937-46fb-ac3f-0374bbba8400",
              "parentUUID": "955034f6-e2ee-42f4-a3df-bd65c23b6c64",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "TestContainers > MongoDB > should be defined",
              "title": "TestContainers > MongoDB > should be defined",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { testContainers } from '../testcontainers';\nimport { StartedGenericContainer } from 'testcontainers/dist/src/generic-container/started-generic-container';\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from '../fixtures';\n\njest.setTimeout(70000);\ndescribe('TestContainers', () => {\n  describe('Redis', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('redis:6.2-alpine', {\n        ...TCRedisOptions,\n        command: ['redis-server', '--appendonly', 'yes', '--requirepass', '123456'],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it('should be return exception of instance', async () => {\n      try {\n        await new testContainers('postgres:13', TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe('Use testContainers.getInstance() instead of new.');\n      }\n    });\n\n    it('should be get instance of test container', () => {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it('should be return envs of instance', () => {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it('should be return container instance', () => {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it('should be return host of container instance', () => {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual('localhost');\n    });\n\n    it('should be return name of container instance', () => {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it('should be return mapped port', () => {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe('DynamoDB', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('amazon/dynamodb-local:latest', {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('MongoDB', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('mongo:5.0', {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('MySql', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('mysql:5.7', {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('Postgres', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('postgres:13', TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('ElasticSearch', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('elasticsearch:8.3.3', {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n",
              "err": {},
              "uuid": "fe98144c-a2c2-4d0b-b8b6-dd69a79a411a",
              "parentUUID": "955034f6-e2ee-42f4-a3df-bd65c23b6c64",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "TestContainers > MySql > should be defined",
              "title": "TestContainers > MySql > should be defined",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { testContainers } from '../testcontainers';\nimport { StartedGenericContainer } from 'testcontainers/dist/src/generic-container/started-generic-container';\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from '../fixtures';\n\njest.setTimeout(70000);\ndescribe('TestContainers', () => {\n  describe('Redis', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('redis:6.2-alpine', {\n        ...TCRedisOptions,\n        command: ['redis-server', '--appendonly', 'yes', '--requirepass', '123456'],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it('should be return exception of instance', async () => {\n      try {\n        await new testContainers('postgres:13', TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe('Use testContainers.getInstance() instead of new.');\n      }\n    });\n\n    it('should be get instance of test container', () => {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it('should be return envs of instance', () => {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it('should be return container instance', () => {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it('should be return host of container instance', () => {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual('localhost');\n    });\n\n    it('should be return name of container instance', () => {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it('should be return mapped port', () => {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe('DynamoDB', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('amazon/dynamodb-local:latest', {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('MongoDB', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('mongo:5.0', {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('MySql', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('mysql:5.7', {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('Postgres', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('postgres:13', TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('ElasticSearch', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('elasticsearch:8.3.3', {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n",
              "err": {},
              "uuid": "3c5e2304-b489-4c39-a7f5-393171606680",
              "parentUUID": "955034f6-e2ee-42f4-a3df-bd65c23b6c64",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "TestContainers > Postgres > should be defined",
              "title": "TestContainers > Postgres > should be defined",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { testContainers } from '../testcontainers';\nimport { StartedGenericContainer } from 'testcontainers/dist/src/generic-container/started-generic-container';\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from '../fixtures';\n\njest.setTimeout(70000);\ndescribe('TestContainers', () => {\n  describe('Redis', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('redis:6.2-alpine', {\n        ...TCRedisOptions,\n        command: ['redis-server', '--appendonly', 'yes', '--requirepass', '123456'],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it('should be return exception of instance', async () => {\n      try {\n        await new testContainers('postgres:13', TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe('Use testContainers.getInstance() instead of new.');\n      }\n    });\n\n    it('should be get instance of test container', () => {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it('should be return envs of instance', () => {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it('should be return container instance', () => {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it('should be return host of container instance', () => {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual('localhost');\n    });\n\n    it('should be return name of container instance', () => {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it('should be return mapped port', () => {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe('DynamoDB', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('amazon/dynamodb-local:latest', {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('MongoDB', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('mongo:5.0', {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('MySql', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('mysql:5.7', {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('Postgres', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('postgres:13', TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('ElasticSearch', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('elasticsearch:8.3.3', {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n",
              "err": {},
              "uuid": "4429cadf-41bb-438e-8288-86110415b4e6",
              "parentUUID": "955034f6-e2ee-42f4-a3df-bd65c23b6c64",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "TestContainers > ElasticSearch > should be defined",
              "title": "TestContainers > ElasticSearch > should be defined",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { testContainers } from '../testcontainers';\nimport { StartedGenericContainer } from 'testcontainers/dist/src/generic-container/started-generic-container';\n\nimport {\n  TCRedisOptions,\n  TCDynamoDBOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n} from '../fixtures';\n\njest.setTimeout(70000);\ndescribe('TestContainers', () => {\n  describe('Redis', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('redis:6.2-alpine', {\n        ...TCRedisOptions,\n        command: ['redis-server', '--appendonly', 'yes', '--requirepass', '123456'],\n        ports: [\n          {\n            container: 6379,\n            host: 6370,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n\n    it('should be return exception of instance', async () => {\n      try {\n        await new testContainers('postgres:13', TCPostgresOptions);\n      } catch (error) {\n        expect(error.message).toBe('Use testContainers.getInstance() instead of new.');\n      }\n    });\n\n    it('should be get instance of test container', () => {\n      const instance = testContainers.getInstance();\n      expect(instance).toBeInstanceOf(testContainers);\n    });\n\n    it('should be return envs of instance', () => {\n      const instanceEnvs = container.getEnvs();\n      expect(instanceEnvs).toEqual(TCRedisOptions.envs);\n    });\n\n    it('should be return container instance', () => {\n      const instanceContainer = container.getContainer();\n      expect(instanceContainer).toBeDefined();\n      expect(instanceContainer).toBeInstanceOf(StartedGenericContainer);\n    });\n\n    it('should be return host of container instance', () => {\n      const instanceHost = container.getHost();\n      expect(instanceHost).toBeDefined();\n      expect(instanceHost).toEqual('localhost');\n    });\n\n    it('should be return name of container instance', () => {\n      const instanceContainerName = container.getName();\n      expect(instanceContainerName).toBeDefined();\n      expect(instanceContainerName).toContain(TCRedisOptions.containerName);\n    });\n\n    it('should be return mapped port', () => {\n      const mappedPort = container.getMappedPort(6379);\n      expect(mappedPort).toEqual(6370);\n    });\n  });\n\n  describe('DynamoDB', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('amazon/dynamodb-local:latest', {\n        ...TCDynamoDBOptions,\n        ports: [\n          {\n            container: 8000,\n            host: 8002,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('MongoDB', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('mongo:5.0', {\n        ...TCMongoOptions,\n        ports: [\n          {\n            container: 27017,\n            host: 27012,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('MySql', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('mysql:5.7', {\n        ...TCMySqlOptions,\n        ports: [\n          {\n            container: 3306,\n            host: 52000,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('Postgres', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('postgres:13', TCPostgresOptions);\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n\n  describe('ElasticSearch', () => {\n    let container: testContainers;\n\n    beforeAll(async () => {\n      container = await new testContainers('elasticsearch:8.3.3', {\n        ...TCElasticSearchOptions,\n        ports: [\n          {\n            container: 9200,\n            host: 9201,\n          },\n        ],\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    it('should be defined', () => {\n      expect(container).toBeDefined();\n      expect(container).toBeInstanceOf(testContainers);\n    });\n  });\n});\n",
              "err": {},
              "uuid": "86a24f69-e77f-4682-9b05-350c9eeb0da6",
              "parentUUID": "955034f6-e2ee-42f4-a3df-bd65c23b6c64",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "utilities > should be return delay default time",
              "title": "utilities > should be return delay default time",
              "timedOut": false,
              "duration": 10005,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { delay, pathJoin } from '../utilities';\nimport path from 'path';\n\ndescribe('utilities', () => {\n  it('should be return delay default time', async () => {\n    jest.spyOn(global, 'setTimeout');\n    await delay();\n    expect(setTimeout).toHaveBeenCalledTimes(1);\n    expect(setTimeout).toHaveBeenLastCalledWith(expect.any(Function), 10000);\n  });\n\n  it('should be return delay custom time', async () => {\n    jest.spyOn(global, 'setTimeout');\n    await delay(60);\n    expect(setTimeout).toHaveBeenCalledTimes(2);\n    expect(setTimeout).toHaveBeenLastCalledWith(expect.any(Function), 60);\n  });\n\n  it('should be return a join of paths', async () => {\n    const filePath = pathJoin(__dirname, 'join');\n    expect(filePath).toBe(path.join(__dirname, 'join'));\n  });\n});\n",
              "err": {},
              "uuid": "750ac110-e6b2-456d-94ec-bfd55167ba35",
              "parentUUID": "955034f6-e2ee-42f4-a3df-bd65c23b6c64",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "utilities > should be return delay custom time",
              "title": "utilities > should be return delay custom time",
              "timedOut": false,
              "duration": 60,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { delay, pathJoin } from '../utilities';\nimport path from 'path';\n\ndescribe('utilities', () => {\n  it('should be return delay default time', async () => {\n    jest.spyOn(global, 'setTimeout');\n    await delay();\n    expect(setTimeout).toHaveBeenCalledTimes(1);\n    expect(setTimeout).toHaveBeenLastCalledWith(expect.any(Function), 10000);\n  });\n\n  it('should be return delay custom time', async () => {\n    jest.spyOn(global, 'setTimeout');\n    await delay(60);\n    expect(setTimeout).toHaveBeenCalledTimes(2);\n    expect(setTimeout).toHaveBeenLastCalledWith(expect.any(Function), 60);\n  });\n\n  it('should be return a join of paths', async () => {\n    const filePath = pathJoin(__dirname, 'join');\n    expect(filePath).toBe(path.join(__dirname, 'join'));\n  });\n});\n",
              "err": {},
              "uuid": "b820906b-35b3-49e6-b65d-65c472e3aaa9",
              "parentUUID": "955034f6-e2ee-42f4-a3df-bd65c23b6c64",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "utilities > should be return a join of paths",
              "title": "utilities > should be return a join of paths",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { delay, pathJoin } from '../utilities';\nimport path from 'path';\n\ndescribe('utilities', () => {\n  it('should be return delay default time', async () => {\n    jest.spyOn(global, 'setTimeout');\n    await delay();\n    expect(setTimeout).toHaveBeenCalledTimes(1);\n    expect(setTimeout).toHaveBeenLastCalledWith(expect.any(Function), 10000);\n  });\n\n  it('should be return delay custom time', async () => {\n    jest.spyOn(global, 'setTimeout');\n    await delay(60);\n    expect(setTimeout).toHaveBeenCalledTimes(2);\n    expect(setTimeout).toHaveBeenLastCalledWith(expect.any(Function), 60);\n  });\n\n  it('should be return a join of paths', async () => {\n    const filePath = pathJoin(__dirname, 'join');\n    expect(filePath).toBe(path.join(__dirname, 'join'));\n  });\n});\n",
              "err": {},
              "uuid": "881bc5d8-5298-40e0-be1b-107511a857ba",
              "parentUUID": "955034f6-e2ee-42f4-a3df-bd65c23b6c64",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "Config > baseConfig > should be return config",
              "title": "Config > baseConfig > should be return config",
              "timedOut": false,
              "duration": 4,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { config, dynamicConfig } from '../config/index';\nimport { appConfigBase } from '../fixtures';\n\ndescribe('Config', () => {\n  describe('baseConfig', () => {\n    it('should be return config', async () => {\n      expect(config()).toBeDefined();\n      expect(config()).not.toBe(null);\n      expect(typeof config()).toBe('object');\n      expect(config()).toEqual(appConfigBase);\n    });\n  });\n\n  describe('dynamicConfig', () => {\n    it('should be return config with args', async () => {\n      const args = {\n        httOptions: {\n          timeout: 5000,\n          maxRedirects: 5,\n        },\n      };\n\n      expect(dynamicConfig(args)()).toBeDefined();\n      expect(dynamicConfig(args)()).not.toBe(null);\n      expect(typeof dynamicConfig(args)()).toBe('object');\n      expect(dynamicConfig(args)()).toEqual({ ...appConfigBase, ...args });\n    });\n\n    it('should be return config without args', async () => {\n      expect(dynamicConfig()()).toBeDefined();\n      expect(dynamicConfig()()).not.toBe(null);\n      expect(typeof dynamicConfig()()).toBe('object');\n      expect(dynamicConfig()()).toEqual(appConfigBase);\n    });\n  });\n});\n",
              "err": {},
              "uuid": "2f165336-0fca-4038-8ec7-a7ed9fb95acc",
              "parentUUID": "955034f6-e2ee-42f4-a3df-bd65c23b6c64",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "Config > dynamicConfig > should be return config with args",
              "title": "Config > dynamicConfig > should be return config with args",
              "timedOut": false,
              "duration": 3,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { config, dynamicConfig } from '../config/index';\nimport { appConfigBase } from '../fixtures';\n\ndescribe('Config', () => {\n  describe('baseConfig', () => {\n    it('should be return config', async () => {\n      expect(config()).toBeDefined();\n      expect(config()).not.toBe(null);\n      expect(typeof config()).toBe('object');\n      expect(config()).toEqual(appConfigBase);\n    });\n  });\n\n  describe('dynamicConfig', () => {\n    it('should be return config with args', async () => {\n      const args = {\n        httOptions: {\n          timeout: 5000,\n          maxRedirects: 5,\n        },\n      };\n\n      expect(dynamicConfig(args)()).toBeDefined();\n      expect(dynamicConfig(args)()).not.toBe(null);\n      expect(typeof dynamicConfig(args)()).toBe('object');\n      expect(dynamicConfig(args)()).toEqual({ ...appConfigBase, ...args });\n    });\n\n    it('should be return config without args', async () => {\n      expect(dynamicConfig()()).toBeDefined();\n      expect(dynamicConfig()()).not.toBe(null);\n      expect(typeof dynamicConfig()()).toBe('object');\n      expect(dynamicConfig()()).toEqual(appConfigBase);\n    });\n  });\n});\n",
              "err": {},
              "uuid": "e05cf343-4254-4bb0-89a5-95f5df1dac6b",
              "parentUUID": "955034f6-e2ee-42f4-a3df-bd65c23b6c64",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "Config > dynamicConfig > should be return config without args",
              "title": "Config > dynamicConfig > should be return config without args",
              "timedOut": false,
              "duration": 3,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import { config, dynamicConfig } from '../config/index';\nimport { appConfigBase } from '../fixtures';\n\ndescribe('Config', () => {\n  describe('baseConfig', () => {\n    it('should be return config', async () => {\n      expect(config()).toBeDefined();\n      expect(config()).not.toBe(null);\n      expect(typeof config()).toBe('object');\n      expect(config()).toEqual(appConfigBase);\n    });\n  });\n\n  describe('dynamicConfig', () => {\n    it('should be return config with args', async () => {\n      const args = {\n        httOptions: {\n          timeout: 5000,\n          maxRedirects: 5,\n        },\n      };\n\n      expect(dynamicConfig(args)()).toBeDefined();\n      expect(dynamicConfig(args)()).not.toBe(null);\n      expect(typeof dynamicConfig(args)()).toBe('object');\n      expect(dynamicConfig(args)()).toEqual({ ...appConfigBase, ...args });\n    });\n\n    it('should be return config without args', async () => {\n      expect(dynamicConfig()()).toBeDefined();\n      expect(dynamicConfig()()).not.toBe(null);\n      expect(typeof dynamicConfig()()).toBe('object');\n      expect(dynamicConfig()()).toEqual(appConfigBase);\n    });\n  });\n});\n",
              "err": {},
              "uuid": "b4e54be0-036e-4935-a84f-9e2e0e8ee420",
              "parentUUID": "955034f6-e2ee-42f4-a3df-bd65c23b6c64",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "Fixtures > appConfigBase > should be return appBaseConfig",
              "title": "Fixtures > appConfigBase > should be return appBaseConfig",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import {\n  appConfigBase,\n  manifest,\n  TCRedisOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n  TCDynamoDBOptions,\n} from '../fixtures';\n\nconst containerName_prefix = 'tresdoce-test-container';\ndescribe('Fixtures', () => {\n  describe('appConfigBase', () => {\n    it('should be return appBaseConfig', async () => {\n      expect(appConfigBase).toBeDefined();\n      expect(appConfigBase).not.toBe(null);\n      expect(typeof appConfigBase).toBe('object');\n    });\n  });\n\n  describe('manifest', () => {\n    it('should be return appBaseConfig', async () => {\n      expect(manifest).toBeDefined();\n      expect(manifest).not.toBe(null);\n      expect(typeof manifest).toBe('object');\n    });\n  });\n\n  describe('TestContainers options', () => {\n    it('should be define Redis options', async () => {\n      expect(TCRedisOptions).toBeDefined();\n      expect(TCRedisOptions).not.toBe(null);\n      expect(typeof TCRedisOptions).toBe('object');\n      expect(TCRedisOptions.containerName).toEqual(`${containerName_prefix}-redis`);\n      expect(TCRedisOptions.ports).toEqual([\n        {\n          container: 6379,\n          host: 6379,\n        },\n      ]);\n    });\n\n    it('should be define DynamoDB options', async () => {\n      expect(TCDynamoDBOptions).toBeDefined();\n      expect(TCDynamoDBOptions).not.toBe(null);\n      expect(typeof TCDynamoDBOptions).toBe('object');\n      expect(TCDynamoDBOptions.containerName).toEqual(`${containerName_prefix}-dynamodb`);\n      expect(TCDynamoDBOptions.ports).toEqual([\n        {\n          container: 8000,\n          host: 8000,\n        },\n      ]);\n    });\n\n    it('should be define MongoDB options', async () => {\n      expect(TCMongoOptions).toBeDefined();\n      expect(TCMongoOptions).not.toBe(null);\n      expect(typeof TCMongoOptions).toBe('object');\n      expect(TCMongoOptions.containerName).toEqual(`${containerName_prefix}-mongo`);\n      expect(TCMongoOptions.ports).toEqual([\n        {\n          container: 27017,\n          host: 27017,\n        },\n      ]);\n    });\n\n    it('should be define MySql options', async () => {\n      expect(TCMySqlOptions).toBeDefined();\n      expect(TCMySqlOptions).not.toBe(null);\n      expect(typeof TCMySqlOptions).toBe('object');\n      expect(TCMySqlOptions.containerName).toEqual(`${containerName_prefix}-mysql`);\n      expect(TCMySqlOptions.ports).toEqual([\n        {\n          container: 3306,\n          host: 3306,\n        },\n      ]);\n    });\n\n    it('should be define Postgres options', async () => {\n      expect(TCPostgresOptions).toBeDefined();\n      expect(TCPostgresOptions).not.toBe(null);\n      expect(typeof TCPostgresOptions).toBe('object');\n      expect(TCPostgresOptions.containerName).toEqual(`${containerName_prefix}-postgres`);\n      expect(TCPostgresOptions.ports).toEqual([\n        {\n          container: 5432,\n          host: 5432,\n        },\n      ]);\n    });\n\n    it('should be define ElasticSearch options', async () => {\n      expect(TCElasticSearchOptions).toBeDefined();\n      expect(TCElasticSearchOptions).not.toBe(null);\n      expect(typeof TCElasticSearchOptions).toBe('object');\n      expect(TCElasticSearchOptions.containerName).toEqual(`${containerName_prefix}-elasticsearch`);\n      expect(TCElasticSearchOptions.ports).toEqual([\n        {\n          container: 9200,\n          host: 9200,\n        },\n      ]);\n    });\n  });\n});\n",
              "err": {},
              "uuid": "a2565c7d-23fa-4dca-8e2b-f057ee059c17",
              "parentUUID": "955034f6-e2ee-42f4-a3df-bd65c23b6c64",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "Fixtures > manifest > should be return appBaseConfig",
              "title": "Fixtures > manifest > should be return appBaseConfig",
              "timedOut": false,
              "duration": 0,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import {\n  appConfigBase,\n  manifest,\n  TCRedisOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n  TCDynamoDBOptions,\n} from '../fixtures';\n\nconst containerName_prefix = 'tresdoce-test-container';\ndescribe('Fixtures', () => {\n  describe('appConfigBase', () => {\n    it('should be return appBaseConfig', async () => {\n      expect(appConfigBase).toBeDefined();\n      expect(appConfigBase).not.toBe(null);\n      expect(typeof appConfigBase).toBe('object');\n    });\n  });\n\n  describe('manifest', () => {\n    it('should be return appBaseConfig', async () => {\n      expect(manifest).toBeDefined();\n      expect(manifest).not.toBe(null);\n      expect(typeof manifest).toBe('object');\n    });\n  });\n\n  describe('TestContainers options', () => {\n    it('should be define Redis options', async () => {\n      expect(TCRedisOptions).toBeDefined();\n      expect(TCRedisOptions).not.toBe(null);\n      expect(typeof TCRedisOptions).toBe('object');\n      expect(TCRedisOptions.containerName).toEqual(`${containerName_prefix}-redis`);\n      expect(TCRedisOptions.ports).toEqual([\n        {\n          container: 6379,\n          host: 6379,\n        },\n      ]);\n    });\n\n    it('should be define DynamoDB options', async () => {\n      expect(TCDynamoDBOptions).toBeDefined();\n      expect(TCDynamoDBOptions).not.toBe(null);\n      expect(typeof TCDynamoDBOptions).toBe('object');\n      expect(TCDynamoDBOptions.containerName).toEqual(`${containerName_prefix}-dynamodb`);\n      expect(TCDynamoDBOptions.ports).toEqual([\n        {\n          container: 8000,\n          host: 8000,\n        },\n      ]);\n    });\n\n    it('should be define MongoDB options', async () => {\n      expect(TCMongoOptions).toBeDefined();\n      expect(TCMongoOptions).not.toBe(null);\n      expect(typeof TCMongoOptions).toBe('object');\n      expect(TCMongoOptions.containerName).toEqual(`${containerName_prefix}-mongo`);\n      expect(TCMongoOptions.ports).toEqual([\n        {\n          container: 27017,\n          host: 27017,\n        },\n      ]);\n    });\n\n    it('should be define MySql options', async () => {\n      expect(TCMySqlOptions).toBeDefined();\n      expect(TCMySqlOptions).not.toBe(null);\n      expect(typeof TCMySqlOptions).toBe('object');\n      expect(TCMySqlOptions.containerName).toEqual(`${containerName_prefix}-mysql`);\n      expect(TCMySqlOptions.ports).toEqual([\n        {\n          container: 3306,\n          host: 3306,\n        },\n      ]);\n    });\n\n    it('should be define Postgres options', async () => {\n      expect(TCPostgresOptions).toBeDefined();\n      expect(TCPostgresOptions).not.toBe(null);\n      expect(typeof TCPostgresOptions).toBe('object');\n      expect(TCPostgresOptions.containerName).toEqual(`${containerName_prefix}-postgres`);\n      expect(TCPostgresOptions.ports).toEqual([\n        {\n          container: 5432,\n          host: 5432,\n        },\n      ]);\n    });\n\n    it('should be define ElasticSearch options', async () => {\n      expect(TCElasticSearchOptions).toBeDefined();\n      expect(TCElasticSearchOptions).not.toBe(null);\n      expect(typeof TCElasticSearchOptions).toBe('object');\n      expect(TCElasticSearchOptions.containerName).toEqual(`${containerName_prefix}-elasticsearch`);\n      expect(TCElasticSearchOptions.ports).toEqual([\n        {\n          container: 9200,\n          host: 9200,\n        },\n      ]);\n    });\n  });\n});\n",
              "err": {},
              "uuid": "eabb8185-e7af-4500-9654-9652c8fa1ba5",
              "parentUUID": "955034f6-e2ee-42f4-a3df-bd65c23b6c64",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "Fixtures > TestContainers options > should be define Redis options",
              "title": "Fixtures > TestContainers options > should be define Redis options",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import {\n  appConfigBase,\n  manifest,\n  TCRedisOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n  TCDynamoDBOptions,\n} from '../fixtures';\n\nconst containerName_prefix = 'tresdoce-test-container';\ndescribe('Fixtures', () => {\n  describe('appConfigBase', () => {\n    it('should be return appBaseConfig', async () => {\n      expect(appConfigBase).toBeDefined();\n      expect(appConfigBase).not.toBe(null);\n      expect(typeof appConfigBase).toBe('object');\n    });\n  });\n\n  describe('manifest', () => {\n    it('should be return appBaseConfig', async () => {\n      expect(manifest).toBeDefined();\n      expect(manifest).not.toBe(null);\n      expect(typeof manifest).toBe('object');\n    });\n  });\n\n  describe('TestContainers options', () => {\n    it('should be define Redis options', async () => {\n      expect(TCRedisOptions).toBeDefined();\n      expect(TCRedisOptions).not.toBe(null);\n      expect(typeof TCRedisOptions).toBe('object');\n      expect(TCRedisOptions.containerName).toEqual(`${containerName_prefix}-redis`);\n      expect(TCRedisOptions.ports).toEqual([\n        {\n          container: 6379,\n          host: 6379,\n        },\n      ]);\n    });\n\n    it('should be define DynamoDB options', async () => {\n      expect(TCDynamoDBOptions).toBeDefined();\n      expect(TCDynamoDBOptions).not.toBe(null);\n      expect(typeof TCDynamoDBOptions).toBe('object');\n      expect(TCDynamoDBOptions.containerName).toEqual(`${containerName_prefix}-dynamodb`);\n      expect(TCDynamoDBOptions.ports).toEqual([\n        {\n          container: 8000,\n          host: 8000,\n        },\n      ]);\n    });\n\n    it('should be define MongoDB options', async () => {\n      expect(TCMongoOptions).toBeDefined();\n      expect(TCMongoOptions).not.toBe(null);\n      expect(typeof TCMongoOptions).toBe('object');\n      expect(TCMongoOptions.containerName).toEqual(`${containerName_prefix}-mongo`);\n      expect(TCMongoOptions.ports).toEqual([\n        {\n          container: 27017,\n          host: 27017,\n        },\n      ]);\n    });\n\n    it('should be define MySql options', async () => {\n      expect(TCMySqlOptions).toBeDefined();\n      expect(TCMySqlOptions).not.toBe(null);\n      expect(typeof TCMySqlOptions).toBe('object');\n      expect(TCMySqlOptions.containerName).toEqual(`${containerName_prefix}-mysql`);\n      expect(TCMySqlOptions.ports).toEqual([\n        {\n          container: 3306,\n          host: 3306,\n        },\n      ]);\n    });\n\n    it('should be define Postgres options', async () => {\n      expect(TCPostgresOptions).toBeDefined();\n      expect(TCPostgresOptions).not.toBe(null);\n      expect(typeof TCPostgresOptions).toBe('object');\n      expect(TCPostgresOptions.containerName).toEqual(`${containerName_prefix}-postgres`);\n      expect(TCPostgresOptions.ports).toEqual([\n        {\n          container: 5432,\n          host: 5432,\n        },\n      ]);\n    });\n\n    it('should be define ElasticSearch options', async () => {\n      expect(TCElasticSearchOptions).toBeDefined();\n      expect(TCElasticSearchOptions).not.toBe(null);\n      expect(typeof TCElasticSearchOptions).toBe('object');\n      expect(TCElasticSearchOptions.containerName).toEqual(`${containerName_prefix}-elasticsearch`);\n      expect(TCElasticSearchOptions.ports).toEqual([\n        {\n          container: 9200,\n          host: 9200,\n        },\n      ]);\n    });\n  });\n});\n",
              "err": {},
              "uuid": "216617f3-97a9-4d89-8b54-622765a250e3",
              "parentUUID": "955034f6-e2ee-42f4-a3df-bd65c23b6c64",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "Fixtures > TestContainers options > should be define DynamoDB options",
              "title": "Fixtures > TestContainers options > should be define DynamoDB options",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import {\n  appConfigBase,\n  manifest,\n  TCRedisOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n  TCDynamoDBOptions,\n} from '../fixtures';\n\nconst containerName_prefix = 'tresdoce-test-container';\ndescribe('Fixtures', () => {\n  describe('appConfigBase', () => {\n    it('should be return appBaseConfig', async () => {\n      expect(appConfigBase).toBeDefined();\n      expect(appConfigBase).not.toBe(null);\n      expect(typeof appConfigBase).toBe('object');\n    });\n  });\n\n  describe('manifest', () => {\n    it('should be return appBaseConfig', async () => {\n      expect(manifest).toBeDefined();\n      expect(manifest).not.toBe(null);\n      expect(typeof manifest).toBe('object');\n    });\n  });\n\n  describe('TestContainers options', () => {\n    it('should be define Redis options', async () => {\n      expect(TCRedisOptions).toBeDefined();\n      expect(TCRedisOptions).not.toBe(null);\n      expect(typeof TCRedisOptions).toBe('object');\n      expect(TCRedisOptions.containerName).toEqual(`${containerName_prefix}-redis`);\n      expect(TCRedisOptions.ports).toEqual([\n        {\n          container: 6379,\n          host: 6379,\n        },\n      ]);\n    });\n\n    it('should be define DynamoDB options', async () => {\n      expect(TCDynamoDBOptions).toBeDefined();\n      expect(TCDynamoDBOptions).not.toBe(null);\n      expect(typeof TCDynamoDBOptions).toBe('object');\n      expect(TCDynamoDBOptions.containerName).toEqual(`${containerName_prefix}-dynamodb`);\n      expect(TCDynamoDBOptions.ports).toEqual([\n        {\n          container: 8000,\n          host: 8000,\n        },\n      ]);\n    });\n\n    it('should be define MongoDB options', async () => {\n      expect(TCMongoOptions).toBeDefined();\n      expect(TCMongoOptions).not.toBe(null);\n      expect(typeof TCMongoOptions).toBe('object');\n      expect(TCMongoOptions.containerName).toEqual(`${containerName_prefix}-mongo`);\n      expect(TCMongoOptions.ports).toEqual([\n        {\n          container: 27017,\n          host: 27017,\n        },\n      ]);\n    });\n\n    it('should be define MySql options', async () => {\n      expect(TCMySqlOptions).toBeDefined();\n      expect(TCMySqlOptions).not.toBe(null);\n      expect(typeof TCMySqlOptions).toBe('object');\n      expect(TCMySqlOptions.containerName).toEqual(`${containerName_prefix}-mysql`);\n      expect(TCMySqlOptions.ports).toEqual([\n        {\n          container: 3306,\n          host: 3306,\n        },\n      ]);\n    });\n\n    it('should be define Postgres options', async () => {\n      expect(TCPostgresOptions).toBeDefined();\n      expect(TCPostgresOptions).not.toBe(null);\n      expect(typeof TCPostgresOptions).toBe('object');\n      expect(TCPostgresOptions.containerName).toEqual(`${containerName_prefix}-postgres`);\n      expect(TCPostgresOptions.ports).toEqual([\n        {\n          container: 5432,\n          host: 5432,\n        },\n      ]);\n    });\n\n    it('should be define ElasticSearch options', async () => {\n      expect(TCElasticSearchOptions).toBeDefined();\n      expect(TCElasticSearchOptions).not.toBe(null);\n      expect(typeof TCElasticSearchOptions).toBe('object');\n      expect(TCElasticSearchOptions.containerName).toEqual(`${containerName_prefix}-elasticsearch`);\n      expect(TCElasticSearchOptions.ports).toEqual([\n        {\n          container: 9200,\n          host: 9200,\n        },\n      ]);\n    });\n  });\n});\n",
              "err": {},
              "uuid": "72ea864d-703e-43d2-b42a-089dd8208cda",
              "parentUUID": "955034f6-e2ee-42f4-a3df-bd65c23b6c64",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "Fixtures > TestContainers options > should be define MongoDB options",
              "title": "Fixtures > TestContainers options > should be define MongoDB options",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import {\n  appConfigBase,\n  manifest,\n  TCRedisOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n  TCDynamoDBOptions,\n} from '../fixtures';\n\nconst containerName_prefix = 'tresdoce-test-container';\ndescribe('Fixtures', () => {\n  describe('appConfigBase', () => {\n    it('should be return appBaseConfig', async () => {\n      expect(appConfigBase).toBeDefined();\n      expect(appConfigBase).not.toBe(null);\n      expect(typeof appConfigBase).toBe('object');\n    });\n  });\n\n  describe('manifest', () => {\n    it('should be return appBaseConfig', async () => {\n      expect(manifest).toBeDefined();\n      expect(manifest).not.toBe(null);\n      expect(typeof manifest).toBe('object');\n    });\n  });\n\n  describe('TestContainers options', () => {\n    it('should be define Redis options', async () => {\n      expect(TCRedisOptions).toBeDefined();\n      expect(TCRedisOptions).not.toBe(null);\n      expect(typeof TCRedisOptions).toBe('object');\n      expect(TCRedisOptions.containerName).toEqual(`${containerName_prefix}-redis`);\n      expect(TCRedisOptions.ports).toEqual([\n        {\n          container: 6379,\n          host: 6379,\n        },\n      ]);\n    });\n\n    it('should be define DynamoDB options', async () => {\n      expect(TCDynamoDBOptions).toBeDefined();\n      expect(TCDynamoDBOptions).not.toBe(null);\n      expect(typeof TCDynamoDBOptions).toBe('object');\n      expect(TCDynamoDBOptions.containerName).toEqual(`${containerName_prefix}-dynamodb`);\n      expect(TCDynamoDBOptions.ports).toEqual([\n        {\n          container: 8000,\n          host: 8000,\n        },\n      ]);\n    });\n\n    it('should be define MongoDB options', async () => {\n      expect(TCMongoOptions).toBeDefined();\n      expect(TCMongoOptions).not.toBe(null);\n      expect(typeof TCMongoOptions).toBe('object');\n      expect(TCMongoOptions.containerName).toEqual(`${containerName_prefix}-mongo`);\n      expect(TCMongoOptions.ports).toEqual([\n        {\n          container: 27017,\n          host: 27017,\n        },\n      ]);\n    });\n\n    it('should be define MySql options', async () => {\n      expect(TCMySqlOptions).toBeDefined();\n      expect(TCMySqlOptions).not.toBe(null);\n      expect(typeof TCMySqlOptions).toBe('object');\n      expect(TCMySqlOptions.containerName).toEqual(`${containerName_prefix}-mysql`);\n      expect(TCMySqlOptions.ports).toEqual([\n        {\n          container: 3306,\n          host: 3306,\n        },\n      ]);\n    });\n\n    it('should be define Postgres options', async () => {\n      expect(TCPostgresOptions).toBeDefined();\n      expect(TCPostgresOptions).not.toBe(null);\n      expect(typeof TCPostgresOptions).toBe('object');\n      expect(TCPostgresOptions.containerName).toEqual(`${containerName_prefix}-postgres`);\n      expect(TCPostgresOptions.ports).toEqual([\n        {\n          container: 5432,\n          host: 5432,\n        },\n      ]);\n    });\n\n    it('should be define ElasticSearch options', async () => {\n      expect(TCElasticSearchOptions).toBeDefined();\n      expect(TCElasticSearchOptions).not.toBe(null);\n      expect(typeof TCElasticSearchOptions).toBe('object');\n      expect(TCElasticSearchOptions.containerName).toEqual(`${containerName_prefix}-elasticsearch`);\n      expect(TCElasticSearchOptions.ports).toEqual([\n        {\n          container: 9200,\n          host: 9200,\n        },\n      ]);\n    });\n  });\n});\n",
              "err": {},
              "uuid": "4736204e-c0f9-46d7-898e-65699fe20309",
              "parentUUID": "955034f6-e2ee-42f4-a3df-bd65c23b6c64",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "Fixtures > TestContainers options > should be define MySql options",
              "title": "Fixtures > TestContainers options > should be define MySql options",
              "timedOut": false,
              "duration": 3,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import {\n  appConfigBase,\n  manifest,\n  TCRedisOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n  TCDynamoDBOptions,\n} from '../fixtures';\n\nconst containerName_prefix = 'tresdoce-test-container';\ndescribe('Fixtures', () => {\n  describe('appConfigBase', () => {\n    it('should be return appBaseConfig', async () => {\n      expect(appConfigBase).toBeDefined();\n      expect(appConfigBase).not.toBe(null);\n      expect(typeof appConfigBase).toBe('object');\n    });\n  });\n\n  describe('manifest', () => {\n    it('should be return appBaseConfig', async () => {\n      expect(manifest).toBeDefined();\n      expect(manifest).not.toBe(null);\n      expect(typeof manifest).toBe('object');\n    });\n  });\n\n  describe('TestContainers options', () => {\n    it('should be define Redis options', async () => {\n      expect(TCRedisOptions).toBeDefined();\n      expect(TCRedisOptions).not.toBe(null);\n      expect(typeof TCRedisOptions).toBe('object');\n      expect(TCRedisOptions.containerName).toEqual(`${containerName_prefix}-redis`);\n      expect(TCRedisOptions.ports).toEqual([\n        {\n          container: 6379,\n          host: 6379,\n        },\n      ]);\n    });\n\n    it('should be define DynamoDB options', async () => {\n      expect(TCDynamoDBOptions).toBeDefined();\n      expect(TCDynamoDBOptions).not.toBe(null);\n      expect(typeof TCDynamoDBOptions).toBe('object');\n      expect(TCDynamoDBOptions.containerName).toEqual(`${containerName_prefix}-dynamodb`);\n      expect(TCDynamoDBOptions.ports).toEqual([\n        {\n          container: 8000,\n          host: 8000,\n        },\n      ]);\n    });\n\n    it('should be define MongoDB options', async () => {\n      expect(TCMongoOptions).toBeDefined();\n      expect(TCMongoOptions).not.toBe(null);\n      expect(typeof TCMongoOptions).toBe('object');\n      expect(TCMongoOptions.containerName).toEqual(`${containerName_prefix}-mongo`);\n      expect(TCMongoOptions.ports).toEqual([\n        {\n          container: 27017,\n          host: 27017,\n        },\n      ]);\n    });\n\n    it('should be define MySql options', async () => {\n      expect(TCMySqlOptions).toBeDefined();\n      expect(TCMySqlOptions).not.toBe(null);\n      expect(typeof TCMySqlOptions).toBe('object');\n      expect(TCMySqlOptions.containerName).toEqual(`${containerName_prefix}-mysql`);\n      expect(TCMySqlOptions.ports).toEqual([\n        {\n          container: 3306,\n          host: 3306,\n        },\n      ]);\n    });\n\n    it('should be define Postgres options', async () => {\n      expect(TCPostgresOptions).toBeDefined();\n      expect(TCPostgresOptions).not.toBe(null);\n      expect(typeof TCPostgresOptions).toBe('object');\n      expect(TCPostgresOptions.containerName).toEqual(`${containerName_prefix}-postgres`);\n      expect(TCPostgresOptions.ports).toEqual([\n        {\n          container: 5432,\n          host: 5432,\n        },\n      ]);\n    });\n\n    it('should be define ElasticSearch options', async () => {\n      expect(TCElasticSearchOptions).toBeDefined();\n      expect(TCElasticSearchOptions).not.toBe(null);\n      expect(typeof TCElasticSearchOptions).toBe('object');\n      expect(TCElasticSearchOptions.containerName).toEqual(`${containerName_prefix}-elasticsearch`);\n      expect(TCElasticSearchOptions.ports).toEqual([\n        {\n          container: 9200,\n          host: 9200,\n        },\n      ]);\n    });\n  });\n});\n",
              "err": {},
              "uuid": "2d441cb7-a513-49e6-8a11-32575d63b2b8",
              "parentUUID": "955034f6-e2ee-42f4-a3df-bd65c23b6c64",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "Fixtures > TestContainers options > should be define Postgres options",
              "title": "Fixtures > TestContainers options > should be define Postgres options",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import {\n  appConfigBase,\n  manifest,\n  TCRedisOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n  TCDynamoDBOptions,\n} from '../fixtures';\n\nconst containerName_prefix = 'tresdoce-test-container';\ndescribe('Fixtures', () => {\n  describe('appConfigBase', () => {\n    it('should be return appBaseConfig', async () => {\n      expect(appConfigBase).toBeDefined();\n      expect(appConfigBase).not.toBe(null);\n      expect(typeof appConfigBase).toBe('object');\n    });\n  });\n\n  describe('manifest', () => {\n    it('should be return appBaseConfig', async () => {\n      expect(manifest).toBeDefined();\n      expect(manifest).not.toBe(null);\n      expect(typeof manifest).toBe('object');\n    });\n  });\n\n  describe('TestContainers options', () => {\n    it('should be define Redis options', async () => {\n      expect(TCRedisOptions).toBeDefined();\n      expect(TCRedisOptions).not.toBe(null);\n      expect(typeof TCRedisOptions).toBe('object');\n      expect(TCRedisOptions.containerName).toEqual(`${containerName_prefix}-redis`);\n      expect(TCRedisOptions.ports).toEqual([\n        {\n          container: 6379,\n          host: 6379,\n        },\n      ]);\n    });\n\n    it('should be define DynamoDB options', async () => {\n      expect(TCDynamoDBOptions).toBeDefined();\n      expect(TCDynamoDBOptions).not.toBe(null);\n      expect(typeof TCDynamoDBOptions).toBe('object');\n      expect(TCDynamoDBOptions.containerName).toEqual(`${containerName_prefix}-dynamodb`);\n      expect(TCDynamoDBOptions.ports).toEqual([\n        {\n          container: 8000,\n          host: 8000,\n        },\n      ]);\n    });\n\n    it('should be define MongoDB options', async () => {\n      expect(TCMongoOptions).toBeDefined();\n      expect(TCMongoOptions).not.toBe(null);\n      expect(typeof TCMongoOptions).toBe('object');\n      expect(TCMongoOptions.containerName).toEqual(`${containerName_prefix}-mongo`);\n      expect(TCMongoOptions.ports).toEqual([\n        {\n          container: 27017,\n          host: 27017,\n        },\n      ]);\n    });\n\n    it('should be define MySql options', async () => {\n      expect(TCMySqlOptions).toBeDefined();\n      expect(TCMySqlOptions).not.toBe(null);\n      expect(typeof TCMySqlOptions).toBe('object');\n      expect(TCMySqlOptions.containerName).toEqual(`${containerName_prefix}-mysql`);\n      expect(TCMySqlOptions.ports).toEqual([\n        {\n          container: 3306,\n          host: 3306,\n        },\n      ]);\n    });\n\n    it('should be define Postgres options', async () => {\n      expect(TCPostgresOptions).toBeDefined();\n      expect(TCPostgresOptions).not.toBe(null);\n      expect(typeof TCPostgresOptions).toBe('object');\n      expect(TCPostgresOptions.containerName).toEqual(`${containerName_prefix}-postgres`);\n      expect(TCPostgresOptions.ports).toEqual([\n        {\n          container: 5432,\n          host: 5432,\n        },\n      ]);\n    });\n\n    it('should be define ElasticSearch options', async () => {\n      expect(TCElasticSearchOptions).toBeDefined();\n      expect(TCElasticSearchOptions).not.toBe(null);\n      expect(typeof TCElasticSearchOptions).toBe('object');\n      expect(TCElasticSearchOptions.containerName).toEqual(`${containerName_prefix}-elasticsearch`);\n      expect(TCElasticSearchOptions.ports).toEqual([\n        {\n          container: 9200,\n          host: 9200,\n        },\n      ]);\n    });\n  });\n});\n",
              "err": {},
              "uuid": "aeb02e1a-d350-4359-ba3b-7b94954bb635",
              "parentUUID": "955034f6-e2ee-42f4-a3df-bd65c23b6c64",
              "isHook": false,
              "skipped": false
            },
            {
              "fullTitle": "Fixtures > TestContainers options > should be define ElasticSearch options",
              "title": "Fixtures > TestContainers options > should be define ElasticSearch options",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "import {\n  appConfigBase,\n  manifest,\n  TCRedisOptions,\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  TCElasticSearchOptions,\n  TCDynamoDBOptions,\n} from '../fixtures';\n\nconst containerName_prefix = 'tresdoce-test-container';\ndescribe('Fixtures', () => {\n  describe('appConfigBase', () => {\n    it('should be return appBaseConfig', async () => {\n      expect(appConfigBase).toBeDefined();\n      expect(appConfigBase).not.toBe(null);\n      expect(typeof appConfigBase).toBe('object');\n    });\n  });\n\n  describe('manifest', () => {\n    it('should be return appBaseConfig', async () => {\n      expect(manifest).toBeDefined();\n      expect(manifest).not.toBe(null);\n      expect(typeof manifest).toBe('object');\n    });\n  });\n\n  describe('TestContainers options', () => {\n    it('should be define Redis options', async () => {\n      expect(TCRedisOptions).toBeDefined();\n      expect(TCRedisOptions).not.toBe(null);\n      expect(typeof TCRedisOptions).toBe('object');\n      expect(TCRedisOptions.containerName).toEqual(`${containerName_prefix}-redis`);\n      expect(TCRedisOptions.ports).toEqual([\n        {\n          container: 6379,\n          host: 6379,\n        },\n      ]);\n    });\n\n    it('should be define DynamoDB options', async () => {\n      expect(TCDynamoDBOptions).toBeDefined();\n      expect(TCDynamoDBOptions).not.toBe(null);\n      expect(typeof TCDynamoDBOptions).toBe('object');\n      expect(TCDynamoDBOptions.containerName).toEqual(`${containerName_prefix}-dynamodb`);\n      expect(TCDynamoDBOptions.ports).toEqual([\n        {\n          container: 8000,\n          host: 8000,\n        },\n      ]);\n    });\n\n    it('should be define MongoDB options', async () => {\n      expect(TCMongoOptions).toBeDefined();\n      expect(TCMongoOptions).not.toBe(null);\n      expect(typeof TCMongoOptions).toBe('object');\n      expect(TCMongoOptions.containerName).toEqual(`${containerName_prefix}-mongo`);\n      expect(TCMongoOptions.ports).toEqual([\n        {\n          container: 27017,\n          host: 27017,\n        },\n      ]);\n    });\n\n    it('should be define MySql options', async () => {\n      expect(TCMySqlOptions).toBeDefined();\n      expect(TCMySqlOptions).not.toBe(null);\n      expect(typeof TCMySqlOptions).toBe('object');\n      expect(TCMySqlOptions.containerName).toEqual(`${containerName_prefix}-mysql`);\n      expect(TCMySqlOptions.ports).toEqual([\n        {\n          container: 3306,\n          host: 3306,\n        },\n      ]);\n    });\n\n    it('should be define Postgres options', async () => {\n      expect(TCPostgresOptions).toBeDefined();\n      expect(TCPostgresOptions).not.toBe(null);\n      expect(typeof TCPostgresOptions).toBe('object');\n      expect(TCPostgresOptions.containerName).toEqual(`${containerName_prefix}-postgres`);\n      expect(TCPostgresOptions.ports).toEqual([\n        {\n          container: 5432,\n          host: 5432,\n        },\n      ]);\n    });\n\n    it('should be define ElasticSearch options', async () => {\n      expect(TCElasticSearchOptions).toBeDefined();\n      expect(TCElasticSearchOptions).not.toBe(null);\n      expect(typeof TCElasticSearchOptions).toBe('object');\n      expect(TCElasticSearchOptions.containerName).toEqual(`${containerName_prefix}-elasticsearch`);\n      expect(TCElasticSearchOptions.ports).toEqual([\n        {\n          container: 9200,\n          host: 9200,\n        },\n      ]);\n    });\n  });\n});\n",
              "err": {},
              "uuid": "d69a2560-68bf-4039-b0fc-fbe9a7df5d2d",
              "parentUUID": "955034f6-e2ee-42f4-a3df-bd65c23b6c64",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "1bb3bed5-4684-4710-ba85-a4b285791c0c",
            "176e46ee-fd85-43f1-bc1e-209c013df4ba",
            "b935cc87-5a41-4248-87c3-891cc7c2dac4",
            "2fda0ca2-8b42-4094-9428-a9c26cbfcd0f",
            "68b721a3-fcdb-4c12-bd58-f9d71e7be663",
            "039a5bd4-04bf-4a64-9b03-644a327641a6",
            "8c3ed895-4920-47ad-95f4-b353d26a7803",
            "a3a99614-5a4b-43af-8613-121187178d7b",
            "c4fce2eb-9ae7-43b6-8fa1-1427971d8a08",
            "e115d45e-9ecc-4d1d-81bc-6b9025a9591b",
            "70c4dd82-7d65-4f16-a22f-f580e5d4dba4",
            "75a38f7d-1937-46fb-ac3f-0374bbba8400",
            "fe98144c-a2c2-4d0b-b8b6-dd69a79a411a",
            "3c5e2304-b489-4c39-a7f5-393171606680",
            "4429cadf-41bb-438e-8288-86110415b4e6",
            "86a24f69-e77f-4682-9b05-350c9eeb0da6",
            "750ac110-e6b2-456d-94ec-bfd55167ba35",
            "b820906b-35b3-49e6-b65d-65c472e3aaa9",
            "881bc5d8-5298-40e0-be1b-107511a857ba",
            "2f165336-0fca-4038-8ec7-a7ed9fb95acc",
            "e05cf343-4254-4bb0-89a5-95f5df1dac6b",
            "b4e54be0-036e-4935-a84f-9e2e0e8ee420",
            "a2565c7d-23fa-4dca-8e2b-f057ee059c17",
            "eabb8185-e7af-4500-9654-9652c8fa1ba5",
            "216617f3-97a9-4d89-8b54-622765a250e3",
            "72ea864d-703e-43d2-b42a-089dd8208cda",
            "4736204e-c0f9-46d7-898e-65699fe20309",
            "2d441cb7-a513-49e6-8a11-32575d63b2b8",
            "aeb02e1a-d350-4359-ba3b-7b94954bb635",
            "d69a2560-68bf-4039-b0fc-fbe9a7df5d2d"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 50098,
          "root": false,
          "rootEmpty": false,
          "_timeout": 5000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 5000
    },
    {
      "uuid": "3da091d5-88ce-4d66-91bf-e501cb9b2e12",
      "title": "",
      "fullFile": "",
      "file": "",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "3da091d5-88ce-4d66-91bf-e501cb9b2e61",
          "title": "@tresdoce-nestjs-toolkit/typeorm",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "3da091d5-88ce-4d66-91bf-e501cb9b2e62",
              "title": "TypeOrm",
              "fullFile": "/Users/maximilianodelgado/Projects/Mex/tresdoce-nestjs-toolkit/packages/typeorm/src/__test__/typeorm.module.spec.ts",
              "file": "typeorm.module.spec.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [],
              "suites": [
                {
                  "uuid": "188bb0af-be76-427f-9c0b-9dd4f76cbc4a",
                  "title": "Postgres",
                  "fullFile": "/Users/maximilianodelgado/Projects/Mex/tresdoce-nestjs-toolkit/packages/typeorm/src/__test__/typeorm.module.spec.ts",
                  "file": "typeorm.module.spec.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "fullTitle": "TypeOrm > Postgres > should be defined",
                      "title": "should be defined",
                      "timedOut": false,
                      "duration": 353,
                      "state": "passed",
                      "speed": "medium",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "import { INestApplication } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport {\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  tcName,\n  testContainers,\n  fixturePostResponse,\n  fixtureUserArrayResponse,\n} from '@tresdoce-nestjs-toolkit/test-utils';\nimport { Repository } from 'typeorm';\n\nimport { TypeOrmClientModule } from '../typeorm/typeorm.module';\nimport { Post } from './utils/post.entity';\nimport { User } from './utils/user.entity';\n\nimport { configPostgres, configMySql, configMongo } from './utils';\n\njest.setTimeout(70000);\ndescribe('TypeOrm', () => {\n  describe('Postgres', () => {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository<Post>;\n\n    beforeAll(async () => {\n      container = await new testContainers('postgres:13', {\n        ...TCPostgresOptions,\n        containerName: `${tcName}-typeorm-postgres`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configPostgres],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([Post]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get('PostRepository');\n      await app.init();\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be defined', async () => {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it('should be return an array of post', async () => {\n      await repository.save([fixturePostResponse]);\n\n      const query = await repository.find();\n      expect(query).toEqual([fixturePostResponse]);\n    });\n  });\n\n  describe('MySql', () => {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository<Post>;\n\n    beforeAll(async () => {\n      container = await new testContainers('mysql:5.7', {\n        ...TCMySqlOptions,\n        containerName: `${tcName}-typeorm-mysql`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configMySql],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([Post]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get('PostRepository');\n      await app.init();\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be defined', async () => {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it('should be return an array of post', async () => {\n      await repository.save([fixturePostResponse]);\n\n      const query = await repository.find();\n      expect(query).toEqual([fixturePostResponse]);\n    });\n  });\n\n  describe('Mongo', () => {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository<User>;\n\n    beforeAll(async () => {\n      container = await new testContainers('mongo:5.0', {\n        ...TCMongoOptions,\n        containerName: `${tcName}-typeorm-mongo`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configMongo],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([User]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get('UserRepository');\n      await app.init();\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be defined', async () => {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it('should be return an array of user', async () => {\n      await repository.save(fixtureUserArrayResponse);\n\n      const query: User[] = await repository.find();\n      expect(query).toEqual(expect.any(Array));\n    });\n  });\n});\n",
                      "err": {},
                      "uuid": "23ed9ff5-ea5d-4b82-89f5-73f5b27da913",
                      "parentUUID": "188bb0af-be76-427f-9c0b-9dd4f76cbc4a",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "fullTitle": "TypeOrm > Postgres > should be return an array of post",
                      "title": "should be return an array of post",
                      "timedOut": false,
                      "duration": 80,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "import { INestApplication } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport {\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  tcName,\n  testContainers,\n  fixturePostResponse,\n  fixtureUserArrayResponse,\n} from '@tresdoce-nestjs-toolkit/test-utils';\nimport { Repository } from 'typeorm';\n\nimport { TypeOrmClientModule } from '../typeorm/typeorm.module';\nimport { Post } from './utils/post.entity';\nimport { User } from './utils/user.entity';\n\nimport { configPostgres, configMySql, configMongo } from './utils';\n\njest.setTimeout(70000);\ndescribe('TypeOrm', () => {\n  describe('Postgres', () => {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository<Post>;\n\n    beforeAll(async () => {\n      container = await new testContainers('postgres:13', {\n        ...TCPostgresOptions,\n        containerName: `${tcName}-typeorm-postgres`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configPostgres],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([Post]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get('PostRepository');\n      await app.init();\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be defined', async () => {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it('should be return an array of post', async () => {\n      await repository.save([fixturePostResponse]);\n\n      const query = await repository.find();\n      expect(query).toEqual([fixturePostResponse]);\n    });\n  });\n\n  describe('MySql', () => {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository<Post>;\n\n    beforeAll(async () => {\n      container = await new testContainers('mysql:5.7', {\n        ...TCMySqlOptions,\n        containerName: `${tcName}-typeorm-mysql`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configMySql],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([Post]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get('PostRepository');\n      await app.init();\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be defined', async () => {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it('should be return an array of post', async () => {\n      await repository.save([fixturePostResponse]);\n\n      const query = await repository.find();\n      expect(query).toEqual([fixturePostResponse]);\n    });\n  });\n\n  describe('Mongo', () => {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository<User>;\n\n    beforeAll(async () => {\n      container = await new testContainers('mongo:5.0', {\n        ...TCMongoOptions,\n        containerName: `${tcName}-typeorm-mongo`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configMongo],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([User]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get('UserRepository');\n      await app.init();\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be defined', async () => {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it('should be return an array of user', async () => {\n      await repository.save(fixtureUserArrayResponse);\n\n      const query: User[] = await repository.find();\n      expect(query).toEqual(expect.any(Array));\n    });\n  });\n});\n",
                      "err": {},
                      "uuid": "961f6707-73bb-445b-b0a5-054de8be1001",
                      "parentUUID": "188bb0af-be76-427f-9c0b-9dd4f76cbc4a",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "23ed9ff5-ea5d-4b82-89f5-73f5b27da913",
                    "961f6707-73bb-445b-b0a5-054de8be1001"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 0,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 5000
                },
                {
                  "uuid": "188bb0af-be76-427f-9c0b-9dd4f76cbc4a",
                  "title": "MySql",
                  "fullFile": "/Users/maximilianodelgado/Projects/Mex/tresdoce-nestjs-toolkit/packages/typeorm/src/__test__/typeorm.module.spec.ts",
                  "file": "typeorm.module.spec.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "fullTitle": "TypeOrm > MySql > should be defined",
                      "title": "should be defined",
                      "timedOut": false,
                      "duration": 127,
                      "state": "passed",
                      "speed": "medium",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "import { INestApplication } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport {\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  tcName,\n  testContainers,\n  fixturePostResponse,\n  fixtureUserArrayResponse,\n} from '@tresdoce-nestjs-toolkit/test-utils';\nimport { Repository } from 'typeorm';\n\nimport { TypeOrmClientModule } from '../typeorm/typeorm.module';\nimport { Post } from './utils/post.entity';\nimport { User } from './utils/user.entity';\n\nimport { configPostgres, configMySql, configMongo } from './utils';\n\njest.setTimeout(70000);\ndescribe('TypeOrm', () => {\n  describe('Postgres', () => {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository<Post>;\n\n    beforeAll(async () => {\n      container = await new testContainers('postgres:13', {\n        ...TCPostgresOptions,\n        containerName: `${tcName}-typeorm-postgres`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configPostgres],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([Post]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get('PostRepository');\n      await app.init();\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be defined', async () => {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it('should be return an array of post', async () => {\n      await repository.save([fixturePostResponse]);\n\n      const query = await repository.find();\n      expect(query).toEqual([fixturePostResponse]);\n    });\n  });\n\n  describe('MySql', () => {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository<Post>;\n\n    beforeAll(async () => {\n      container = await new testContainers('mysql:5.7', {\n        ...TCMySqlOptions,\n        containerName: `${tcName}-typeorm-mysql`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configMySql],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([Post]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get('PostRepository');\n      await app.init();\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be defined', async () => {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it('should be return an array of post', async () => {\n      await repository.save([fixturePostResponse]);\n\n      const query = await repository.find();\n      expect(query).toEqual([fixturePostResponse]);\n    });\n  });\n\n  describe('Mongo', () => {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository<User>;\n\n    beforeAll(async () => {\n      container = await new testContainers('mongo:5.0', {\n        ...TCMongoOptions,\n        containerName: `${tcName}-typeorm-mongo`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configMongo],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([User]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get('UserRepository');\n      await app.init();\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be defined', async () => {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it('should be return an array of user', async () => {\n      await repository.save(fixtureUserArrayResponse);\n\n      const query: User[] = await repository.find();\n      expect(query).toEqual(expect.any(Array));\n    });\n  });\n});\n",
                      "err": {},
                      "uuid": "080d95da-bf51-45a0-ba18-00d8601761d4",
                      "parentUUID": "188bb0af-be76-427f-9c0b-9dd4f76cbc4a",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "fullTitle": "TypeOrm > MySql > should be return an array of post",
                      "title": "should be return an array of post",
                      "timedOut": false,
                      "duration": 58,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "import { INestApplication } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport {\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  tcName,\n  testContainers,\n  fixturePostResponse,\n  fixtureUserArrayResponse,\n} from '@tresdoce-nestjs-toolkit/test-utils';\nimport { Repository } from 'typeorm';\n\nimport { TypeOrmClientModule } from '../typeorm/typeorm.module';\nimport { Post } from './utils/post.entity';\nimport { User } from './utils/user.entity';\n\nimport { configPostgres, configMySql, configMongo } from './utils';\n\njest.setTimeout(70000);\ndescribe('TypeOrm', () => {\n  describe('Postgres', () => {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository<Post>;\n\n    beforeAll(async () => {\n      container = await new testContainers('postgres:13', {\n        ...TCPostgresOptions,\n        containerName: `${tcName}-typeorm-postgres`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configPostgres],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([Post]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get('PostRepository');\n      await app.init();\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be defined', async () => {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it('should be return an array of post', async () => {\n      await repository.save([fixturePostResponse]);\n\n      const query = await repository.find();\n      expect(query).toEqual([fixturePostResponse]);\n    });\n  });\n\n  describe('MySql', () => {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository<Post>;\n\n    beforeAll(async () => {\n      container = await new testContainers('mysql:5.7', {\n        ...TCMySqlOptions,\n        containerName: `${tcName}-typeorm-mysql`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configMySql],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([Post]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get('PostRepository');\n      await app.init();\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be defined', async () => {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it('should be return an array of post', async () => {\n      await repository.save([fixturePostResponse]);\n\n      const query = await repository.find();\n      expect(query).toEqual([fixturePostResponse]);\n    });\n  });\n\n  describe('Mongo', () => {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository<User>;\n\n    beforeAll(async () => {\n      container = await new testContainers('mongo:5.0', {\n        ...TCMongoOptions,\n        containerName: `${tcName}-typeorm-mongo`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configMongo],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([User]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get('UserRepository');\n      await app.init();\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be defined', async () => {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it('should be return an array of user', async () => {\n      await repository.save(fixtureUserArrayResponse);\n\n      const query: User[] = await repository.find();\n      expect(query).toEqual(expect.any(Array));\n    });\n  });\n});\n",
                      "err": {},
                      "uuid": "e906611d-eeab-4e62-84aa-34d55de483cc",
                      "parentUUID": "188bb0af-be76-427f-9c0b-9dd4f76cbc4a",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "080d95da-bf51-45a0-ba18-00d8601761d4",
                    "e906611d-eeab-4e62-84aa-34d55de483cc"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 0,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 5000
                },
                {
                  "uuid": "188bb0af-be76-427f-9c0b-9dd4f76cbc4a",
                  "title": "Mongo",
                  "fullFile": "/Users/maximilianodelgado/Projects/Mex/tresdoce-nestjs-toolkit/packages/typeorm/src/__test__/typeorm.module.spec.ts",
                  "file": "typeorm.module.spec.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "fullTitle": "TypeOrm > Mongo > should be defined",
                      "title": "should be defined",
                      "timedOut": false,
                      "duration": 2294,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "import { INestApplication } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport {\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  tcName,\n  testContainers,\n  fixturePostResponse,\n  fixtureUserArrayResponse,\n} from '@tresdoce-nestjs-toolkit/test-utils';\nimport { Repository } from 'typeorm';\n\nimport { TypeOrmClientModule } from '../typeorm/typeorm.module';\nimport { Post } from './utils/post.entity';\nimport { User } from './utils/user.entity';\n\nimport { configPostgres, configMySql, configMongo } from './utils';\n\njest.setTimeout(70000);\ndescribe('TypeOrm', () => {\n  describe('Postgres', () => {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository<Post>;\n\n    beforeAll(async () => {\n      container = await new testContainers('postgres:13', {\n        ...TCPostgresOptions,\n        containerName: `${tcName}-typeorm-postgres`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configPostgres],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([Post]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get('PostRepository');\n      await app.init();\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be defined', async () => {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it('should be return an array of post', async () => {\n      await repository.save([fixturePostResponse]);\n\n      const query = await repository.find();\n      expect(query).toEqual([fixturePostResponse]);\n    });\n  });\n\n  describe('MySql', () => {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository<Post>;\n\n    beforeAll(async () => {\n      container = await new testContainers('mysql:5.7', {\n        ...TCMySqlOptions,\n        containerName: `${tcName}-typeorm-mysql`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configMySql],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([Post]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get('PostRepository');\n      await app.init();\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be defined', async () => {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it('should be return an array of post', async () => {\n      await repository.save([fixturePostResponse]);\n\n      const query = await repository.find();\n      expect(query).toEqual([fixturePostResponse]);\n    });\n  });\n\n  describe('Mongo', () => {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository<User>;\n\n    beforeAll(async () => {\n      container = await new testContainers('mongo:5.0', {\n        ...TCMongoOptions,\n        containerName: `${tcName}-typeorm-mongo`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configMongo],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([User]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get('UserRepository');\n      await app.init();\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be defined', async () => {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it('should be return an array of user', async () => {\n      await repository.save(fixtureUserArrayResponse);\n\n      const query: User[] = await repository.find();\n      expect(query).toEqual(expect.any(Array));\n    });\n  });\n});\n",
                      "err": {},
                      "uuid": "a3a99e24-e583-46a0-84cd-36b469e14223",
                      "parentUUID": "188bb0af-be76-427f-9c0b-9dd4f76cbc4a",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "fullTitle": "TypeOrm > Mongo > should be return an array of user",
                      "title": "should be return an array of user",
                      "timedOut": false,
                      "duration": 47,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "import { INestApplication } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport {\n  TCMongoOptions,\n  TCMySqlOptions,\n  TCPostgresOptions,\n  tcName,\n  testContainers,\n  fixturePostResponse,\n  fixtureUserArrayResponse,\n} from '@tresdoce-nestjs-toolkit/test-utils';\nimport { Repository } from 'typeorm';\n\nimport { TypeOrmClientModule } from '../typeorm/typeorm.module';\nimport { Post } from './utils/post.entity';\nimport { User } from './utils/user.entity';\n\nimport { configPostgres, configMySql, configMongo } from './utils';\n\njest.setTimeout(70000);\ndescribe('TypeOrm', () => {\n  describe('Postgres', () => {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository<Post>;\n\n    beforeAll(async () => {\n      container = await new testContainers('postgres:13', {\n        ...TCPostgresOptions,\n        containerName: `${tcName}-typeorm-postgres`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configPostgres],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([Post]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get('PostRepository');\n      await app.init();\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be defined', async () => {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it('should be return an array of post', async () => {\n      await repository.save([fixturePostResponse]);\n\n      const query = await repository.find();\n      expect(query).toEqual([fixturePostResponse]);\n    });\n  });\n\n  describe('MySql', () => {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository<Post>;\n\n    beforeAll(async () => {\n      container = await new testContainers('mysql:5.7', {\n        ...TCMySqlOptions,\n        containerName: `${tcName}-typeorm-mysql`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configMySql],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([Post]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get('PostRepository');\n      await app.init();\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be defined', async () => {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it('should be return an array of post', async () => {\n      await repository.save([fixturePostResponse]);\n\n      const query = await repository.find();\n      expect(query).toEqual([fixturePostResponse]);\n    });\n  });\n\n  describe('Mongo', () => {\n    let app: INestApplication;\n    let container: testContainers;\n    let repository: Repository<User>;\n\n    beforeAll(async () => {\n      container = await new testContainers('mongo:5.0', {\n        ...TCMongoOptions,\n        containerName: `${tcName}-typeorm-mongo`,\n      });\n      await container.start();\n    });\n\n    afterAll(async () => {\n      await container.stop({ removeVolumes: true });\n    });\n\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        imports: [\n          ConfigModule.forRoot({\n            isGlobal: true,\n            load: [configMongo],\n          }),\n          TypeOrmClientModule,\n          TypeOrmClientModule.forFeature([User]),\n        ],\n      }).compile();\n      app = module.createNestApplication();\n      repository = module.get('UserRepository');\n      await app.init();\n    });\n\n    afterEach(async () => {\n      await app.close();\n    });\n\n    it('should be defined', async () => {\n      await expect(app).toBeDefined();\n    }, 50000);\n\n    it('should be return an array of user', async () => {\n      await repository.save(fixtureUserArrayResponse);\n\n      const query: User[] = await repository.find();\n      expect(query).toEqual(expect.any(Array));\n    });\n  });\n});\n",
                      "err": {},
                      "uuid": "a90c78ef-1708-45d0-9adc-010a93dade7b",
                      "parentUUID": "188bb0af-be76-427f-9c0b-9dd4f76cbc4a",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "a3a99e24-e583-46a0-84cd-36b469e14223",
                    "a90c78ef-1708-45d0-9adc-010a93dade7b"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 0,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 5000
                }
              ],
              "passes": [],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 0,
              "root": false,
              "rootEmpty": false,
              "_timeout": 5000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 5000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 5000
    }
  ]
}